import { utils } from 'ethers';
import xn from 'long';
import { keystore, authn, signature, publicKey, ciphertext, privateKey, message, content, messageApi, contact, invitation, composite, fetcher } from '@xmtp/proto';
import * as H from '@noble/secp256k1';
import { Mutex } from 'async-mutex';
import Ys from 'elliptic';

var Qi=Object.create;var An=Object.defineProperty;var Yi=Object.getOwnPropertyDescriptor;var Zi=Object.getOwnPropertyNames;var es=Object.getPrototypeOf,ts=Object.prototype.hasOwnProperty;var En=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports);var rs=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of Zi(e))!ts.call(n,i)&&i!==t&&An(n,i,{get:()=>e[i],enumerable:!(r=Yi(e,i))||r.enumerable});return n};var Sn=(n,e,t)=>(t=n!=null?Qi(es(n)):{},rs(e||!n||!n.__esModule?An(t,"default",{value:n,enumerable:!0}):t,n));var Nn=En((ra,Vn)=>{Vn.exports={webcrypto:window.crypto};});var di=En((Pp,Ir)=>{(function(){var n="input is invalid type",e="finalize already called",t=typeof window=="object",r=t?window:{};r.JS_SHA3_NO_WINDOW&&(t=!1);var i=!t&&typeof self=="object",o=!r.JS_SHA3_NO_NODE_JS&&typeof process=="object"&&process.versions&&process.versions.node;o?r=global:i&&(r=self);var a=!r.JS_SHA3_NO_COMMON_JS&&typeof Ir=="object"&&Ir.exports,c=typeof define=="function"&&define.amd,p=!r.JS_SHA3_NO_ARRAY_BUFFER&&typeof ArrayBuffer<"u",l="0123456789abcdef".split(""),v=[31,7936,2031616,520093696],b=[4,1024,262144,67108864],C=[1,256,65536,16777216],ie=[6,1536,393216,100663296],R=[0,8,16,24],Pe=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],it=[224,256,384,512],je=[128,256],hn=["hex","buffer","arrayBuffer","array","digest"],gn={128:168,256:136};(r.JS_SHA3_NO_NODE_JS||!Array.isArray)&&(Array.isArray=function(s){return Object.prototype.toString.call(s)==="[object Array]"}),p&&(r.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)&&(ArrayBuffer.isView=function(s){return typeof s=="object"&&s.buffer&&s.buffer.constructor===ArrayBuffer});for(var vn=function(s,d,u){return function(y){return new k(s,d,s).update(y)[u]()}},wn=function(s,d,u){return function(y,m){return new k(s,d,m).update(y)[u]()}},bn=function(s,d,u){return function(y,m,h,g){return fe["cshake"+s].update(y,m,h,g)[u]()}},Pn=function(s,d,u){return function(y,m,h,g){return fe["kmac"+s].update(y,m,h,g)[u]()}},Pt=function(s,d,u,y){for(var m=0;m<hn.length;++m){var h=hn[m];s[h]=d(u,y,h);}return s},Cn=function(s,d){var u=vn(s,d,"hex");return u.create=function(){return new k(s,d,s)},u.update=function(y){return u.create().update(y)},Pt(u,vn,s,d)},zi=function(s,d){var u=wn(s,d,"hex");return u.create=function(y){return new k(s,d,y)},u.update=function(y,m){return u.create(m).update(y)},Pt(u,wn,s,d)},$i=function(s,d){var u=gn[s],y=bn(s,d,"hex");return y.create=function(m,h,g){return !h&&!g?fe["shake"+s].create(m):new k(s,d,m).bytepad([h,g],u)},y.update=function(m,h,g,f){return y.create(h,g,f).update(m)},Pt(y,bn,s,d)},Wi=function(s,d){var u=gn[s],y=Pn(s,d,"hex");return y.create=function(m,h,g){return new Lr(s,d,h).bytepad(["KMAC",g],u).bytepad([m],u)},y.update=function(m,h,g,f){return y.create(m,g,f).update(h)},Pt(y,Pn,s,d)},Kn=[{name:"keccak",padding:C,bits:it,createMethod:Cn},{name:"sha3",padding:ie,bits:it,createMethod:Cn},{name:"shake",padding:v,bits:je,createMethod:zi},{name:"cshake",padding:b,bits:je,createMethod:$i},{name:"kmac",padding:b,bits:je,createMethod:Wi}],fe={},st=[],Ce=0;Ce<Kn.length;++Ce)for(var Xe=Kn[Ce],Ct=Xe.bits,ot=0;ot<Ct.length;++ot){var qr=Xe.name+"_"+Ct[ot];if(st.push(qr),fe[qr]=Xe.createMethod(Ct[ot],Xe.padding),Xe.name!=="sha3"){var Tn=Xe.name+Ct[ot];st.push(Tn),fe[Tn]=fe[qr];}}function k(s,d,u){this.blocks=[],this.s=[],this.padding=d,this.outputBits=u,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(s<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=u>>5,this.extraBytes=(u&31)>>3;for(var y=0;y<50;++y)this.s[y]=0;}k.prototype.update=function(s){if(this.finalized)throw new Error(e);var d,u=typeof s;if(u!=="string"){if(u==="object"){if(s===null)throw new Error(n);if(p&&s.constructor===ArrayBuffer)s=new Uint8Array(s);else if(!Array.isArray(s)&&(!p||!ArrayBuffer.isView(s)))throw new Error(n)}else throw new Error(n);d=!0;}for(var y=this.blocks,m=this.byteCount,h=s.length,g=this.blockCount,f=0,B=this.s,w,A;f<h;){if(this.reset)for(this.reset=!1,y[0]=this.block,w=1;w<g+1;++w)y[w]=0;if(d)for(w=this.start;f<h&&w<m;++f)y[w>>2]|=s[f]<<R[w++&3];else for(w=this.start;f<h&&w<m;++f)A=s.charCodeAt(f),A<128?y[w>>2]|=A<<R[w++&3]:A<2048?(y[w>>2]|=(192|A>>6)<<R[w++&3],y[w>>2]|=(128|A&63)<<R[w++&3]):A<55296||A>=57344?(y[w>>2]|=(224|A>>12)<<R[w++&3],y[w>>2]|=(128|A>>6&63)<<R[w++&3],y[w>>2]|=(128|A&63)<<R[w++&3]):(A=65536+((A&1023)<<10|s.charCodeAt(++f)&1023),y[w>>2]|=(240|A>>18)<<R[w++&3],y[w>>2]|=(128|A>>12&63)<<R[w++&3],y[w>>2]|=(128|A>>6&63)<<R[w++&3],y[w>>2]|=(128|A&63)<<R[w++&3]);if(this.lastByteIndex=w,w>=m){for(this.start=w-m,this.block=y[g],w=0;w<g;++w)B[w]^=y[w];at(B),this.reset=!0;}else this.start=w;}return this},k.prototype.encode=function(s,d){var u=s&255,y=1,m=[u];for(s=s>>8,u=s&255;u>0;)m.unshift(u),s=s>>8,u=s&255,++y;return d?m.push(y):m.unshift(y),this.update(m),m.length},k.prototype.encodeString=function(s){var d,u=typeof s;if(u!=="string"){if(u==="object"){if(s===null)throw new Error(n);if(p&&s.constructor===ArrayBuffer)s=new Uint8Array(s);else if(!Array.isArray(s)&&(!p||!ArrayBuffer.isView(s)))throw new Error(n)}else throw new Error(n);d=!0;}var y=0,m=s.length;if(d)y=m;else for(var h=0;h<s.length;++h){var g=s.charCodeAt(h);g<128?y+=1:g<2048?y+=2:g<55296||g>=57344?y+=3:(g=65536+((g&1023)<<10|s.charCodeAt(++h)&1023),y+=4);}return y+=this.encode(y*8),this.update(s),y},k.prototype.bytepad=function(s,d){for(var u=this.encode(d),y=0;y<s.length;++y)u+=this.encodeString(s[y]);var m=d-u%d,h=[];return h.length=m,this.update(h),this},k.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var s=this.blocks,d=this.lastByteIndex,u=this.blockCount,y=this.s;if(s[d>>2]|=this.padding[d&3],this.lastByteIndex===this.byteCount)for(s[0]=s[u],d=1;d<u+1;++d)s[d]=0;for(s[u-1]|=2147483648,d=0;d<u;++d)y[d]^=s[d];at(y);}},k.prototype.toString=k.prototype.hex=function(){this.finalize();for(var s=this.blockCount,d=this.s,u=this.outputBlocks,y=this.extraBytes,m=0,h=0,g="",f;h<u;){for(m=0;m<s&&h<u;++m,++h)f=d[m],g+=l[f>>4&15]+l[f&15]+l[f>>12&15]+l[f>>8&15]+l[f>>20&15]+l[f>>16&15]+l[f>>28&15]+l[f>>24&15];h%s===0&&(at(d),m=0);}return y&&(f=d[m],g+=l[f>>4&15]+l[f&15],y>1&&(g+=l[f>>12&15]+l[f>>8&15]),y>2&&(g+=l[f>>20&15]+l[f>>16&15])),g},k.prototype.arrayBuffer=function(){this.finalize();var s=this.blockCount,d=this.s,u=this.outputBlocks,y=this.extraBytes,m=0,h=0,g=this.outputBits>>3,f;y?f=new ArrayBuffer(u+1<<2):f=new ArrayBuffer(g);for(var B=new Uint32Array(f);h<u;){for(m=0;m<s&&h<u;++m,++h)B[h]=d[m];h%s===0&&at(d);}return y&&(B[m]=d[m],f=f.slice(0,g)),f},k.prototype.buffer=k.prototype.arrayBuffer,k.prototype.digest=k.prototype.array=function(){this.finalize();for(var s=this.blockCount,d=this.s,u=this.outputBlocks,y=this.extraBytes,m=0,h=0,g=[],f,B;h<u;){for(m=0;m<s&&h<u;++m,++h)f=h<<2,B=d[m],g[f]=B&255,g[f+1]=B>>8&255,g[f+2]=B>>16&255,g[f+3]=B>>24&255;h%s===0&&at(d);}return y&&(f=h<<2,B=d[m],g[f]=B&255,y>1&&(g[f+1]=B>>8&255),y>2&&(g[f+2]=B>>16&255)),g};function Lr(s,d,u){k.call(this,s,d,u);}Lr.prototype=new k,Lr.prototype.finalize=function(){return this.encode(this.outputBits,!0),k.prototype.finalize.call(this)};var at=function(s){var d,u,y,m,h,g,f,B,w,A,Kt,Tt,At,Et,St,xt,kt,Bt,Mt,Rt,Dt,It,Ut,Vt,Nt,Ot,_t,qt,Lt,Ft,Ht,Gt,Jt,jt,Xt,zt,$t,Wt,Qt,Yt,Zt,er,tr,rr,nr,ir,sr,or,ar,cr,pr,dr,ur,yr,lr,mr,fr,hr,gr,vr,wr,br,Pr;for(y=0;y<48;y+=2)m=s[0]^s[10]^s[20]^s[30]^s[40],h=s[1]^s[11]^s[21]^s[31]^s[41],g=s[2]^s[12]^s[22]^s[32]^s[42],f=s[3]^s[13]^s[23]^s[33]^s[43],B=s[4]^s[14]^s[24]^s[34]^s[44],w=s[5]^s[15]^s[25]^s[35]^s[45],A=s[6]^s[16]^s[26]^s[36]^s[46],Kt=s[7]^s[17]^s[27]^s[37]^s[47],Tt=s[8]^s[18]^s[28]^s[38]^s[48],At=s[9]^s[19]^s[29]^s[39]^s[49],d=Tt^(g<<1|f>>>31),u=At^(f<<1|g>>>31),s[0]^=d,s[1]^=u,s[10]^=d,s[11]^=u,s[20]^=d,s[21]^=u,s[30]^=d,s[31]^=u,s[40]^=d,s[41]^=u,d=m^(B<<1|w>>>31),u=h^(w<<1|B>>>31),s[2]^=d,s[3]^=u,s[12]^=d,s[13]^=u,s[22]^=d,s[23]^=u,s[32]^=d,s[33]^=u,s[42]^=d,s[43]^=u,d=g^(A<<1|Kt>>>31),u=f^(Kt<<1|A>>>31),s[4]^=d,s[5]^=u,s[14]^=d,s[15]^=u,s[24]^=d,s[25]^=u,s[34]^=d,s[35]^=u,s[44]^=d,s[45]^=u,d=B^(Tt<<1|At>>>31),u=w^(At<<1|Tt>>>31),s[6]^=d,s[7]^=u,s[16]^=d,s[17]^=u,s[26]^=d,s[27]^=u,s[36]^=d,s[37]^=u,s[46]^=d,s[47]^=u,d=A^(m<<1|h>>>31),u=Kt^(h<<1|m>>>31),s[8]^=d,s[9]^=u,s[18]^=d,s[19]^=u,s[28]^=d,s[29]^=u,s[38]^=d,s[39]^=u,s[48]^=d,s[49]^=u,Et=s[0],St=s[1],ir=s[11]<<4|s[10]>>>28,sr=s[10]<<4|s[11]>>>28,qt=s[20]<<3|s[21]>>>29,Lt=s[21]<<3|s[20]>>>29,vr=s[31]<<9|s[30]>>>23,wr=s[30]<<9|s[31]>>>23,er=s[40]<<18|s[41]>>>14,tr=s[41]<<18|s[40]>>>14,jt=s[2]<<1|s[3]>>>31,Xt=s[3]<<1|s[2]>>>31,xt=s[13]<<12|s[12]>>>20,kt=s[12]<<12|s[13]>>>20,or=s[22]<<10|s[23]>>>22,ar=s[23]<<10|s[22]>>>22,Ft=s[33]<<13|s[32]>>>19,Ht=s[32]<<13|s[33]>>>19,br=s[42]<<2|s[43]>>>30,Pr=s[43]<<2|s[42]>>>30,yr=s[5]<<30|s[4]>>>2,lr=s[4]<<30|s[5]>>>2,zt=s[14]<<6|s[15]>>>26,$t=s[15]<<6|s[14]>>>26,Bt=s[25]<<11|s[24]>>>21,Mt=s[24]<<11|s[25]>>>21,cr=s[34]<<15|s[35]>>>17,pr=s[35]<<15|s[34]>>>17,Gt=s[45]<<29|s[44]>>>3,Jt=s[44]<<29|s[45]>>>3,Vt=s[6]<<28|s[7]>>>4,Nt=s[7]<<28|s[6]>>>4,mr=s[17]<<23|s[16]>>>9,fr=s[16]<<23|s[17]>>>9,Wt=s[26]<<25|s[27]>>>7,Qt=s[27]<<25|s[26]>>>7,Rt=s[36]<<21|s[37]>>>11,Dt=s[37]<<21|s[36]>>>11,dr=s[47]<<24|s[46]>>>8,ur=s[46]<<24|s[47]>>>8,rr=s[8]<<27|s[9]>>>5,nr=s[9]<<27|s[8]>>>5,Ot=s[18]<<20|s[19]>>>12,_t=s[19]<<20|s[18]>>>12,hr=s[29]<<7|s[28]>>>25,gr=s[28]<<7|s[29]>>>25,Yt=s[38]<<8|s[39]>>>24,Zt=s[39]<<8|s[38]>>>24,It=s[48]<<14|s[49]>>>18,Ut=s[49]<<14|s[48]>>>18,s[0]=Et^~xt&Bt,s[1]=St^~kt&Mt,s[10]=Vt^~Ot&qt,s[11]=Nt^~_t&Lt,s[20]=jt^~zt&Wt,s[21]=Xt^~$t&Qt,s[30]=rr^~ir&or,s[31]=nr^~sr&ar,s[40]=yr^~mr&hr,s[41]=lr^~fr&gr,s[2]=xt^~Bt&Rt,s[3]=kt^~Mt&Dt,s[12]=Ot^~qt&Ft,s[13]=_t^~Lt&Ht,s[22]=zt^~Wt&Yt,s[23]=$t^~Qt&Zt,s[32]=ir^~or&cr,s[33]=sr^~ar&pr,s[42]=mr^~hr&vr,s[43]=fr^~gr&wr,s[4]=Bt^~Rt&It,s[5]=Mt^~Dt&Ut,s[14]=qt^~Ft&Gt,s[15]=Lt^~Ht&Jt,s[24]=Wt^~Yt&er,s[25]=Qt^~Zt&tr,s[34]=or^~cr&dr,s[35]=ar^~pr&ur,s[44]=hr^~vr&br,s[45]=gr^~wr&Pr,s[6]=Rt^~It&Et,s[7]=Dt^~Ut&St,s[16]=Ft^~Gt&Vt,s[17]=Ht^~Jt&Nt,s[26]=Yt^~er&jt,s[27]=Zt^~tr&Xt,s[36]=cr^~dr&rr,s[37]=pr^~ur&nr,s[46]=vr^~br&yr,s[47]=wr^~Pr&lr,s[8]=It^~Et&xt,s[9]=Ut^~St&kt,s[18]=Gt^~Vt&Ot,s[19]=Jt^~Nt&_t,s[28]=er^~jt&zt,s[29]=tr^~Xt&$t,s[38]=dr^~rr&ir,s[39]=ur^~nr&sr,s[48]=br^~yr&mr,s[49]=Pr^~lr&fr,s[0]^=Pe[y],s[1]^=Pe[y+1];};if(a)Ir.exports=fe;else {for(Ce=0;Ce<st.length;++Ce)r[st[Ce]]=fe[st[Ce]];c&&define(function(){return fe});}})();});var Re=n=>`/xmtp/0/${n}/proto`,se=(n,e)=>{let t=[utils.getAddress(n),utils.getAddress(e)];return t.sort(),Re(`dm-${t.join("-")}`)},pt=n=>Re(`m-${n}`),dt=n=>Re(`contact-${utils.getAddress(n)}`),de=n=>Re(`intro-${utils.getAddress(n)}`),Ke=n=>Re(`invite-${utils.getAddress(n)}`),Fr=n=>Re(`privatestore-${n}`);var Cr=n=>new Promise(e=>setTimeout(e,n));var ns=n=>!!n;async function ze(n,e,t,r,i=ns,o=1){let a=typeof o=="number"?o:1;try{return await n(...e)}catch(c){if(!i(c)||a>t)throw c;return await Cr(r),ze(n,e,t,r,i,a+1)}}async function*Hr(n,e){for await(let t of n){let r=await Promise.allSettled(t.map(e)),i=[];for(let o of r)o.status==="fulfilled"?i.push(o.value):console.warn("Failed to process envelope due to reason: ",o.reason);yield i;}}function D(n){return xn.fromNumber(n.valueOf()).multiply(1e6)}function _(n){return new Date(n.divide(1e6).toNumber())}var ue=n=>n&&D(n).toString(),is=n=>{if(n)return _(xn.fromString(n))};var{b64Decode:Kr,b64Encode:kn}=fetcher;function Gr(n,e){let t=new Uint8Array(n.length+e.length);return t.set(n),t.set(e,n.length),t}function Bn(n){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,n,!0),new Uint8Array(e)}function Mn(n){let e=n.buffer;return new DataView(e).getInt32(0,!0)}var Rn=()=>typeof window<"u"&&typeof window.document<"u";function Tr(n){let[e,t,...r]=n.split(".");return {major:Number(e),minor:Number(t),patch:r.join(".")}}function Dn(n,e){return !n||!e?!0:Tr(n).major===Tr(e).major}function In(n,e){if(!n||!e)return !1;let t=Tr(n),r=Tr(e);return t.major!==r.major?t.major>r.major:t.minor!==r.minor?t.minor>r.minor:!t.patch||!r.patch?!1:os(t.patch,r.patch)}function os(n,e){let[t,r]=n.split("-"),[i,o]=e.split("-");if(Number(t)!==Number(i))return Number(t)>Number(i);if(!r||!o)return !1;let[a,c]=r.split("."),[p,l]=o.split(".");return a!==p?!0:Number(c)>Number(l)}var F=class{topics;client;messages;resolvers;callback;subscriptionManager;onConnectionLost;constructor(e,t,r,i,o){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(r,i),this.onConnectionLost=o;}newMessageCallback(e,t){return async r=>{if(r.message)try{let i=await e(r);if(!i)return;if(t){let a=t(i);a&&this.resubscribeToTopics(a);}let o=this.resolvers.pop();o?o({value:i}):this.messages.unshift(i);}catch(i){console.warn(i);}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},async e=>{this.callback&&await this?.callback(e);},this.onConnectionLost);}static async create(e,t,r,i,o){let a=new F(e,t,r,i,o);return await a.start(),a}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach(e=>e({value:void 0,done:!0})),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){let e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise(t=>this.resolvers.unshift(t)):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if(typeof this.subscriptionManager?.updateContentTopics=="function")return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},async t=>{this.callback&&await this?.callback(t);},this.onConnectionLost);}};var Jr=32,jr=12,as=16,I=class{aes256GcmHkdfSha256;constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<as)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(e.aes256GcmHkdfSha256.hkdfSalt.length!==Jr)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(e.aes256GcmHkdfSha256.gcmNonce.length!==jr)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256;}toBytes(){return ciphertext.Ciphertext.encode(this).finish()}static fromBytes(e){return new I(ciphertext.Ciphertext.decode(e))}};var On=Sn(Nn(),1),cs=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0,ps=cs??On.webcrypto,M=ps;var ds=new ArrayBuffer(0);async function U(n){return new Uint8Array(await M.subtle.digest("SHA-256",n))}async function ee(n,e,t){let r=M.getRandomValues(new Uint8Array(Jr)),i=M.getRandomValues(new Uint8Array(jr)),o=await qn(e,r),a=await M.subtle.encrypt(_n(i,t),o,n);return new I({aes256GcmHkdfSha256:{payload:new Uint8Array(a),hkdfSalt:r,gcmNonce:i}})}async function X(n,e,t){if(!n.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");let r=await qn(e,n.aes256GcmHkdfSha256.hkdfSalt),i=await M.subtle.decrypt(_n(n.aes256GcmHkdfSha256.gcmNonce,t),r,n.aes256GcmHkdfSha256.payload);return new Uint8Array(i)}function _n(n,e){let t={name:"AES-GCM",iv:n};return e&&(t.additionalData=e),t}async function qn(n,e){let t=await M.subtle.importKey("raw",n,"HKDF",!1,["deriveKey"]);return M.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:e,info:ds},t,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}var z=H.utils.bytesToHex;function $(n){n.startsWith("0x")&&(n=n.slice(2));let e=new Uint8Array(n.length/2);for(let t=0;t<e.length;t++){let r=t*2;e[t]=Number.parseInt(n.slice(r,r+2),16);}return e}function Te(n,e){if(n.length!==e.length)return !1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return !1;return !0}function Hn(n){if(n.bytes.length!==32)throw new Error(`invalid private key length: ${n.bytes.length}`)}var O=class{createdNs;secp256k1;publicKey;constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(Hn(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new E(e.publicKey);}static async generate(e){let t={bytes:H.utils.randomPrivateKey()},r=xn.fromNumber(new Date().getTime()).mul(1e6),i=new re({secp256k1Uncompressed:{bytes:H.getPublicKey(t.bytes)},createdNs:r}),o=await e.signKey(i);return new O({secp256k1:t,createdNs:r,publicKey:o})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){let[t,r]=await H.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new S({ecdsaCompact:{bytes:t,recovery:r}})}async signKey(e){let t=e.toBytes(),r=await U(t),i=await this.sign(r);return new E({keyBytes:t,signature:i})}static async signerKey(e,t){let r=await U(e.bytesToSign());return Xr(r,t)}sharedSecret(e){return H.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,r){let i=this.sharedSecret(t);return ee(e,i,r)}decrypt(e,t,r){let i=this.sharedSecret(t);return X(e,i,r)}matches(e){return this.publicKey.equals(e)}equals(e){return Te(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return privateKey.SignedPrivateKey.encode(this).finish()}validatePublicKey(){let e=H.getPublicKey(this.secp256k1.bytes);return Te(e,this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new O(privateKey.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new O({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:E.fromLegacyKey(e.publicKey,t)})}},te=class{timestamp;secp256k1;publicKey;constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(Hn(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new V(e.publicKey);}static generate(){let e={bytes:H.utils.randomPrivateKey()},t=xn.fromNumber(new Date().getTime());return new te({secp256k1:e,timestamp:t,publicKey:new V({secp256k1Uncompressed:{bytes:H.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){let[t,r]=await H.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new S({ecdsaCompact:{bytes:t,recovery:r}})}async signKey(e){let t=await U(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return H.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,r){let i=this.sharedSecret(t);return ee(e,i,r)}decrypt(e,t,r){let i=this.sharedSecret(t);return X(e,i,r)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){let e=H.getPublicKey(this.secp256k1.bytes);return Te(e,this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return privateKey.PrivateKey.encode(this).finish()}static fromBytes(e){return new te(privateKey.PrivateKey.decode(e))}};function jn(n){if(n.bytes.length!==64)throw new Error(`invalid signature length: ${n.bytes.length}`);if(n.recovery!==0&&n.recovery!==1)throw new Error(`invalid recovery bit: ${n.recovery}`)}function Xn(n,e){return n.recovery===e.recovery&&Te(n.bytes,e.bytes)}function Xr(n,e){let t=H.recoverPublicKey(n,e.bytes,e.recovery);return t?new re({secp256k1Uncompressed:{bytes:t},createdNs:xn.fromNumber(0)}):void 0}var S=class{ecdsaCompact;walletEcdsaCompact;constructor(e){if(e.ecdsaCompact)jn(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else if(e.walletEcdsaCompact)jn(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact;else throw new Error("invalid signature")}async signerKey(e){return this.ecdsaCompact?O.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?oe.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=H.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else if(this.walletEcdsaCompact)t=H.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery);else throw new Error("invalid v1 signature");return t?new V({secp256k1Uncompressed:{bytes:t},timestamp:xn.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?Xn(this.ecdsaCompact,e.ecdsaCompact):this.walletEcdsaCompact&&e.walletEcdsaCompact?Xn(this.walletEcdsaCompact,e.walletEcdsaCompact):!1}toBytes(){return signature.Signature.encode(this).finish()}static fromBytes(e){return new S(signature.Signature.decode(e))}};var oe=class{wallet;constructor(e){this.wallet=e;}static identitySigRequestText(e){return `XMTP : Create Identity
${z(e)}

For more info: https://xmtp.org/signatures/`}static signerKey(e,t){let r=$(utils.hashMessage(this.identitySigRequestText(e.bytesToSign())));return Xr(r,t)}async signKey(e){let t=e.toBytes(),r=await this.wallet.signMessage(oe.identitySigRequestText(t)),i=utils.splitSignature(r),o=$(i.r),a=$(i.s),c=new Uint8Array(64);c.set(o),c.set(a,o.length);let p=new S({walletEcdsaCompact:{bytes:c,recovery:i.recoveryParam}});return new E({keyBytes:t,signature:p})}};function ls(n){if(n.bytes.length!==65)throw new Error(`invalid public key length: ${n.bytes.length}`);if(n.bytes[0]!==4)throw new Error(`unrecognized public key prefix: ${n.bytes[0]}`)}var ms=new xn(10**9).mul(10**9),re=class{createdNs;secp256k1Uncompressed;constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");ls(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned();}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(ms)}get timestamp(){return (this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return e.ecdsaCompact?H.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes):!1}async verifyKey(e){if(!e.signature)return !1;let t=await U(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return Te(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return utils.computeAddress(this.secp256k1Uncompressed.bytes)}toBytes(){return publicKey.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new re(publicKey.UnsignedPublicKey.decode(e))}},E=class extends re{keyBytes;signature;constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(publicKey.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new S(e.signature);}get unsignedKey(){return new re({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");let e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return publicKey.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new E(publicKey.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new S({ecdsaCompact:e.walletEcdsaCompact})),new V({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let r=e.signature;return t&&(r=new S({walletEcdsaCompact:r.ecdsaCompact})),new E({keyBytes:e.bytesToSign(),signature:r})}},V=class extends re{signature;constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new S({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new S(e.signature));}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return publicKey.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){let t=await e.signMessage(oe.identitySigRequestText(this.bytesToSign())),r=utils.splitSignature(t),i=$(r.r),o=$(r.s),a=new Uint8Array(64);a.set(i),a.set(o,i.length),this.signature=new S({ecdsaCompact:{bytes:a,recovery:r.recoveryParam}});}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");let e=$(utils.hashMessage(oe.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return publicKey.PublicKey.encode(this).finish()}static fromBytes(e){return new V(publicKey.PublicKey.decode(e))}};var T=class{identityKey;preKey;constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new E(e.identityKey),this.preKey=new E(e.preKey);}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return publicKey.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new P({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){let t=publicKey.SignedPublicKeyBundle.decode(e);return new T(t)}static fromLegacyBundle(e){return new T({identityKey:E.fromLegacyKey(e.identityKey,!0),preKey:E.fromLegacyKey(e.preKey)})}},P=class{identityKey;preKey;constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new V(e.identityKey),this.preKey=new V(e.preKey);}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return publicKey.PublicKeyBundle.encode(this).finish()}static fromBytes(e){let t=publicKey.PublicKeyBundle.decode(e);return new P(t)}};var ut=class extends Error{constructor(e){super(`no pre-key matches: ${z(e.secp256k1Uncompressed.bytes)}`);}};var G=class{identityKey;preKeys;version=2;_publicKeyBundle;constructor(e){if(!e.identityKey)throw new Error("missing identity key");this.identityKey=new O(e.identityKey),this.preKeys=(e.preKeys||[]).map(t=>new O(t));}static async generate(e){let t=await O.generate(new oe(e)),r=new G({identityKey:t,preKeys:[]});return await r.addPreKey(),r}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){let t=this.preKeys.find(r=>r.matches(e));if(!t)throw new ut(e);return t}async addPreKey(){this._publicKeyBundle=void 0;let e=await O.generate(this.identityKey);this.preKeys.unshift(e);}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new T({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,r){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let i,o,a;r?(a=this.findPreKey(t),i=a.sharedSecret(e.identityKey),o=this.identityKey.sharedSecret(e.preKey)):(a=this.findPreKey(t),i=this.identityKey.sharedSecret(e.preKey),o=a.sharedSecret(e.identityKey));let c=a.sharedSecret(e.preKey),p=new Uint8Array(i.length+o.length+c.length);return p.set(i,0),p.set(o,i.length),p.set(c,i.length+o.length),p}encode(){return privateKey.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return this.identityKey.validatePublicKey()?this.preKeys.every(e=>e.validatePublicKey()):!1}equals(e){if(this.preKeys.length!==e.preKeys.length)return !1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return !1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new G({identityKey:O.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map(t=>O.fromLegacyKey(t))})}},N=class{identityKey;preKeys;version=1;_publicKeyBundle;constructor(e){if(!e.identityKey)throw new Error("missing identity key");this.identityKey=new te(e.identityKey),this.preKeys=(e.preKeys||[]).map(t=>new te(t));}static async generate(e){let t=te.generate();e&&await t.publicKey.signWithWallet(e);let r=new N({identityKey:t,preKeys:[]});return await r.addPreKey(),r}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){let t=this.preKeys.find(r=>r.matches(e));if(!t)throw new ut(e);return t}async addPreKey(){this._publicKeyBundle=void 0;let e=te.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e);}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new P({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return this.identityKey.validatePublicKey()?this.preKeys.every(e=>e.validatePublicKey()):!1}async sharedSecret(e,t,r){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let i,o,a;r?(a=this.findPreKey(t),i=a.sharedSecret(e.identityKey),o=this.identityKey.sharedSecret(e.preKey)):(a=this.findPreKey(t),i=this.identityKey.sharedSecret(e.preKey),o=a.sharedSecret(e.identityKey));let c=a.sharedSecret(e.preKey),p=new Uint8Array(i.length+o.length+c.length);return p.set(i,0),p.set(o,i.length),p.set(c,i.length+o.length),p}encode(){return privateKey.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}};function De(n){let e=privateKey.PrivateKeyBundle.decode(n);if(e.v1)return new N(e.v1);if(e.v2)return new G(e.v2);throw new Error("unknown private key bundle version")}var fs=16,hs=65,gs=32,vs=16,ws=n=>{if(n.iv.length!==fs)throw new Error("Invalid iv length");if(n.ephemeralPublicKey.length!==hs)throw new Error("Invalid ephemPublicKey length");if(n.ciphertext.length<1||n.ciphertext.length%vs!==0)throw new Error("Invalid ciphertext length");if(n.mac.length!==gs)throw new Error("Invalid mac length")},ye=class{eciesBytes;signature;ciphertext;constructor({eciesBytes:e,signature:t}){if(!e||!e.length)throw new Error("eciesBytes is empty");if(!t)throw new Error("signature is undefined");this.eciesBytes=e,this.signature=new S(t),this.ciphertext=ciphertext.SignedEciesCiphertext_Ecies.decode(e);}toBytes(){return ciphertext.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await U(this.eciesBytes))}static fromBytes(e){let t=ciphertext.SignedEciesCiphertext.decode(e);return new ye(t)}static async create(e,t){ws(e);let r=ciphertext.SignedEciesCiphertext_Ecies.encode(e).finish(),i=await t.sign(await U(r));return new ye({eciesBytes:r,signature:i})}};var yt=class{messageEnvelope;onSend;constructor(e,t){this.messageEnvelope=e,this.onSend=t;}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return z(await U(this.messageEnvelope.message))}async send(){await this.onSend();}};var K=class extends Error{code;constructor(e,t){super(t),this.code=e;}};var Ie=n=>{if(n.error)throw new K(n.error.code,n.error.message);if(!n.result)throw new K(keystore.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in n.result&&!n.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in n.result&&!n.result.decrypted)throw new Error("Missing decrypted result");return n.result},kr=(n,e)=>({requests:n.map(t=>{let r=new P({identityKey:t.header.sender?.identityKey,preKey:t.header.sender?.preKey}),i=e.equals(r);return {payload:t.ciphertext,peerKeys:i?new P({identityKey:t.header.recipient?.identityKey,preKey:t.header.recipient?.preKey}):r,headerBytes:t.headerBytes,isSender:i}})});var W=class{authorityId;typeId;versionMajor;versionMinor;constructor(e){this.authorityId=e.authorityId,this.typeId=e.typeId,this.versionMajor=e.versionMajor,this.versionMinor=e.versionMinor;}toString(){return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`}static fromString(e){let[t,r]=e.split(":"),[i,o]=t.split("/"),[a,c]=r.split(".");return new W({authorityId:i,typeId:o,versionMajor:Number(a),versionMinor:Number(c)})}sameAs(e){return this.authorityId===e.authorityId&&this.typeId===e.typeId}},Ps=new W({authorityId:"xmtp.org",typeId:"fallback",versionMajor:1,versionMinor:0});var Ee=new W({authorityId:"xmtp.org",typeId:"text",versionMajor:1,versionMinor:0});var lt=class{get contentType(){return Ee}encode(e){return {type:Ee,parameters:{encoding:"UTF-8"},content:new TextEncoder().encode(e)}}decode(e){let t=e.parameters.encoding;if(t&&t!=="UTF-8")throw new Error(`unrecognized encoding ${t}`);return new TextDecoder().decode(e.content)}fallback(e){}};var Q=class{conversationVersion="v1";peerAddress;createdAt;context=void 0;client;constructor(e,t,r){this.peerAddress=utils.getAddress(t),this.client=e,this.createdAt=r;}get clientAddress(){return this.client.address}get topic(){return se(this.peerAddress,this.client.address)}get ephemeralTopic(){return se(this.peerAddress,this.client.address).replace("/xmtp/0/dm-","/xmtp/0/dmE-")}async messages(e){let t=se(this.peerAddress,this.client.address),r=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(r,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");let t=await this.processEnvelope(e),r=await this.decryptBatch([t],e.contentTopic,!0);if(!r.length)throw new Error("No results");return r[0]}async prepareMessage(e,t){let r,i=await this.client.getUserContact(this.peerAddress);if(!i)throw new Error(`recipient ${this.peerAddress} is not registered`);i instanceof P||(i=i.toLegacyBundle()),this.client.contacts.has(this.peerAddress)?r=[this.topic]:(r=[de(this.peerAddress),de(this.client.address),this.topic],this.client.contacts.add(this.peerAddress));let o=await this.client.encodeContent(e,t),a=await this.createMessage(o,i,t?.timestamp),c={contentTopic:this.topic,message:a.toBytes(),timestampNs:ue(a.sent)};return new yt(c,async()=>{await this.client.publishEnvelopes(r.map(p=>({contentTopic:p,message:a.toBytes(),timestamp:a.sent})));})}streamMessages(e){return F.create(this.client,[this.topic],async t=>this.decodeMessage(t),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");let r=await J.fromBytes(e),{senderAddress:i,recipientAddress:o}=r;if(!i||!o||!t||se(i,o)!==this.topic)throw new Error("Headers do not match intended recipient");return r}streamEphemeral(e){return F.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let r,i=await this.client.getUserContact(this.peerAddress);if(!i)throw new Error(`recipient ${this.peerAddress} is not registered`);i instanceof P||(i=i.toLegacyBundle());let o=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.has(this.peerAddress)?r=[this.topic]:(r=[de(this.peerAddress),de(this.client.address),o],this.client.contacts.add(this.peerAddress));let a=t?.contentType||Ee,c=await this.client.encodeContent(e,t),p=await this.createMessage(c,i,t?.timestamp);return await this.client.publishEnvelopes(r.map(l=>({contentTopic:l,message:p.toBytes(),timestamp:p.sent}))),q.fromV1Message(p,e,a,c,r[0],this)}async decryptBatch(e,t,r=!1){let i=(await this.client.keystore.decryptV1(kr(e,this.client.publicKeyBundle))).responses,o=[];for(let a=0;a<i.length;a++){let c=i[a],p=e[a];try{let{decrypted:l}=Ie(c);o.push(await this.buildDecodedMessage(p,l,t));}catch(l){if(r)throw l;console.warn("Error decoding content",l);}}return o}async buildDecodedMessage(e,t,r){let{content:i,contentType:o,error:a,contentFallback:c}=await this.client.decodeContent(t);return q.fromV1Message(e,i,o,t,r,this,a,c)}async createMessage(e,t,r){return r=r||new Date,J.encode(this.client.keystore,e,this.client.publicKeyBundle,t,r)}},ae=class{conversationVersion="v2";client;topic;peerAddress;createdAt;context;constructor(e,t,r,i,o){this.topic=t,this.createdAt=i,this.context=o,this.client=e,this.peerAddress=r;}get clientAddress(){return this.client.address}async messages(e){let t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/xmtp/0/m","/xmtp/0/mE")}streamEphemeral(e){return F.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return F.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let r=await this.client.encodeContent(e,t),i=await this.createMessage(r,t?.timestamp),o;t?.ephemeral?o=this.ephemeralTopic:o=this.topic,await this.client.publishEnvelopes([{contentTopic:o,message:i.toBytes(),timestamp:i.sent}]);let a=t?.contentType||Ee;return q.fromV2Message(i,e,a,this.topic,r,this,this.client.address)}async createMessage(e,t){let r={topic:this.topic,createdNs:D(t||new Date)},i=message.MessageHeaderV2.encode(r).finish(),o=await U(Gr(i,e)),a={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:o,prekeyIndex:0,identityKey:void 0})},c=content.SignedContent.encode(a).finish(),p=await this.encryptMessage(c,i),l={v1:void 0,v2:{headerBytes:i,ciphertext:p}},v=message.Message.encode(l).finish();return Se.create(l,r,v)}async decryptBatch(e,t=!1){let r=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,i=[];for(let o=0;o<r.length;o++){let a=r[o],c=e[o];try{let{decrypted:p}=Ie(a);i.push(await this.buildDecodedMessage(c,p));}catch(p){if(t)throw p;console.warn("Error decoding content",p);}}return i}buildDecryptRequest(e){return {requests:e.map(t=>({payload:t.ciphertext,headerBytes:t.headerBytes,contentTopic:this.topic}))}}async encryptMessage(e,t){let{responses:r}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(r.length!==1)throw new Error("Invalid response length");let{encrypted:i}=Ie(r[0]);return i}async buildDecodedMessage(e,t){let r=content.SignedContent.decode(t);if(!r.sender?.identityKey||!r.sender?.preKey||!r.signature)throw new Error("incomplete signed content");await Ks(r);let i=await U(Gr(e.headerBytes,r.payload));if(!new E(r.sender?.preKey).verify(new S(r.signature),i))throw new Error("invalid signature");let o=await new T(r.sender).walletSignatureAddress(),{content:a,contentType:c,error:p,contentFallback:l}=await this.client.decodeContent(r.payload);return q.fromV2Message(e,a,c,this.topic,r.payload,this,o,p,l)}async prepareMessage(e,t){let r=await this.client.encodeContent(e,t),i=await this.createMessage(r,t?.timestamp),a={contentTopic:t?.ephemeral?this.ephemeralTopic:this.topic,message:i.toBytes(),timestampNs:ue(i.sent)};return new yt(a,async()=>{await this.client.publishEnvelopes([{contentTopic:this.topic,message:i.toBytes(),timestamp:i.sent}]);})}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");let t=message.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");let r=message.MessageHeaderV2.decode(t.v2.headerBytes);if(r.topic!==this.topic)throw new Error("topic mismatch");return Se.create(t,r,e.message)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");let t=await this.processEnvelope(e),r=await this.decryptBatch([t],!0);if(!r.length)throw new Error("No results");return r[0]}};async function Ks(n){let e=n.sender?.preKey;if(!e||!e.signature||!e.keyBytes)throw new Error("missing pre-key or pre-key signature");let t=n.sender?.identityKey;if(!t)throw new Error("missing identity key in bundle");if(!await new E(t).verifyKey(new E(e)))throw new Error("pre key not signed by identity key")}var Qn=n=>{if(n.v1?.ciphertext)return [n.v1.headerBytes,new I(n.v1.ciphertext)];if(n.v2?.ciphertext)return [n.v2.headerBytes,new I(n.v2.ciphertext)];throw new Error("unknown message version")},Mr=class{headerBytes;ciphertext;contentType;error;id;bytes;constructor(e,t,r){[this.headerBytes,this.ciphertext]=Qn(r),this.id=e,this.bytes=t;}toBytes(){return this.bytes}},J=class extends Mr{header;senderAddress;conversation=void 0;constructor(e,t,r,i,o){super(e,t,r),this.senderAddress=o,this.header=i;}static async create(e,t,r){if(!t.sender)throw new Error("missing message sender");let i=new P(t.sender).walletSignatureAddress(),o=z(await U(r));return new J(o,r,e,t,i)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new V(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){let r=(await e.decryptV1(kr([this],t))).responses;if(!r.length)throw new Error("No response from Keystore");let{decrypted:i}=Ie(r[0]);return i}static fromBytes(e){let t=message.Message.decode(e),[r]=Qn(t),i=message.MessageHeaderV1.decode(r);if(!i)throw new Error("missing message header");if(!i.sender)throw new Error("missing message sender");if(!i.sender.identityKey)throw new Error("missing message sender identity key");if(!i.sender.preKey)throw new Error("missing message sender pre-key");if(!i.recipient)throw new Error("missing message recipient");if(!i.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!i.recipient.preKey)throw new Error("missing message recipient pre-key");return J.create(t,i,e)}static async encode(e,t,r,i,o){let a={sender:r,recipient:i,timestamp:xn.fromNumber(o.getTime())},c=message.MessageHeaderV1.encode(a).finish(),p=await e.encryptV1({requests:[{recipient:i,headerBytes:c,payload:t}]});if(!p.responses.length)throw new Error("No response from Keystore");let{encrypted:l}=Ie(p.responses[0]),v={v1:{headerBytes:c,ciphertext:l},v2:void 0},b=message.Message.encode(v).finish();return J.create(v,a,b)}},Se=class extends Mr{senderAddress;header;constructor(e,t,r,i){super(e,t,r),this.header=i;}static async create(e,t,r){let i=z(await U(r));return new Se(i,r,e,t)}get sent(){return _(this.header.createdNs)}},q=class{id;messageVersion;senderAddress;recipientAddress;sent;contentTopic;conversation;contentType;content;error;contentBytes;contentFallback;constructor({id:e,messageVersion:t,senderAddress:r,recipientAddress:i,conversation:o,contentBytes:a,contentType:c,contentTopic:p,content:l,sent:v,error:b,contentFallback:C}){this.id=e,this.messageVersion=t,this.senderAddress=r,this.recipientAddress=i,this.conversation=o,this.contentType=c,this.sent=v,this.error=b,this.content=l,this.contentTopic=p,this.contentBytes=a,this.contentFallback=C;}toBytes(){return message.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:D(this.conversation.createdAt),peerAddress:this.conversation.peerAddress},sentNs:D(this.sent)}).finish()}static async fromBytes(e,t){let r=message.DecodedMessage.decode(e),i=r.messageVersion;if(i!=="v1"&&i!=="v2")throw new Error("Invalid message version");if(!r.conversation)throw new Error("No conversation reference found");let{content:o,contentType:a,error:c,contentFallback:p}=await t.decodeContent(r.contentBytes);return new q({...r,content:o,contentType:a,error:c,messageVersion:i,sent:_(r.sentNs),conversation:As(r.conversation,t,i),contentFallback:p})}static fromV1Message(e,t,r,i,o,a,c,p){let{id:l,senderAddress:v,recipientAddress:b,sent:C}=e;if(!v)throw new Error("Sender address is required");return new q({id:l,messageVersion:"v1",senderAddress:v,recipientAddress:b,sent:C,content:t,contentBytes:i,contentType:r,contentTopic:o,conversation:a,error:c,contentFallback:p})}static fromV2Message(e,t,r,i,o,a,c,p,l){let{id:v,sent:b}=e;return new q({id:v,messageVersion:"v2",senderAddress:c,sent:b,content:t,contentBytes:o,contentType:r,contentTopic:i,conversation:a,error:p,contentFallback:l})}};function As(n,e,t){if(t==="v1")return new Q(e,n.peerAddress,_(n.createdNs));if(t==="v2")return new ae(e,n.topic,n.peerAddress,_(n.createdNs),n.context);throw new Error(`Unknown conversation version ${t}`)}function Es(n,e){return e.decodeContent(n)}var Ss=60*60-10,Ue=class{authenticator;token;maxAgeMs;constructor(e,t=Ss){this.authenticator=e,this.maxAgeMs=t*1e3;}async getToken(){return (!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken();}};var Yn={name:"@xmtp/xmtp-js",version:"11.0.0",description:"XMTP client SDK for interacting with XMTP networks.",type:"module",main:"dist/index.cjs",module:"dist/index.js",types:"dist/index.d.ts",browser:"dist/web/index.js",exports:{".":{types:"./dist/index.d.ts",browser:"./dist/web/index.js",import:"./dist/index.js",require:"./dist/index.cjs"}},scripts:{prebench:"npm run build:bench",bench:"node dist/bench/index.cjs",build:"npm run clean:dist && npm run build:node && npm run build:web","build:bench":"tsup --out-dir dist/bench --entry.0 bench/index.ts --format cjs","build:node":"tsup","build:web":"tsup --platform browser --target esnext","build:docs":"rimraf docs && mkdir -p tmp && cp README.md tmp/ && sed -i.bak '/badge.svg/d' tmp/README.md && typedoc --excludePrivate --readme tmp/README.md src/index.ts",clean:"npm run clean:dist && npm run clean:proto","clean:dist":"rimraf dist","clean:proto":"rimraf -g src/proto/*.ts",package:"npm pack",prepublishOnly:"npm run build",updateSnapVersion:`npm view @xmtp/snap --json | jq '{"version": .version, "package": .name}' > ./src/snapInfo.json`,"test:setup":"./dev/up","test:teardown":"./dev/down",test:"npm run test:node","test:node":"jest --no-cache --env='node' --testTimeout=30000","test:jsdom":"jest --no-cache --env='./jest.jsdom.env.cjs' --testTimeout=30000","test:cov":"jest --coverage --no-cache --runInBand",lint:"prettier --check . && eslint .",autolint:"prettier --write . && eslint --fix .","semantic-release":"semantic-release",typecheck:"tsc"},publishConfig:{access:"public",provenance:!0},files:["dist/index.cjs","dist/index.cjs.map","dist/index.d.ts","dist/index.js","dist/index.js.map","dist/web/index.js","dist/web/index.js.map"],keywords:["xmtp","messaging","web3","sdk","js","javascript","node","nodejs"],author:"XMTP Labs <eng@xmtp.com>",license:"MIT",homepage:"https://github.com/xmtp/xmtp-js",repository:{type:"git",url:"https:git@github.com:xmtp/xmtp-js.git"},bugs:{url:"https://github.com/xmtp/xmtp-js/issues"},release:{branches:["main",{name:"beta",prerelease:!0}]},dependencies:{"@noble/secp256k1":"^1.5.2","@xmtp/proto":"^3.28.0-beta.1","async-mutex":"^0.4.0",elliptic:"^6.5.4",ethers:"^5.5.3",long:"^5.2.0"},devDependencies:{"@commitlint/cli":"^16.1.0","@commitlint/config-conventional":"^16.0.0","@metamask/providers":"^11.1.1","@types/benchmark":"^2.1.2","@types/bl":"^5.0.2","@types/callback-to-async-iterator":"^1.1.4","@types/elliptic":"^6.4.14","@types/jest":"^28.1.3","@types/node":"^18.14.0","@typescript-eslint/eslint-plugin":"^5.38.0","@typescript-eslint/parser":"^5.38.0",benny:"^3.7.1","dd-trace":"^2.12.2",esbuild:"^0.17.16","esbuild-plugin-external-global":"^1.0.1",eslint:"^8.0.1","eslint-config-prettier":"^8.3.0","eslint-config-standard":"^17.0.0","eslint-plugin-import":"^2.26.0","eslint-plugin-jsdoc":"^37.9.1","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.0.0","eslint-plugin-promise":"^6.0.1",husky:"^7.0.4",jest:"^29.6.0","jest-environment-jsdom":"^28.1.3",prettier:"^2.4.0",rimraf:"^5.0.0","semantic-release":"^21.0.3","ts-jest":"^29.1.1","ts-node":"^10.9.1",tsup:"^6.7.0",typedoc:"^0.22.11",typescript:"^4.4.3"},engines:{node:">=18"}};var Zn=`
XX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV 
 XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV 
  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  
 XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   
XX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    

Connected to the XMTP 'dev' network. Use 'production' for production messages.
https://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments
`;var {MessageApi:Rr,SortDirection:he}=messageApi,Wr=100,Bs=16,Ms="X-Client-Version",Rs="X-App-Version",mt={local:"http://localhost:5555",dev:"https://dev.xmtp.network",production:"https://production.xmtp.network"};var We=class extends Error{code;constructor(e,t){super(e),this.code=t;}static fromObject(e){return new We(e.message,e.code)}},Ds=n=>n?!!(n.name==="AbortError"||n.message.includes("aborted")):!1,Is=n=>!!(n&&"code"in n&&n.code===Bs),ei=n=>!Is(n),Qr=n=>(!n.message||!n.message.length||typeof n.message=="string"&&(n.message=Kr(n.message)),n),Ve=class{pathPrefix;maxRetries;authCache;appVersion;version;constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="xmtp-js/"+Yn.version,e===mt.dev&&console.info(Zn);}async _query(e){try{return await ze(Rr.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,Wr)}catch(t){throw We.fromObject(t)}}_batchQuery(e){return ze(Rr.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,Wr)}async _publish(e,t=0){let r=await this.getToken(),i=this.headers();i.set("Authorization",`Bearer ${r}`);try{return await ze(Rr.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:i}],this.maxRetries,Wr,ei)}catch(o){if(ei(o)||t>=1)throw We.fromObject(o);return await this.authCache?.refresh(),this._publish(e,t+1)}}_subscribe(e,t,r){let i=new AbortController;return (async()=>{for(;;){let a=new Date().getTime();try{if(await Rr.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:i.signal,mode:"cors",headers:this.headers()}),i.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),new Date().getTime()-a<1e3&&await Cr(1e3),r?.();}catch(c){if(Ds(c)||i.signal.aborted)return;console.info("Stream connection closed. Resubscribing",c.toString()),new Date().getTime()-a<1e3&&await Cr(1e3),r?.();}}})(),{unsubscribe:async()=>{i?.abort();}}}async query(e,{direction:t=he.SORT_DIRECTION_ASCENDING,limit:r}){let i=[];for await(let o of this.queryIteratePages(e,{direction:t,pageSize:r&&r<100?r:100}))for(let a of o)if(i.push(a),r&&i.length===r)return i;return i}async*queryIterator(e,t){for await(let r of this.queryIteratePages(e,t))for(let i of r)yield i;}async*queryIteratePages({contentTopic:e,startTime:t,endTime:r},{direction:i,pageSize:o=10}){if(!e||!e.length)throw new Error("Must specify content topics");let a=ue(t),c=ue(r),p;for(;;){let l={limit:o,direction:i,cursor:p},v=await this._query({contentTopics:[e],startTimeNs:a,endTimeNs:c,pagingInfo:l});if(v.envelopes?.length)yield v.envelopes.map(Qr);else return;if(v.pagingInfo?.cursor)p=v.pagingInfo?.cursor;else return}}async batchQuery(e){let r=[];for(let a=0;a<e.length;a+=50){let c=e.slice(a,a+50),p=[];for(let v of c)p.push({contentTopics:[v.contentTopic],startTimeNs:ue(v.startTime),endTimeNs:ue(v.endTime),pagingInfo:{limit:v.pageSize||10,direction:v.direction||he.SORT_DIRECTION_ASCENDING}});let l={requests:p};r.push(l);}let i=await Promise.all(r.map(async a=>this._batchQuery(a))),o=[];for(let a of i){if(!a.responses)throw new Error("BatchQueryResponse missing responses");for(let c of a.responses)c.envelopes?o.push(c.envelopes.map(Qr)):o.push([]);}return o}async publish(e){let t=[];for(let{contentTopic:r,message:i,timestamp:o}of e){if(!r.length)throw new Error("Content topic cannot be empty string");if(!i.length)throw new Error("0 length messages not allowed");let a=o||new Date;t.push({contentTopic:r,timestampNs:ue(a),message:Uint8Array.from(i)});}return this._publish({envelopes:t})}subscribe(e,t,r){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,i=>t(Qr(i)),r)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new Ue(e,t);}headers(){let e=new Headers;return e.set(Ms,this.version),this.appVersion&&e.set(Rs,this.appVersion),e}};var Qe=class{jobType;mutex;keystore;constructor(e,t){this.jobType=e,this.mutex=new Mutex,this.keystore=t;}get protoJobType(){return Ns(this.jobType)}async run(e){return this.mutex.runExclusive(async()=>{let t=await this.getLastRunTime(),r=new Date,i=await e(t);return await this.setLastRunTime(r),i})}async getLastRunTime(){let{lastRunNs:e}=await this.keystore.getRefreshJob(keystore.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(xn.fromNumber(0)))return _(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:D(e)});}};function Ns(n){let e={v1:keystore.JobType.JOB_TYPE_REFRESH_V1,v2:keystore.JobType.JOB_TYPE_REFRESH_V2}[n];if(!e)throw new Error(`unknown job type: ${n}`);return e}var ti=1e4,ri=n=>!!(n.recipientAddress&&n.senderAddress),Ne=class{client;v1JobRunner;v2JobRunner;constructor(e){this.client=e,this.v1JobRunner=new Qe("v1",e.keystore),this.v2JobRunner=new Qe("v2",e.keystore);}async list(){let[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),r=e.concat(t);return r.sort((i,o)=>i.createdAt.getTime()-o.createdAt.getTime()),r}async listFromCache(){let[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),r=e.concat(t);return r.sort((i,o)=>i.createdAt.getTime()-o.createdAt.getTime()),r}async listV1Conversations(){return this.v1JobRunner.run(async e=>{let t=await this.getIntroductionPeers({startTime:e?new Date(+e-ti):void 0,direction:he.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map(([r,i])=>({peerAddress:r,createdNs:D(i),topic:se(r,this.client.address),context:void 0}))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))})}async listV2Conversations(){return this.v2JobRunner.run(async e=>{let t=await this.getV2ConversationsFromKeystore(),r=await this.updateV2Conversations(e),i=new Set(t.map(o=>o.topic));for(let o of r)i.has(o.topic)||(t.push(o),i.add(o.topic));return t.sort((o,a)=>o.createdAt.getTime()-a.createdAt.getTime()),t})}async getV2ConversationsFromKeystore(){return (await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return (await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){let t=await this.client.listInvitations({startTime:e?new Date(+e-ti):void 0,direction:he.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){let{responses:r}=await this.client.keystore.saveInvites({requests:e.map(o=>({payload:o.message,timestampNs:xn.fromString(o.timestampNs),contentTopic:o.contentTopic}))}),i=[];for(let o of r)try{i.push(this.saveInviteResponseToConversation(o));}catch(a){if(console.warn("Error saving invite response to conversation: ",a),t)throw a}return i}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new ae(this.client,e.topic,e.peerAddress,_(e.createdNs),e.context)}conversationReferenceToV1(e){return new Q(this.client,e.peerAddress,_(e.createdNs))}async stream(e){let t=new Set,r=de(this.client.address),i=Ke(this.client.address),o=p=>t.has(p)?!1:(t.add(p),!0),a=async p=>{if(p.contentTopic===r){if(!p.message)throw new Error("empty envelope");let l=await J.fromBytes(p.message),v=this.getPeerAddress(l);return o(v)?(await l.decrypt(this.client.keystore,this.client.publicKeyBundle),new Q(this.client,v,l.sent)):void 0}if(p.contentTopic===i){let l=await this.decodeInvites([p],!0);if(l.length)return l[0]}throw new Error("unrecognized invite topic")},c=[r,i];return F.create(this.client,c,a.bind(this),void 0,e)}async streamAllMessages(e){let t=de(this.client.address),r=Ke(this.client.address),i=new Set([t,r]),o=new Map;for(let b of await this.list())i.add(b.topic),o.set(b.topic,b);let a=async b=>{let C=b.contentTopic;if(!C||!b.message)return null;if(C===t){let R=await J.fromBytes(b.message);if(!ri(R))return null;let Pe=this.getPeerAddress(R);return new Q(this.client,Pe,R.sent).decodeMessage(b)}if(C===r)return (await this.decodeInvites([b],!0))[0];let ie=o.get(C);if(ie instanceof Q||ie instanceof ae)return ie.decodeMessage(b);throw console.log("Unknown topic"),new Error("Unknown topic")},c=(b,C)=>i.has(b)?!1:(o.set(b,C),i.add(b),!0),p=b=>{if(b instanceof q&&b.contentTopic===t){let C=new Q(this.client,b.recipientAddress===this.client.address?b.senderAddress:b.recipientAddress,b.sent);return c(C.topic,C)?Array.from(i.values()):void 0}if(b instanceof ae)return c(b.topic,b)?Array.from(i.values()):void 0},l=await F.create(this.client,Array.from(i.values()),a,p,e),v=async function*(){for await(let C of l)if(C instanceof q&&(yield C),C instanceof ae)for(let ie of await C.messages())yield ie;}();return v.return=async()=>(await l?.return(),{value:void 0,done:!0}),v}async getIntroductionPeers(e){let t=de(this.client.address),r=await this.client.listEnvelopes(t,o=>{if(!o.message)throw new Error("empty envelope");return J.fromBytes(o.message)},e),i=new Map;for(let o of r){if(!ri(o))continue;let a=this.getPeerAddress(o);if(a){let c=i.get(a);if(!c||c>o.sent)try{await o.decrypt(this.client.keystore,this.client.publicKeyBundle),i.set(a,o.sent);}catch{continue}}}return i}async newConversation(e,t){let r=await this.client.getUserContact(e);if(!r)throw new Error(`Recipient ${e} is not on the XMTP network`);if(e===this.client.address)throw new Error("self messaging not supported");if(r instanceof P&&!t?.conversationId)return new Q(this.client,e,new Date);if(!t?.conversationId){let p=(await this.listV1Conversations()).find(l=>l.peerAddress===e);if(p){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(r instanceof P)&&!r.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return p}}r instanceof P&&(r=T.fromLegacyBundle(r));let i=c=>c.peerAddress===e&&_s(t,c.context??void 0),a=(await this.getV2ConversationsFromKeystore()).find(i);return a||this.v2JobRunner.run(async c=>{let l=(await this.updateV2Conversations(c)).find(i);return l||this.createV2Convo(r,t)})}async createV2Convo(e,t){let r=new Date,{payload:i,conversation:o}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:D(r)});if(!i||!o)throw new Error("Required field not returned from Keystore");let a=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:Ke(a),message:i,timestamp:r},{contentTopic:Ke(this.client.address),message:i,timestamp:r}]),this.conversationReferenceToV2(o)}getPeerAddress(e){return e.recipientAddress===this.client.address?e.senderAddress:e.recipientAddress}};function _s(n,e){return n?.conversationId===e?.conversationId}async function ii(n,e){if(n.compression===void 0)return;let t={bytes:new Uint8Array(n.content.length)};await ai(n.content).pipeThrough(new DecompressionStream(oi(n.compression))).pipeTo(ci(t,e)),n.content=t.bytes;}async function si(n){if(n.compression===void 0)return;let e={bytes:new Uint8Array(n.content.length/10)};await ai(n.content).pipeThrough(new CompressionStream(oi(n.compression))).pipeTo(ci(e,n.content.length+1e3)),n.content=e.bytes;}function oi(n){if(n===content.Compression.COMPRESSION_GZIP)return "gzip";if(n===content.Compression.COMPRESSION_DEFLATE)return "deflate";throw new Error("unrecognized compression algorithm")}function ai(n,e=1024){let t=0;return new ReadableStream({pull(r){if(t>=n.length)return r.close();let i=t+e;i=i<=n.length?i:n.length,r.enqueue(n.subarray(t,i)),t=i;}})}function ci(n,e){let t=0;return new WritableStream({write(r){let i=t+r.length;if(i>e)throw new Error("maximum output size exceeded");for(;n.bytes.length<i;)n.bytes=qs(n.bytes,e);n.bytes.set(r,t),t=i;},close(){t<n.bytes.length&&(n.bytes=n.bytes.subarray(0,t));}})}function qs(n,e){let t=n.length*2;t>e&&(t=e);let r=new Uint8Array(t);return r.set(n),r}function Dr(n){let e;try{e=contact.ContactBundle.decode(n);}catch{let r=publicKey.PublicKeyBundle.decode(n);e={v1:{keyBundle:new P(r)},v2:void 0};}if(e.v1?.keyBundle)return new P(e.v1.keyBundle);if(e.v2?.keyBundle)return new T(e.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function pi(n){return n instanceof P?contact.ContactBundle.encode({v1:{keyBundle:n},v2:void 0}).finish():contact.ContactBundle.encode({v1:void 0,v2:{keyBundle:n}}).finish()}var li=Sn(di(),1);var ce=class{walletAddr;createdNs;constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t;}static create(e,t){return t=t||new Date,new ce({walletAddr:e,createdNs:D(t)})}static fromBytes(e){let t=authn.AuthData.decode(e);return new ce(t)}toBytes(){return authn.AuthData.encode(this).finish()}};var pe=class{identityKey;authDataBytes;authDataSignature;_authData;constructor({identityKey:e,authDataBytes:t,authDataSignature:r}){if(!e)throw new Error("Missing identity key in token");if(!r)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=r;}get authData(){return this._authData||(this._authData=ce.fromBytes(this.authDataBytes)),this._authData}get ageMs(){let e=new Date().valueOf(),r=this.authData.createdNs.div(1e6).toNumber();return e-r}toBytes(){return authn.Token.encode(this).finish()}static fromBytes(e){return new pe(authn.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}};var ge=class{identityKey;constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e;}async createToken(e){let r=ce.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),i=(0, li.keccak256)(r),o=await this.identityKey.sign($(i));return new pe(authn.Token.fromPartial({identityKey:publicKey.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:r,authDataSignature:signature.Signature.fromPartial(o)}))}};var Js=n=>n instanceof pe?n:new pe(n),Ye=class{keystore;constructor(e){this.keystore=e;}async createToken(e){let t=await this.keystore.createAuthToken({timestampNs:e?D(e):void 0});return Js(t)}};var mi=0,Ze=class{configuration;static createConfiguration(){return {type:mi,version:0}}constructor(e){this.configuration=e;}get backupType(){return mi}};var fi=1,et=class{configuration;static createConfiguration(e){return {type:fi,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e;}get backupType(){return fi}};async function hi(n,e){let t=await js(n,e);switch(t.type){case 0:return new Ze(t);case 1:return new et(t)}}async function js(n,e){let t;switch((await e()).type){case 0:t=Ze.createConfiguration();break;case 1:t=et.createConfiguration(n);break}return t}var L=class extends Error{};var ke=class{topic;context;aes256GcmHkdfSha256;constructor({topic:e,context:t,aes256GcmHkdfSha256:r}){if(!e||!e.length)throw new Error("Missing topic");if(!r||!r.keyMaterial||!r.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=r;}static createRandom(e){let t=pt(Buffer.from(M.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace("/","-")),r=M.getRandomValues(new Uint8Array(32));return new ke({topic:t,aes256GcmHkdfSha256:{keyMaterial:r},context:e})}toBytes(){return invitation.InvitationV1.encode(this).finish()}static fromBytes(e){return new ke(invitation.InvitationV1.decode(e))}},tt=class{sender;recipient;createdNs;constructor({sender:e,recipient:t,createdNs:r}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new T(e),this.recipient=new T(t),this.createdNs=r;}toBytes(){return invitation.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new tt(invitation.SealedInvitationHeaderV1.decode(e))}},ft=class{headerBytes;ciphertext;_header;_invitation;constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new I(t);}get header(){return this._header?this._header:(this._header=tt.fromBytes(this.headerBytes),this._header)}async getInvitation(e){if(this._invitation)return this._invitation;let t=this.header,r;e.identityKey.matches(this.header.sender.identityKey)?r=await e.sharedSecret(t.recipient,t.sender.preKey,!1):r=await e.sharedSecret(t.sender,t.recipient.preKey,!0);let i=await X(this.ciphertext,r,this.headerBytes);return this._invitation=ke.fromBytes(i),this._invitation}toBytes(){return invitation.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new ft(invitation.SealedInvitationV1.decode(e))}},le=class{v1;constructor({v1:e}){if(e)this.v1=new ft(e);else throw new Error("Missing v1 or v2 invitation")}toBytes(){return invitation.SealedInvitation.encode(this).finish()}static fromBytes(e){return new le(invitation.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");let t=le.fromBytes(e.message),r=xn.fromString(e.timestampNs),i=t.v1?.header.createdNs;if(!i||!i.equals(r))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:r,invitation:i}){let o=new tt({sender:e.getPublicKeyBundle(),recipient:t,createdNs:D(r)}).toBytes(),a=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),c=i.toBytes(),p=await ee(c,a,o);return new le({v1:{headerBytes:o,ciphertext:p}})}};var gi=async(n,e,t,r,i)=>{let o=await n.sharedSecret(e,n.getCurrentPreKey().publicKey,!i);return X(t,o,r)},vi=async(n,e,t,r)=>{let i=await n.sharedSecret(e,n.getCurrentPreKey().publicKey,!1);return ee(t,i,r)},wi=(n,e,t)=>X(n,e,t),bi=(n,e,t)=>ee(n,e,t);var rn=(n,e)=>n instanceof K?n:new K(e,n.message),zs=n=>({result:n}),rt=(n,e,t)=>Promise.all(n.map(async r=>{try{return zs(await e(r))}catch(i){return {error:rn(i,t)}}})),nn=n=>n instanceof P?n:new P(n),Pi=n=>n instanceof T?n:new T(n),Oe=(n,e,t)=>{for(let r of e)if(!n[r])throw new K(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(r)}`);for(let r of t){let i=n[r];if(!i||!i?.length)throw new K(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(r)}`)}return !0},sn=n=>{if(!n?.aes256GcmHkdfSha256?.keyMaterial)throw new K(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return n.aes256GcmHkdfSha256.keyMaterial},Ur=({invitation:n,createdNs:e,peerAddress:t})=>({context:n.context,topic:n.topic,peerAddress:t,createdNs:e}),Ci=n=>!!n.invitation,Ki=n=>{let e=new Map;for(let[t,r]of Object.entries(n.topics))e.set(t,r);return e},Ti=(n,e)=>`xmtp/${n}/${e}/`;var Ws="invitations/v1",Qs="conversation-v1/v1",Be=class{persistence;persistenceKey;mutex;topicMap;revision;constructor(e,t,r=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new Mutex,this.topicMap=r;}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){let t=Ws,r=new Be(e,t);return await r.refresh(),r}validate(e){return !!e.topic&&e.topic.length>0&&Ci(e)}async refresh(){let e=await this.getRevision();if(e>this.revision)for(let[t,r]of await this.loadFromPersistence())this.topicMap.set(t,r);this.revision=e;}async getRevision(){let e=await this.persistence.getItem(this.revisionKey);return e?Mn(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,Bn(e));}async loadFromPersistence(){let e=await this.persistence.getItem(this.persistenceKey);return e?Ki(keystore.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision);}async add(e){await this.mutex.runExclusive(async()=>{await this.refresh();let t=!1;for(let r of e){if(!this.validate(r)){console.warn("Invalid topic data",r.topic);continue}let{topic:i,...o}=r;this.topicMap.has(i)||(this.topicMap.set(i,o),t=!0);}t&&await this.store();});}get topics(){return [...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return keystore.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}},_e=class extends Be{static async create(e){let t=Qs,r=new _e(e,t);return await r.refresh(),r}validate(e){return !!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}};var Zs=Ys.ec,an=new Zs("secp256k1"),ht=M.subtle,eo=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),to=Buffer.alloc(32,0);function me(n,e){if(!n)throw new Error(e||"Assertion failed")}function ro(n){return Buffer.isBuffer(n)&&n.length===32}function cn(n){return ro(n)?n.compare(to)>0&&n.compare(eo)<0:!1}function no(n,e){if(n.length!==e.length)return !1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}function on(n){let e=new Uint8Array(n);return M.getRandomValues(e),Buffer.from(e)}async function Ei(n){let e=await ht.digest("SHA-512",n);return Buffer.from(e)}function Si(n){return function(e,t,r){return new Promise(function(i){let o={name:"AES-CBC"};return ht.importKey("raw",t,o,!1,[n]).then(function(c){let p={name:"AES-CBC",iv:e};return ht[n](p,c,r)}).then(function(c){i(Buffer.from(new Uint8Array(c)));})})}}var io=Si("encrypt"),so=Si("decrypt");async function Vr(n,e){let t=await ht.importKey("raw",n,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await ht.sign({name:"HMAC",hash:"SHA-256"},t,e))}async function oo(n,e,t){let r=await Vr(n,e);return no(r,t)}function pn(n){return me(n.length===32,"Bad private key"),me(cn(n),"Bad private key"),Buffer.from(an.keyFromPrivate(n).getPublic("array"))}function xi(n,e){return new Promise(function(t){me(Buffer.isBuffer(n),"Bad private key"),me(Buffer.isBuffer(e),"Bad public key"),me(n.length===32,"Bad private key"),me(cn(n),"Bad private key"),me(e.length===65||e.length===33,"Bad public key"),e.length===65&&me(e[0]===4,"Bad public key"),e.length===33&&me(e[0]===2||e[0]===3,"Bad public key");let r=an.keyFromPrivate(n),i=an.keyFromPublic(e),o=r.derive(i.getPublic());t(Buffer.from(o.toArray()));})}async function ki(n,e,t){t=t||{};let r=t?.iv||on(16),i=t?.ephemPrivateKey||on(32);for(;!cn(i);){if(t?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");i=on(32);}let o=pn(i),a=await Ei(await xi(i,n)),c=a.slice(0,32),p=a.slice(32),l=await io(r,c,e),v=Buffer.concat([r,o,l]),b=await Vr(p,v);return {iv:r,ephemeralPublicKey:o,ciphertext:l,mac:b}}async function Bi(n,e){let t=await xi(n,e.ephemeralPublicKey),r=await Ei(t),i=r.slice(0,32),o=r.slice(32),a=Buffer.concat([e.iv,e.ephemeralPublicKey,e.ciphertext]);return me(await oo(o,a,e.mac),"Bad mac"),so(e.iv,i,e.ciphertext)}var{ErrorCode:j}=keystore,ao=new TextEncoder().encode("__XMTP__INVITATION__SALT__XMTP__");async function co(n,e){let t=await M.subtle.importKey("raw",n,"HKDF",!1,["deriveKey"]);return M.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:ao,info:e},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}var Z=class{v1Keys;v2Keys;v1Store;v2Store;authenticator;accountAddress;jobStatePersistence;constructor(e,t,r,i){this.v1Keys=e,this.v2Keys=G.fromLegacyBundle(e),this.v1Store=t,this.v2Store=r,this.authenticator=new ge(e.identityKey),this.jobStatePersistence=i;}static async create(e,t){return new Z(e,await _e.create(t),await Be.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){let t=await rt(e.requests,async r=>{if(!Oe(r,["payload","peerKeys"],["headerBytes"]));let{payload:i,peerKeys:o,headerBytes:a,isSender:c}=r;return {decrypted:await gi(this.v1Keys,nn(o),i,a,c)}},keystore.ErrorCode.ERROR_CODE_UNSPECIFIED);return keystore.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){let t=await rt(e.requests,async r=>{if(!Oe(r,["payload"],["headerBytes"]));let{payload:i,headerBytes:o,contentTopic:a}=r,c=this.v2Store.lookup(a);if(!c)throw new K(keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");return {decrypted:await wi(i,sn(c.invitation),o)}},j.ERROR_CODE_UNSPECIFIED);return keystore.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){let t=await rt(e.requests,async r=>{if(!Oe(r,["payload","recipient"],["headerBytes"]));let{recipient:i,payload:o,headerBytes:a}=r;return {encrypted:await vi(this.v1Keys,nn(i),o,a)}},j.ERROR_CODE_UNSPECIFIED);return keystore.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?_(e):void 0)}async encryptV2(e){let t=await rt(e.requests,async r=>{if(!Oe(r,["payload"],["headerBytes"]));let{payload:i,headerBytes:o,contentTopic:a}=r,c=this.v2Store.lookup(a);if(!c)throw new K(j.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");return {encrypted:await bi(i,sn(c.invitation),o)}},j.ERROR_CODE_INVALID_INPUT);return keystore.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){let t=[],r=await rt(e.requests,async({payload:i,timestampNs:o})=>{let a=le.fromBytes(i);if(a.v1){if(!a.v1.header.createdNs.equals(o))throw new Error("envelope and header timestamp mismatch");let p=a.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),l=await a.v1.getInvitation(this.v2Keys),v={invitation:l,createdNs:a.v1.header.createdNs,peerAddress:p?await a.v1.header.recipient.walletSignatureAddress():await a.v1.header.sender.walletSignatureAddress()};return t.push({...v,topic:l.topic}),{conversation:Ur(v)}}},j.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),keystore.SaveInvitesResponse.fromPartial({responses:r})}async createInvite(e){try{if(!Oe(e,["recipient"],[]));let t=_(e.createdNs),r=Pi(e.recipient),i=await this.getAccountAddress(),o=await r.walletSignatureAddress(),a=await this.v2Keys.sharedSecret(r,this.v2Keys.getCurrentPreKey().publicKey,i<o),c=[i,o].sort(),p=(e.context?.conversationId||"")+c.join(),l=new TextEncoder().encode(p),v=z(await Vr(Buffer.from(a),Buffer.from(l))),b=["0",...c].join("|"),C=new TextEncoder().encode(b),ie=await co(a,C),R=new Uint8Array(await M.subtle.exportKey("raw",ie)),Pe=new ke({topic:pt(v),aes256GcmHkdfSha256:{keyMaterial:R},context:e.context}),it=await le.createV1({sender:this.v2Keys,recipient:r,created:t,invitation:Pe}),je={invitation:Pe,topic:Pe.topic,createdNs:e.createdNs,peerAddress:await r.walletSignatureAddress()};return await this.v2Store.add([je]),keystore.CreateInviteResponse.fromPartial({conversation:Ur(je),payload:it.toBytes()})}catch(t){throw rn(t,j.ERROR_CODE_INVALID_INPUT)}}async signDigest(e){if(!Oe(e,["digest"],[]));let{digest:t,identityKey:r,prekeyIndex:i}=e,o;if(r)o=this.v1Keys.identityKey;else if(typeof i<"u"&&Number.isInteger(i)){if(o=this.v1Keys.preKeys[i],!o)throw new K(j.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}else throw new K(j.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");return o.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map(t=>({topic:se(t.peerAddress,this.walletAddress),peerAddress:t.peerAddress,createdNs:t.createdNs,invitation:void 0}))),{}}async getV1Conversations(){return {conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){let e=this.v2Store.topics.map(t=>Ur(t));return e.sort((t,r)=>t.createdNs.div(1e6).sub(r.createdNs.div(1e6)).toNumber()),keystore.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===keystore.JobType.JOB_TYPE_UNSPECIFIED)throw new K(j.ERROR_CODE_INVALID_INPUT,"invalid job type");let t=await this.getLastRunTime(e);return keystore.GetRefreshJobResponse.fromPartial({lastRunNs:t||xn.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){let r=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(r,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return {peerAddress:e.peerAddress,createdNs:e.createdNs,topic:se(e.peerAddress,this.walletAddress),context:void 0}}buildJobStorageKey(e){return `refreshJob/${e.toString()}`}async getLastRunTime(e){let t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(!(!t||!t.length))return xn.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}};var qe=class{apiClient;constructor(e){this.apiClient=e;}async getItem(e){for await(let t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:messageApi.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(r){console.log(r);}return null}async setItem(e,t){let r=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:r}]);}setAuthenticator(e){this.apiClient.setAuthenticator(e);}buildTopic(e){return Fr(e)}};var ne=class{storage;constructor(e){this.storage=e;}static create(){if(typeof localStorage>"u")throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new ne(localStorage)}async getItem(e){let t=this.storage.getItem(e);return t===null?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"));}};var gt=class{store;constructor(){this.store=new Map;}get length(){return this.store.size}clear(){this.store=new Map;}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(e===void 0)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");let t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e);}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t));}validateString(e){if(typeof e!="string")throw new TypeError("Key must be a string")}};var ve=class extends ne{static create(){return new ne(new gt)}};var Le=class{prefix;persistence;constructor(e,t){this.prefix=e,this.persistence=t;}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}};var Fe=class{persistence;privateKey;privateKeyBytes;publicKey;constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=pn(this.privateKeyBytes);}async getItem(e){let t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){let r=await this.encrypt(t);await this.persistence.setItem(e,r);}async encrypt(e){let t=await ki(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){let t=await this.deserializeEcies(e),r=await Bi(this.privateKeyBytes,t);return Uint8Array.from(r)}async serializeEcies(e){return (await ye.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){let t=ye.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");let r=t.ciphertext;return {ciphertext:Buffer.from(r.ciphertext),mac:Buffer.from(r.mac),iv:Buffer.from(r.iv),ephemeralPublicKey:Buffer.from(r.ephemeralPublicKey)}}};var nt=async(n,e)=>{if(!n.persistConversations)return ve.create();let t=await e.identityKey.publicKey.walletSignatureAddress(),r=Ti(n.env,t),i=n.basePersistence,o=!n.disablePersistenceEncryption;return new Le(r,o?new Fe(i,e.identityKey):i)};var Ri="key_bundle",He=class{persistence;signer;preEnableIdentityCallback;constructor(e,t,r){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=r;}async getStorageAddress(e){let t=await this.signer.getAddress();return t=utils.getAddress(t),`${t}/${e}`}async loadPrivateKeyBundle(){let e=await this.persistence.getItem(await this.getStorageAddress(Ri));if(!e)return null;let[t,r]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return r&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){let t=await this.getStorageAddress(Ri),r=await this.toEncryptedBytes(e,this.signer);typeof this.persistence.setAuthenticator=="function"&&this.persistence.setAuthenticator(new ge(e.identityKey)),await this.persistence.setItem(t,r);}async toEncryptedBytes(e,t){let r=e.encode(),i=M.getRandomValues(new Uint8Array(32)),o=Ii(i),a=await t.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();let c=await t.signMessage(o),p=utils.verifyMessage(o,c);if(p!==a&&(c=await t.signMessage(o),console.log("invalid signature, retrying"),p=utils.verifyMessage(o,c),p!==a))throw new Error("invalid signature");let l=$(c),v=await ee(r,l);return privateKey.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:i,ciphertext:v}}).finish()}async fromEncryptedBytes(e,t){let[r,i]=uo(t);if(!r.walletPreKey)throw new Error("missing wallet pre-key");if(!r.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();let o=$(await e.signMessage(Ii(r.walletPreKey)));try{let a=new I(r.ciphertext),c=await X(a,o),[p,l]=Di(c);return [p,i||l]}catch{if(o.length!==65)throw new Error("Expected 65 bytes before trying a different recovery byte");let c=o[o.length-1],p=o.slice(0,o.length-1);c<27?p=new Uint8Array([...p,c+27]):p=new Uint8Array([...p,c-27]);let l=new I(r.ciphertext),v=await X(l,p),[b,C]=Di(v);return [b,i||C]}}};function uo(n){try{let e=privateKey.EncryptedPrivateKeyBundle.decode(n);if(e.v1)return [e.v1,!1]}catch{return [privateKey.EncryptedPrivateKeyBundleV1.decode(n),!0]}throw new Error("unrecognized encrypted private key bundle version")}function Di(n){try{let e=De(n);if(e instanceof G)throw new Error("V2 bundles not supported yet");return [e,!1]}catch{let t=privateKey.PrivateKeyBundleV1.decode(n);return [new N(t),!0]}}function Ii(n){return `XMTP : Enable Identity
${z(n)}

For more info: https://xmtp.org/signatures/`}var we=class{async newKeystore(e,t,r){if(!r)throw new L("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();let i=await N.generate(r);return await new He(r,new qe(t),e.preEnableIdentityCallback).storePrivateKeyBundle(i),Z.create(i,await nt(e,i))}};var be=class{async newKeystore(e,t,r){if(!r)throw new L("No wallet provided");let o=await new He(r,new qe(t),e.preEnableIdentityCallback).loadPrivateKeyBundle();if(!o)throw new L("No keys found");return Z.create(o,await nt(e,o))}};var Ge=class{async newKeystore(e){let{privateKeyOverride:t}=e;if(!t)throw new L("No private key override provided");let r=De(t);if(r instanceof G)throw new Error("V2 private key bundle found. Only V1 supported");return Z.create(r,await nt(e,r))}};function vt(){return window.ethereum}var{GetKeystoreStatusResponse_KeystoreStatus:Ui,InitKeystoreRequest:lo,InitKeystoreResponse:mo,GetKeystoreStatusRequest:fo,GetKeystoreStatusResponse:ho}=keystore;async function Or(n,e,t,r,i){let o=null;if(e.req){let c=e.req.encode(t).finish();o=kn(c,0,c.length);}let a=await go(n,o,r,i);if(Array.isArray(a))throw new Error("Unexpected array response");return e.res.decode(Kr(a))}async function go(n,e,t,r){let i={meta:t};typeof e=="string"&&(i.req=e);let o=await vt().request({method:"wallet_invokeSnap",params:{snapId:r,request:{method:n,params:i}}});if(!o||typeof o!="object")throw new Error("No response value");return o.res}async function _r(){let n=vt();if(n?.isMetaMask)try{return await n.request({method:"wallet_getSnaps"}),!0}catch{}if(typeof n?.detected<"u"&&Array.isArray(n.detected))for(let e of n.detected)try{return await e.request({method:"wallet_getSnaps"}),n?.setProvider?.(e),!0}catch{}if(typeof n?.providers<"u"&&Array.isArray(n.providers))for(let e of n.providers)try{return await e.request({method:"wallet_getSnaps"}),window.ethereum=e,!0}catch{}return !1}async function vo(){return await vt()?.request({method:"wallet_getSnaps"})}async function Vi(n,e){try{let t=await vo();return Object.values(t).find(r=>r.id===n&&(!e||Dn(r.version,e)))}catch(t){console.warn("Failed to obtain installed snap",t);return}}async function Ni(n,e={}){await vt()?.request({method:"wallet_requestSnaps",params:{[n]:e}});}var wo={req:fo,res:ho};async function Oi(n,e){let t=await Or("getKeystoreStatus",wo,{walletAddress:n.walletAddress},n,e);if([Ui.KEYSTORE_STATUS_UNSPECIFIED,Ui.UNRECOGNIZED].includes(t.status))throw new Error("No status specified in response");return t.status}var bo={req:lo,res:mo};async function _i(n,e,t){let r=n.identityKey.publicKey.walletSignatureAddress(),i=await Or("initKeystore",bo,{v1:n},{walletAddress:r,env:e},t);if(i.error)throw new K(i.error.code,i.error.message)}var wt={decryptV1:{req:keystore.DecryptV1Request,res:keystore.DecryptResponse},encryptV1:{req:keystore.EncryptV1Request,res:keystore.EncryptResponse},encryptV2:{req:keystore.EncryptV2Request,res:keystore.EncryptResponse},decryptV2:{req:keystore.DecryptV2Request,res:keystore.DecryptResponse},saveInvites:{req:keystore.SaveInvitesRequest,res:keystore.SaveInvitesResponse},createInvite:{req:keystore.CreateInviteRequest,res:keystore.CreateInviteResponse},createAuthToken:{req:keystore.CreateAuthTokenRequest,res:authn.Token},signDigest:{req:keystore.SignDigestRequest,res:signature.Signature},getPublicKeyBundle:{req:null,res:publicKey.PublicKeyBundle},saveV1Conversations:{req:keystore.SaveV1ConversationsRequest,res:keystore.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:keystore.GetConversationsResponse},getV2Conversations:{req:null,res:keystore.GetConversationsResponse},getRefreshJob:{req:keystore.GetRefreshJobRequest,res:keystore.GetRefreshJobResponse},setRefreshJob:{req:keystore.SetRefeshJobRequest,res:keystore.SetRefreshJobResponse}};async function qi(n,e,t,r){return Or(n,wt[n],e,t,r)}function un(n,e,t){let r={},i={walletAddress:n,env:e};for(let[o,a]of Object.entries(wt))r[o]=async c=>a.req?qi(o,c,i,t):qi(o,null,i,t);return {...r,async getAccountAddress(){return n}}}var {GetKeystoreStatusResponse_KeystoreStatus:Ao}=keystore,Eo="local:http://localhost:8080",Je=class{snapId;snapVersion;constructor(e=Eo,t){this.snapId=e,this.snapVersion=t;}async newKeystore(e,t,r){if(!r)throw new L("No wallet provided");if(!await _r())throw new L("MetaMask with Snaps not detected");let i=await r.getAddress(),o=e.env,a=await Vi(this.snapId,this.snapVersion);if((!a||In(this.snapVersion,a.version))&&await Ni(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await Bo(i,o,this.snapId)){let c=await xo(e,t,r);await _i(c,o,this.snapId);}return un(i,o,this.snapId)}};async function So(n,e,t){let i=await new we().newKeystore(n,e,t);return new N(await i.getPrivateKeyBundle())}async function xo(n,e,t){if(n.privateKeyOverride){let r=De(n.privateKeyOverride);if(!(r instanceof N))throw new Error("Unsupported private key bundle version");return r}if(!t)throw new Error("No privateKeyOverride or wallet");return ko(n,e,t)}async function ko(n,e,t){let r=new be;try{let i=await r.newKeystore(n,e,t);return new N(await i.getPrivateKeyBundle())}catch(i){if(i instanceof L)return So(n,e,t);throw i}}async function Bo(n,e,t){return await Oi({walletAddress:n,env:e},t)===Ao.KEYSTORE_STATUS_INITIALIZED}var Fi="1.2.2",Hi="@xmtp/snap";var {Compression:Ro}=content,Ji=100*1024*1024;function Do(n){let e={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new lt],maxContentSize:Ji,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:Rn()?ne.create():ve.create(),disablePersistenceEncryption:!1,keystoreProviders:ji(),apiClientFactory:Io};return n?.codecs&&(n.codecs=e.codecs.concat(n.codecs)),n?.useSnaps&&(n.keystoreProviders=[new Je(`npm:${Hi}`,Fi),...e.keystoreProviders]),{...e,...n}}var Me=class{address;keystore;apiClient;contacts;publicKeyBundle;knownPublicKeyBundles;_backupClient;_conversations;_codecs;_maxContentSize;constructor(e,t,r,i){this.contacts=new Set,this.knownPublicKeyBundles=new Map,this.keystore=i,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new Ne(this),this._codecs=new Map,this._maxContentSize=Ji,this.apiClient=t,this._backupClient=r;}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return T.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){let r=Do(t),i=r.apiClientFactory(r),o=await Uo(r,i,e),a=new P(await o.getPublicKeyBundle()),c=a.walletSignatureAddress();i.setAuthenticator(new Ye(o));let p=await Me.setupBackupClient(c,r.env),l=new Me(a,i,p,o);return await l.init(r),l}static async getKeys(e,t){let i=await(await Me.create(e,t)).keystore.getPrivateKeyBundle();return new N(i).encode()}static isSnapsReady(){return _r()}static async setupBackupClient(e,t){return hi(e,async()=>Promise.resolve({type:t==="local"?1:0}))}async init(e){e.codecs.forEach(t=>{this.registerCodec(t);}),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact);}async close(){}async ensureUserContactPublished(e=!1){let t=await yn(this.apiClient,this.address);t&&t instanceof T&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e));}async publishUserContact(e=!1){let t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:dt(this.address),message:pi(t)}]);}async getUserContact(e){e=utils.getAddress(e);let t=this.knownPublicKeyBundles.get(e);if(t)return t;let r=await yn(this.apiClient,e);return r&&this.knownPublicKeyBundles.set(e,r),r}async getUserContacts(e){let t=e.map(a=>utils.getAddress(a)),r=new Map,i=[];for(let a of t){let c=this.knownPublicKeyBundles.get(a);c?r.set(a,c):(r.set(a,void 0),i.push(a));}let o=await Gi(this.apiClient,i);for(let a=0;a<o.length;a++){let c=i[a],p=o[a];r.set(c,p),p&&this.knownPublicKeyBundles.set(c,p);}return t.map(a=>r.get(a))}forgetContact(e){e=utils.getAddress(e),this.knownPublicKeyBundles.delete(e);}async canMessage(e){try{return Array.isArray(e)?(await this.getUserContacts(e)).map(i=>!!i):await this.getUserContact(e)!==void 0}catch{return !1}}static async canMessage(e,t){let r=t?.apiUrl||mt[t?.env||"dev"],i=new Ve(r,{appVersion:t?.appVersion});if(Array.isArray(e)){let c=e.map(l=>utils.getAddress(l));return (await Gi(i,c)).map(l=>!!l)}try{e=utils.getAddress(e);}catch{return !1}return await yn(i,e)!==void 0}validateEnvelope(e){let t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(let t of e)this.validateEnvelope(t);await this.apiClient.publish(e);}registerCodec(e){let t=e.contentType,r=`${t.authorityId}/${t.typeId}`;return this._codecs.set(r,e),this}codecFor(e){let t=`${e.authorityId}/${e.typeId}`,r=this._codecs.get(t);if(r&&!(e.versionMajor>r.contentType.versionMajor))return r}async encodeContent(e,t){let r=t?.contentType||Ee,i=this.codecFor(r);if(!i)throw new Error("unknown content type "+r);let o=i.encode(e,this),a=i.fallback(e);return a&&(o.fallback=a),typeof t?.compression=="number"&&(o.compression=t.compression),await si(o),content.EncodedContent.encode(o).finish()}async decodeContent(e){let t=content.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let r,i=new W(t.type),o;await ii(t,1e3);let a=this.codecFor(i);return a?r=a.decode(t,this):o=new Error("unknown content type "+i),{content:r,contentType:i,error:o,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(Ke(this.address),async t=>t,e)}async listEnvelopes(e,t,r){r||(r={});let{startTime:i,endTime:o,limit:a}=r,c=await this.apiClient.query({contentTopic:e,startTime:i,endTime:o},{direction:r.direction||messageApi.SortDirection.SORT_DIRECTION_ASCENDING,limit:a}),p=[];for(let l of c)if(l.message)try{let v=await t(l);p.push(v);}catch(v){console.warn("Error in listEnvelopes mapper",v);}return p}listEnvelopesPaginated(e,t,r){return Hr(this.apiClient.queryIteratePages({contentTopic:e,startTime:r?.startTime,endTime:r?.endTime},{direction:r?.direction,pageSize:r?.pageSize||100}),t)}};function Io(n){let e=n.apiUrl||mt[n.env];return new Ve(e,{appVersion:n.appVersion})}async function yn(n,e){let t=n.queryIterator({contentTopic:dt(e)},{pageSize:5,direction:he.SORT_DIRECTION_DESCENDING});for await(let r of t){if(!r.message)continue;let i=Dr(r.message),o;try{o=await i?.walletSignatureAddress();}catch{o=void 0;}if(o===e)return i}}async function Gi(n,e){let t=e.map(dt),r=await n.batchQuery(t.map(i=>({contentTopic:i,pageSize:5,direction:he.SORT_DIRECTION_DESCENDING})));return Promise.all(e.map(async(i,o)=>{let a=r[o];if(a){for(let c of a)if(c.message)try{let p=Dr(c.message),l=await p?.walletSignatureAddress();if(i===l)return p;console.info("Received contact bundle with incorrect address");}catch(p){console.info("Invalid contact bundle",p);}}}))}function ji(){return [new Ge,new be,new we]}async function Uo(n,e,t){for(let r of n.keystoreProviders)try{return await r.newKeystore(n,e,t??void 0)}catch(i){if(i instanceof L)continue;throw i}throw new Error("No keystore providers available")}var mn=new W({authorityId:"xmtp.org",typeId:"composite",versionMajor:1,versionMinor:0}),fn=class{get contentType(){return mn}encode(e,t){let r=this.toProto(e,t),i;r.composite?i=r.composite:i={parts:[r]};let o=composite.Composite.encode(i).finish();return {type:mn,parameters:{},content:o}}decode(e,t){return this.fromProto({composite:composite.Composite.decode(e.content),part:void 0},t)}toProto(e,t){if("type"in e){let i=t.codecFor(e.type);if(!i)throw new Error(`missing codec for part type ${e.type}`);return {part:i.encode(e.content,t),composite:void 0}}let r=new Array;for(let i of e.parts)r.push(this.toProto(i,t));return {composite:{parts:r},part:void 0}}fromProto(e,t){if(e.part){if(!e.part.type)throw new Error("missing part content type");let i=new W(e.part.type),o=t.codecFor(i);if(!o)throw new Error(`missing codec for part type ${i}`);return {type:i,content:o.decode(e.part,t)}}if(!e.composite)throw new Error("invalid composite");let r=new Array;for(let i of e.composite.parts)r.push(this.fromProto(i,t));return {parts:r}}fallback(e){}};/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)
*/

export { mt as ApiUrls, Ue as AuthCache, ne as BrowserStoragePersistence, I as Ciphertext, Me as Client, fn as CompositeCodec, Ro as Compression, mn as ContentTypeComposite, Ps as ContentTypeFallback, W as ContentTypeId, Ee as ContentTypeText, Q as ConversationV1, ae as ConversationV2, Ne as Conversations, q as DecodedMessage, Fe as EncryptedPersistence, Ve as HttpApiClient, Z as InMemoryKeystore, ve as InMemoryPersistence, we as KeyGeneratorKeystoreProvider, ge as LocalAuthenticator, J as MessageV1, Se as MessageV2, be as NetworkKeystoreProvider, Le as PrefixedPersistence, te as PrivateKey, N as PrivateKeyBundleV1, G as PrivateKeyBundleV2, V as PublicKey, P as PublicKeyBundle, le as SealedInvitation, S as Signature, E as SignedPublicKey, T as SignedPublicKeyBundle, Je as SnapProvider, he as SortDirection, Ge as StaticKeystoreProvider, F as Stream, lt as TextCodec, Re as buildContentTopic, se as buildDirectMessageTopic, pt as buildDirectMessageTopicV2, dt as buildUserContactTopic, de as buildUserIntroTopic, Ke as buildUserInviteTopic, Fr as buildUserPrivateStoreTopic, D as dateToNs, Dr as decodeContactBundle, Es as decodeContent, X as decrypt, ji as defaultKeystoreProviders, ee as encrypt, is as fromNanoString, wt as keystoreApiDefs, Hr as mapPaginatedStream, _ as nsToDate, ze as retry, ue as toNanoString };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map