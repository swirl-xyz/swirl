import { signature, publicKey, ciphertext, privateKey, authn, keystore, invitation, messageApi, content, message } from '@xmtp/proto';
import { NotifyStreamEntityArrival } from '@xmtp/proto/ts/dist/types/fetch.pb';
import Long from 'long';
import { Envelope } from '@xmtp/proto/ts/dist/types/message_api/v1/message_api.pb';
import { Reader, Writer } from 'protobufjs/minimal';

interface Signer {
    getAddress(): Promise<string>;
    signMessage(message: ArrayLike<number> | string): Promise<string>;
}

declare type ECDSACompactWithRecovery = {
    bytes: Uint8Array;
    recovery: number;
};
declare class Signature implements signature.Signature {
    ecdsaCompact: ECDSACompactWithRecovery | undefined;
    walletEcdsaCompact: ECDSACompactWithRecovery | undefined;
    constructor(obj: Partial<signature.Signature>);
    signerKey(key: SignedPublicKey): Promise<UnsignedPublicKey | undefined>;
    getPublicKey(digest: Uint8Array): PublicKey | undefined;
    equals(other: Signature): boolean;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): Signature;
}
interface KeySigner {
    signKey(key: UnsignedPublicKey): Promise<SignedPublicKey>;
}

declare type secp256k1Uncompressed = {
    bytes: Uint8Array;
};
declare class UnsignedPublicKey implements publicKey.UnsignedPublicKey {
    createdNs: Long;
    secp256k1Uncompressed: secp256k1Uncompressed;
    constructor(obj: publicKey.UnsignedPublicKey);
    generated(): Date | undefined;
    isFromLegacyKey(): boolean;
    get timestamp(): Long;
    verify(signature: Signature, digest: Uint8Array): boolean;
    verifyKey(pub: PublicKey | SignedPublicKey): Promise<boolean>;
    equals(other: this): boolean;
    getEthereumAddress(): string;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): UnsignedPublicKey;
}
declare class SignedPublicKey extends UnsignedPublicKey implements publicKey.SignedPublicKey {
    keyBytes: Uint8Array;
    signature: Signature;
    constructor(obj: publicKey.SignedPublicKey);
    get unsignedKey(): UnsignedPublicKey;
    signerKey(): Promise<UnsignedPublicKey | undefined>;
    walletSignatureAddress(): Promise<string>;
    equals(other: this): boolean;
    bytesToSign(): Uint8Array;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SignedPublicKey;
    toLegacyKey(): PublicKey;
    static fromLegacyKey(legacyKey: PublicKey, signedByWallet?: boolean): SignedPublicKey;
}
declare class PublicKey extends UnsignedPublicKey implements publicKey.PublicKey {
    signature?: Signature;
    constructor(obj: publicKey.PublicKey);
    get timestamp(): Long;
    bytesToSign(): Uint8Array;
    signWithWallet(wallet: Signer): Promise<void>;
    walletSignatureAddress(): string;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): PublicKey;
}

declare class SignedPublicKeyBundle implements publicKey.SignedPublicKeyBundle {
    identityKey: SignedPublicKey;
    preKey: SignedPublicKey;
    constructor(bundle: publicKey.SignedPublicKeyBundle);
    walletSignatureAddress(): Promise<string>;
    equals(other: this): boolean;
    toBytes(): Uint8Array;
    isFromLegacyBundle(): boolean;
    toLegacyBundle(): PublicKeyBundle;
    static fromBytes(bytes: Uint8Array): SignedPublicKeyBundle;
    static fromLegacyBundle(bundle: PublicKeyBundle): SignedPublicKeyBundle;
}
declare class PublicKeyBundle implements publicKey.PublicKeyBundle {
    identityKey: PublicKey;
    preKey: PublicKey;
    constructor(bundle: publicKey.PublicKeyBundle);
    equals(other: this): boolean;
    walletSignatureAddress(): string;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): PublicKeyBundle;
}

declare class Ciphertext implements ciphertext.Ciphertext {
    aes256GcmHkdfSha256: ciphertext.Ciphertext_Aes256gcmHkdfsha256 | undefined;
    constructor(obj: ciphertext.Ciphertext);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): Ciphertext;
}

declare type secp256k1 = {
    bytes: Uint8Array;
};
declare class SignedPrivateKey implements privateKey.SignedPrivateKey, KeySigner {
    createdNs: Long;
    secp256k1: secp256k1;
    publicKey: SignedPublicKey;
    constructor(obj: privateKey.SignedPrivateKey);
    static generate(signer: KeySigner): Promise<SignedPrivateKey>;
    generated(): Date | undefined;
    sign(digest: Uint8Array): Promise<Signature>;
    signKey(pub: UnsignedPublicKey): Promise<SignedPublicKey>;
    static signerKey(key: SignedPublicKey, signature: ECDSACompactWithRecovery): Promise<UnsignedPublicKey | undefined>;
    sharedSecret(peer: SignedPublicKey | UnsignedPublicKey): Uint8Array;
    encrypt(plain: Uint8Array, peer: UnsignedPublicKey, additionalData?: Uint8Array): Promise<Ciphertext>;
    decrypt(encrypted: Ciphertext, peer: UnsignedPublicKey, additionalData?: Uint8Array): Promise<Uint8Array>;
    matches(key: SignedPublicKey): boolean;
    equals(other: this): boolean;
    toBytes(): Uint8Array;
    validatePublicKey(): boolean;
    static fromBytes(bytes: Uint8Array): SignedPrivateKey;
    static fromLegacyKey(key: PrivateKey, signedByWallet?: boolean): SignedPrivateKey;
}
declare class PrivateKey implements privateKey.PrivateKey {
    timestamp: Long;
    secp256k1: secp256k1;
    publicKey: PublicKey;
    constructor(obj: privateKey.PrivateKey);
    static generate(): PrivateKey;
    generated(): Date | undefined;
    sign(digest: Uint8Array): Promise<Signature>;
    signKey(pub: PublicKey): Promise<PublicKey>;
    sharedSecret(peer: PublicKey | SignedPublicKey): Uint8Array;
    encrypt(plain: Uint8Array, peer: PublicKey, additionalData?: Uint8Array): Promise<Ciphertext>;
    decrypt(encrypted: Ciphertext, peer: PublicKey, additionalData?: Uint8Array): Promise<Uint8Array>;
    matches(key: PublicKey): boolean;
    validatePublicKey(): boolean;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): PrivateKey;
}

declare class PrivateKeyBundleV2 implements privateKey.PrivateKeyBundleV2 {
    identityKey: SignedPrivateKey;
    preKeys: SignedPrivateKey[];
    version: number;
    private _publicKeyBundle?;
    constructor(bundle: privateKey.PrivateKeyBundleV2);
    static generate(wallet: Signer): Promise<PrivateKeyBundleV2>;
    getCurrentPreKey(): SignedPrivateKey;
    findPreKey(which: SignedPublicKey): SignedPrivateKey;
    addPreKey(): Promise<void>;
    getPublicKeyBundle(): SignedPublicKeyBundle;
    sharedSecret(peer: SignedPublicKeyBundle, myPreKey: SignedPublicKey, isRecipient: boolean): Promise<Uint8Array>;
    encode(): Uint8Array;
    validatePublicKeys(): boolean;
    equals(other: this): boolean;
    static fromLegacyBundle(bundle: PrivateKeyBundleV1): PrivateKeyBundleV2;
}
declare class PrivateKeyBundleV1 implements privateKey.PrivateKeyBundleV1 {
    identityKey: PrivateKey;
    preKeys: PrivateKey[];
    version: number;
    private _publicKeyBundle?;
    constructor(bundle: privateKey.PrivateKeyBundleV1);
    static generate(wallet?: Signer): Promise<PrivateKeyBundleV1>;
    getCurrentPreKey(): PrivateKey;
    findPreKey(which: PublicKey): PrivateKey;
    addPreKey(): Promise<void>;
    getPublicKeyBundle(): PublicKeyBundle;
    validatePublicKeys(): boolean;
    sharedSecret(peer: PublicKeyBundle | SignedPublicKeyBundle, myPreKey: PublicKey, isRecipient: boolean): Promise<Uint8Array>;
    encode(): Uint8Array;
}
declare type PrivateKeyBundle = PrivateKeyBundleV1 | PrivateKeyBundleV2;

declare function encrypt(plain: Uint8Array, secret: Uint8Array, additionalData?: Uint8Array): Promise<Ciphertext>;
declare function decrypt(encrypted: Ciphertext | ciphertext.Ciphertext, secret: Uint8Array, additionalData?: Uint8Array): Promise<Uint8Array>;

declare class AuthData implements authn.AuthData {
    walletAddr: string;
    createdNs: Long;
    constructor({ walletAddr, createdNs }: authn.AuthData);
    static create(walletAddr: string, timestamp?: Date): AuthData;
    static fromBytes(bytes: Uint8Array): AuthData;
    toBytes(): Uint8Array;
}

declare class Token implements authn.Token {
    identityKey: publicKey.PublicKey;
    authDataBytes: Uint8Array;
    authDataSignature: signature.Signature;
    private _authData?;
    constructor({ identityKey, authDataBytes, authDataSignature }: authn.Token);
    get authData(): AuthData;
    get ageMs(): number;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): Token;
    toBase64(): string;
}

declare class LocalAuthenticator {
    private identityKey;
    constructor(identityKey: PrivateKey);
    createToken(timestamp?: Date): Promise<Token>;
}

declare type Flatten<T> = {
    [K in keyof T]: T[K];
};
declare type WithoutUndefined<T> = {
    [P in keyof T]: NonNullable<T[P]>;
};

/**
 * A Keystore is responsible for holding the user's XMTP private keys and using them to encrypt/decrypt/sign messages.
 * Keystores are instantiated using a `KeystoreProvider`
 */
interface Keystore {
    /**
     * Decrypt a batch of V1 messages
     */
    decryptV1(req: keystore.DecryptV1Request): Promise<keystore.DecryptResponse>;
    /**
     * Decrypt a batch of V2 messages
     */
    decryptV2(req: keystore.DecryptV2Request): Promise<keystore.DecryptResponse>;
    /**
     * Encrypt a batch of V1 messages
     */
    encryptV1(req: keystore.EncryptV1Request): Promise<keystore.EncryptResponse>;
    /**
     * Encrypt a batch of V2 messages
     */
    encryptV2(req: keystore.EncryptV2Request): Promise<keystore.EncryptResponse>;
    /**
     * Take a batch of invite messages and store the `TopicKeys` for later use in decrypting messages
     */
    saveInvites(req: keystore.SaveInvitesRequest): Promise<keystore.SaveInvitesResponse>;
    /**
     * Create a sealed/encrypted invite and store the Topic keys in the Keystore for later use.
     * The returned invite payload must be sent to the network for the other party to be able to communicate.
     */
    createInvite(req: keystore.CreateInviteRequest): Promise<keystore.CreateInviteResponse>;
    /**
     * Create an XMTP auth token to be used as a header on XMTP API requests
     */
    createAuthToken(req: keystore.CreateAuthTokenRequest): Promise<authn.Token>;
    /**
     * Sign the provided digest with either the `IdentityKey` or a specified `PreKey`
     */
    signDigest(req: keystore.SignDigestRequest): Promise<signature.Signature>;
    /**
     * Get a refresh job from the persistence
     */
    getRefreshJob(req: keystore.GetRefreshJobRequest): Promise<keystore.GetRefreshJobResponse>;
    /**
     * Sets the time of a refresh job
     */
    setRefreshJob(req: keystore.SetRefeshJobRequest): Promise<keystore.SetRefreshJobResponse>;
    /**
     * Save V1 Conversations
     */
    saveV1Conversations(req: keystore.SaveV1ConversationsRequest): Promise<keystore.SaveV1ConversationsResponse>;
    /**
     * Get a list of V1 conversations
     */
    getV1Conversations(): Promise<keystore.GetConversationsResponse>;
    /**
     * Get a list of V2 conversations
     */
    getV2Conversations(): Promise<keystore.GetConversationsResponse>;
    /**
     * Get the `PublicKeyBundle` associated with the Keystore's private keys
     */
    getPublicKeyBundle(): Promise<publicKey.PublicKeyBundle>;
    /**
     * Export the private keys. May throw an error if the keystore implementation does not allow this operation
     */
    getPrivateKeyBundle(): Promise<privateKey.PrivateKeyBundleV1>;
    /**
     * Get the account address of the wallet used to create the Keystore
     */
    getAccountAddress(): Promise<string>;
}
declare type TopicData = WithoutUndefined<keystore.TopicMap_TopicData>;

interface Persistence {
    getItem(key: string): Promise<Uint8Array | null>;
    setItem(key: string, value: Uint8Array): Promise<void>;
}

declare type AddRequest = {
    topic: string;
    createdNs: Long;
    peerAddress: string;
    invitation: invitation.InvitationV1 | undefined;
};
/**
 * V2Store holds a simple map of topic -> TopicData and writes to the persistence layer on changes
 */
declare class V2Store {
    private readonly persistence;
    private readonly persistenceKey;
    private readonly mutex;
    private readonly topicMap;
    private revision;
    constructor(persistence: Persistence, persistenceKey: string, initialData?: Map<string, keystore.TopicMap_TopicData>);
    get revisionKey(): string;
    static create(persistence: Persistence): Promise<V2Store>;
    protected validate(topicData: AddRequest): boolean;
    refresh(): Promise<void>;
    getRevision(): Promise<number>;
    setRevision(number: number): Promise<void>;
    loadFromPersistence(): Promise<Map<string, keystore.TopicMap_TopicData>>;
    store(): Promise<void>;
    add(topicData: AddRequest[]): Promise<void>;
    get topics(): keystore.TopicMap_TopicData[];
    lookup(topic: string): keystore.TopicMap_TopicData | undefined;
    private toBytes;
}
declare class V1Store extends V2Store {
    static create(persistence: Persistence): Promise<V1Store>;
    protected validate(topicData: AddRequest): boolean;
}

declare class BrowserStoragePersistence implements Persistence {
    storage: Storage;
    constructor(storage: Storage);
    static create(): BrowserStoragePersistence;
    getItem(key: string): Promise<Uint8Array | null>;
    setItem(key: string, value: Uint8Array): Promise<void>;
}

declare class InMemoryPersistence extends BrowserStoragePersistence {
    static create(): BrowserStoragePersistence;
}

declare class PrefixedPersistence {
    prefix: string;
    persistence: Persistence;
    constructor(prefix: string, persistence: Persistence);
    getItem(key: string): Promise<Uint8Array | null>;
    setItem(key: string, value: Uint8Array): Promise<void>;
    private buildKey;
}

/**
 * EncryptedPersistence is a Persistence implementation that uses ECIES to encrypt all values
 * ECIES encryption protects against unauthorized reads, but not unauthorized writes.
 * A third party with access to the underlying store could write malicious data using the public key of the owner
 */
declare class EncryptedPersistence implements Persistence {
    private persistence;
    private privateKey;
    private privateKeyBytes;
    private publicKey;
    constructor(persistence: Persistence, privateKey: PrivateKey | SignedPrivateKey);
    getItem(key: string): Promise<Uint8Array | null>;
    setItem(key: string, value: Uint8Array): Promise<void>;
    private encrypt;
    private decrypt;
    private serializeEcies;
    private deserializeEcies;
}

declare class InMemoryKeystore implements Keystore {
    private v1Keys;
    private v2Keys;
    private v1Store;
    private v2Store;
    private authenticator;
    private accountAddress;
    private jobStatePersistence;
    constructor(keys: PrivateKeyBundleV1, v1Store: V1Store, v2Store: V2Store, persistence: Persistence);
    static create(keys: PrivateKeyBundleV1, persistence: Persistence): Promise<InMemoryKeystore>;
    get walletAddress(): string;
    decryptV1(req: keystore.DecryptV1Request): Promise<keystore.DecryptResponse>;
    decryptV2(req: keystore.DecryptV2Request): Promise<keystore.DecryptResponse>;
    encryptV1(req: keystore.EncryptV1Request): Promise<keystore.EncryptResponse>;
    createAuthToken({ timestampNs, }: keystore.CreateAuthTokenRequest): Promise<authn.Token>;
    encryptV2(req: keystore.EncryptV2Request): Promise<keystore.EncryptResponse>;
    saveInvites(req: keystore.SaveInvitesRequest): Promise<keystore.SaveInvitesResponse>;
    createInvite(req: keystore.CreateInviteRequest): Promise<keystore.CreateInviteResponse>;
    signDigest(req: keystore.SignDigestRequest): Promise<signature.Signature>;
    saveV1Conversations({ conversations, }: keystore.SaveV1ConversationsRequest): Promise<keystore.SaveV1ConversationsResponse>;
    getV1Conversations(): Promise<keystore.GetConversationsResponse>;
    getV2Conversations(): Promise<keystore.GetConversationsResponse>;
    getPublicKeyBundle(): Promise<PublicKeyBundle>;
    getPrivateKeyBundle(): Promise<privateKey.PrivateKeyBundleV1>;
    getAccountAddress(): Promise<string>;
    getRefreshJob({ jobType, }: keystore.GetRefreshJobRequest): Promise<keystore.GetRefreshJobResponse>;
    setRefreshJob({ jobType, lastRunNs, }: keystore.SetRefeshJobRequest): Promise<keystore.SetRefreshJobResponse>;
    private topicDataToV1ConversationReference;
    private buildJobStorageKey;
    private getLastRunTime;
    lookupTopic(topic: string): keystore.TopicMap_TopicData | undefined;
}

declare const buildContentTopic: (name: string) => string;
declare const buildDirectMessageTopic: (sender: string, recipient: string) => string;
declare const buildDirectMessageTopicV2: (randomString: string) => string;
declare const buildUserContactTopic: (walletAddr: string) => string;
declare const buildUserIntroTopic: (walletAddr: string) => string;
declare const buildUserInviteTopic: (walletAddr: string) => string;
declare const buildUserPrivateStoreTopic: (addrPrefixedKey: string) => string;

declare type IsRetryable = (err?: Error) => boolean;
declare function retry<T extends (...arg0: any[]) => any>(fn: T, args: Parameters<T>, maxRetries: number, sleepTime: number, isRetryableFn?: IsRetryable, retryCount?: number): Promise<Awaited<ReturnType<T>>>;
declare type EnvelopeMapper<Out> = (env: messageApi.Envelope) => Promise<Out>;
declare function mapPaginatedStream<Out>(gen: AsyncGenerator<messageApi.Envelope[]>, mapper: EnvelopeMapper<Out>): AsyncGenerator<Out[]>;

declare function dateToNs(date: Date): Long;
declare function nsToDate(ns: Long): Date;
declare const toNanoString: (d: Date | undefined) => undefined | string;
declare const fromNanoString: (s: string | undefined) => undefined | Date;

declare type InvitationContext = {
    conversationId: string;
    metadata: {
        [k: string]: string;
    };
};
/**
 * InvitationV1 is a protobuf message to be encrypted and used as the ciphertext in a SealedInvitationV1 message
 */
declare class InvitationV1 implements invitation.InvitationV1 {
    topic: string;
    context: InvitationContext | undefined;
    aes256GcmHkdfSha256: invitation.InvitationV1_Aes256gcmHkdfsha256;
    constructor({ topic, context, aes256GcmHkdfSha256, }: invitation.InvitationV1);
    static createRandom(context?: invitation.InvitationV1_Context): InvitationV1;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): InvitationV1;
}
/**
 * SealedInvitationHeaderV1 is a protobuf message to be used as the headerBytes in a SealedInvitationV1
 */
declare class SealedInvitationHeaderV1 implements invitation.SealedInvitationHeaderV1 {
    sender: SignedPublicKeyBundle;
    recipient: SignedPublicKeyBundle;
    createdNs: Long;
    constructor({ sender, recipient, createdNs, }: invitation.SealedInvitationHeaderV1);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationHeaderV1;
}
declare class SealedInvitationV1 implements invitation.SealedInvitationV1 {
    headerBytes: Uint8Array;
    ciphertext: Ciphertext;
    private _header?;
    private _invitation?;
    constructor({ headerBytes, ciphertext }: invitation.SealedInvitationV1);
    /**
     * Accessor method for the full header object
     */
    get header(): SealedInvitationHeaderV1;
    /**
     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
     */
    getInvitation(viewer: PrivateKeyBundleV2): Promise<InvitationV1>;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationV1;
}
/**
 * Wrapper class for SealedInvitationV1 and any future iterations of SealedInvitation
 */
declare class SealedInvitation implements invitation.SealedInvitation {
    v1: SealedInvitationV1 | undefined;
    constructor({ v1 }: invitation.SealedInvitation);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitation;
    static fromEnvelope(env: messageApi.Envelope): Promise<SealedInvitation>;
    /**
     * Create a SealedInvitation with a SealedInvitationV1 payload
     * Will encrypt all contents and validate inputs
     */
    static createV1({ sender, recipient, created, invitation, }: {
        sender: PrivateKeyBundleV2;
        recipient: SignedPublicKeyBundle;
        created: Date;
        invitation: InvitationV1;
    }): Promise<SealedInvitation>;
}

declare type MessageDecoder<M> = (env: messageApi.Envelope) => Promise<M | undefined>;
declare type ContentTopicUpdater<M> = (msg: M) => string[] | undefined;
/**
 * Stream implements an Asynchronous Iterable over messages received from a topic.
 * As such can be used with constructs like for-await-of, yield*, array destructing, etc.
 */
declare class Stream<T, ClientType = any> {
    topics: string[];
    client: Client<ClientType>;
    messages: T[];
    resolvers: ((value: IteratorResult<T>) => void)[];
    callback: ((env: messageApi.Envelope) => Promise<void>) | undefined;
    subscriptionManager?: SubscriptionManager;
    onConnectionLost?: OnConnectionLostCallback;
    constructor(client: Client<ClientType>, topics: string[], decoder: MessageDecoder<T>, contentTopicUpdater?: ContentTopicUpdater<T>, onConnectionLost?: OnConnectionLostCallback);
    private newMessageCallback;
    private start;
    static create<T, ClientType = string>(client: Client<ClientType>, topics: string[], decoder: MessageDecoder<T>, contentTopicUpdater?: ContentTopicUpdater<T>, onConnectionLost?: OnConnectionLostCallback): Promise<Stream<T, ClientType>>;
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
    return(): Promise<IteratorResult<T>>;
    next(): Promise<IteratorResult<T>>;
    private resubscribeToTopics;
}

/**
 * Conversations allows you to view ongoing 1:1 messaging sessions with another wallet
 */
declare class Conversations<ContentTypes = any> {
    private client;
    private v1JobRunner;
    private v2JobRunner;
    constructor(client: Client<ContentTypes>);
    /**
     * List all conversations with the current wallet found in the network.
     */
    list(): Promise<Conversation<ContentTypes>[]>;
    /**
     * List all conversations stored in the client cache, which may not include
     * conversations on the network.
     */
    listFromCache(): Promise<Conversation<ContentTypes>[]>;
    private listV1Conversations;
    /**
     * List all V2 conversations
     */
    private listV2Conversations;
    private getV2ConversationsFromKeystore;
    private getV1ConversationsFromKeystore;
    updateV2Conversations(startTime?: Date): Promise<ConversationV2<ContentTypes>[]>;
    private decodeInvites;
    private saveInviteResponseToConversation;
    private conversationReferenceToV2;
    private conversationReferenceToV1;
    /**
     * Returns a stream of any newly created conversations.
     * Will dedupe to not return the same conversation twice in the same stream.
     * Does not dedupe any other previously seen conversations
     */
    stream(onConnectionLost?: OnConnectionLostCallback): Promise<Stream<Conversation<ContentTypes>, ContentTypes>>;
    /**
     * Streams messages from all conversations.
     *
     * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.
     * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.
     *
     */
    streamAllMessages(onConnectionLost?: OnConnectionLostCallback): Promise<AsyncGenerator<DecodedMessage<ContentTypes>>>;
    private getIntroductionPeers;
    /**
     * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network
     */
    newConversation(peerAddress: string, context?: InvitationContext): Promise<Conversation<ContentTypes>>;
    private createV2Convo;
    private getPeerAddress;
}

declare class ContentTypeId {
    authorityId: string;
    typeId: string;
    versionMajor: number;
    versionMinor: number;
    constructor(obj: content.ContentTypeId);
    toString(): string;
    static fromString(contentTypeString: string): ContentTypeId;
    sameAs(id: ContentTypeId): boolean;
}
interface EncodedContent<Parameters = Record<string, string>> {
    type: ContentTypeId;
    parameters: Parameters;
    fallback?: string;
    compression?: number;
    content: Uint8Array;
}
interface CodecRegistry {
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
}
interface ContentCodec<T> {
    contentType: ContentTypeId;
    encode(content: T, registry: CodecRegistry): EncodedContent;
    decode(content: EncodedContent, registry: CodecRegistry): T;
    fallback(content: T): string | undefined;
}
declare const ContentTypeFallback: ContentTypeId;

declare const ContentTypeText: ContentTypeId;
declare class TextCodec implements ContentCodec<string> {
    get contentType(): ContentTypeId;
    encode(content: string): EncodedContent;
    decode(content: EncodedContent): string;
    fallback(content: string): string | undefined;
}

/**
 * Where message backups should be stored
 */
declare enum BackupType {
    none = 0,
    xmtpTopicStore = 1
}
interface BackupClient {
    get backupType(): BackupType;
}

declare type KeystoreProviderOptions = {
    env: XmtpEnv;
    persistConversations: boolean;
    privateKeyOverride?: Uint8Array;
    basePersistence: Persistence;
    disablePersistenceEncryption: boolean;
} & PreEventCallbackOptions;
/**
 * A Keystore Provider is responsible for either creating a Keystore instance or throwing a KeystoreUnavailableError
 * It is typically used once on application startup to bootstrap the Keystore and load/decrypt the user's private keys
 */
interface KeystoreProvider {
    newKeystore(opts: KeystoreProviderOptions, apiClient: ApiClient, wallet?: Signer): Promise<Keystore>;
}

/**
 * KeyGeneratorKeystoreProvider will create a new XMTP `PrivateKeyBundle` and persist it to the network
 * This provider should always be specified last in the list of `keystoreProviders` on client creation,
 * as it will overwrite any XMTP identities already on the network
 */
declare class KeyGeneratorKeystoreProvider implements KeystoreProvider {
    newKeystore(opts: KeystoreProviderOptions, apiClient: ApiClient, wallet?: Signer): Promise<Keystore>;
}

/**
 * NetworkKeystoreProvider will look on the XMTP network for an `EncryptedPrivateKeyBundle`
 * on the user's private storage topic. If found, will decrypt the bundle using a wallet
 * signature and instantiate a Keystore instance using the decrypted value.
 */
declare class NetworkKeystoreProvider implements KeystoreProvider {
    newKeystore(opts: KeystoreProviderOptions, apiClient: ApiClient, wallet?: Signer): Promise<Keystore>;
}

/**
 * StaticKeystoreProvider will look for a `privateKeyOverride` in the provided options,
 * and bootstrap a Keystore using those options if provided.
 *
 * If no `privateKeyOverride` is supplied will throw a `KeystoreProviderUnavailableError` causing
 * the client to continue iterating through the `KeystoreProviders` list.
 */
declare class StaticKeystoreProvider implements KeystoreProvider {
    newKeystore(opts: KeystoreProviderOptions): Promise<Keystore>;
}

/**
 * The Snap keystore provider will:
 * 1. Check if the user is capable of using Snaps
 * 2. Check if the user has already setup the Snap with the appropriate keys
 * 3. If not, will get keys from the network or create new keys and store them in the Snap
 */
declare class SnapKeystoreProvider implements KeystoreProvider {
    snapId: string;
    snapVersion?: string;
    constructor(snapId?: string, snapVersion?: string);
    newKeystore(opts: KeystoreProviderOptions, apiClient: ApiClient, wallet?: Signer): Promise<Keystore>;
}

declare type GetMessageContentTypeFromClient<C> = C extends Client<infer T> ? T : never;
declare type ExtractDecodedType<C> = C extends ContentCodec<infer T> ? T : never;

declare const Compression: typeof content.Compression;
declare type ListMessagesOptions = {
    checkAddresses?: boolean;
    startTime?: Date;
    endTime?: Date;
    limit?: number;
    direction?: messageApi.SortDirection;
};
declare type ListMessagesPaginatedOptions = {
    startTime?: Date;
    endTime?: Date;
    pageSize?: number;
    direction?: messageApi.SortDirection;
};
declare type SendOptions = {
    contentType?: ContentTypeId;
    compression?: content.Compression;
    timestamp?: Date;
    ephemeral?: boolean;
};

declare type XmtpEnv = keyof typeof ApiUrls;
declare type PreEventCallback = () => Promise<void>;
/**
 * Network startup options
 */
declare type NetworkOptions = {
    /**
     * Specify which XMTP environment to connect to. (default: `dev`)
     */
    env: XmtpEnv;
    /**
     * apiUrl can be used to override the `env` flag and connect to a
     * specific endpoint
     */
    apiUrl: string | undefined;
    /**
     * identifier that's included with API requests.
     *
     * For example, you can use the following format:
     * `appVersion: APP_NAME + '/' + APP_VERSION`.
     * Setting this value provides telemetry that shows which apps are
     * using the XMTP client SDK. This information can help XMTP developers
     * provide app support, especially around communicating important
     * SDK updates, including deprecations and required upgrades.
     */
    appVersion?: string;
    /**
     * Skip publishing the user's contact bundle as part of Client startup.
     *
     * This flag should be used with caution, as we rely on contact publishing to
     * let other users know your public key and periodically run migrations on
     * this data with new SDK versions.
     *
     * Your application should have this flag set to `false` at least _some_ of the
     * time.
     *
     * The most common use-case for setting this to `true` is cases where the Client
     * instance is very short-lived. For example, spinning up a Client to decrypt
     * a push notification.
     */
    skipContactPublishing: boolean;
    apiClientFactory: (options: NetworkOptions) => ApiClient;
};
declare type ContentOptions = {
    /**
     * Allow configuring codecs for additional content types
     */
    codecs: ContentCodec<any>[];
    /**
     * Set the maximum content size in bytes that is allowed by the Client.
     * Currently only checked when decompressing compressed content.
     */
    maxContentSize: number;
};
declare type KeyStoreOptions = {
    /**
     * Provide an array of KeystoreProviders.
     * The client will attempt to use each one in sequence until one successfully
     * returns a Keystore instance
     */
    keystoreProviders: KeystoreProvider[];
    /**
     * Enable the Keystore to persist conversations in the provided storage interface
     */
    persistConversations: boolean;
    /**
     * Provide a XMTP PrivateKeyBundle encoded as a Uint8Array.
     * A bundle can be retried using `Client.getKeys(...)`
     */
    privateKeyOverride?: Uint8Array;
    /**
     * Override the base persistence provider.
     * Defaults to LocalStoragePersistence, which is fine for most implementations
     */
    basePersistence: Persistence;
    /**
     * Whether or not the persistence provider should encrypt the values.
     * Only disable if you are using a secure datastore that already has encryption
     */
    disablePersistenceEncryption: boolean;
    /**
     * A single option to allow Metamask Snaps to be used as a keystore provider
     */
    useSnaps: boolean;
};
declare type LegacyOptions = {
    publishLegacyContact?: boolean;
};
declare type PreEventCallbackOptions = {
    /**
     * preCreateIdentityCallback will be called immediately before a Create Identity
     * wallet signature is requested from the user.
     *
     * The provided function must return a Promise and will be awaited, allowing the
     * developer to update the UI or insert a required delay before requesting a signature.
     */
    preCreateIdentityCallback?: PreEventCallback;
    /**
     * preEnableIdentityCallback will be called immediately before an Enable Identity
     * wallet signature is requested from the user.
     *
     * The provided function must return a Promise and will be awaited, allowing the
     * developer to update the UI or insert a required delay before requesting a signature.
     */
    preEnableIdentityCallback?: PreEventCallback;
};
/**
 * Aggregate type for client options. Optional properties are used when the default value is calculated on invocation, and are computed
 * as needed by each function. All other defaults are specified in defaultOptions.
 */
declare type ClientOptions = Flatten<NetworkOptions & KeyStoreOptions & ContentOptions & LegacyOptions & PreEventCallbackOptions>;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
declare class Client<ContentTypes = any> {
    address: string;
    keystore: Keystore;
    apiClient: ApiClient;
    contacts: Set<string>;
    publicKeyBundle: PublicKeyBundle;
    private knownPublicKeyBundles;
    private _backupClient;
    private readonly _conversations;
    private _codecs;
    private _maxContentSize;
    constructor(publicKeyBundle: PublicKeyBundle, apiClient: ApiClient, backupClient: BackupClient, keystore: Keystore);
    /**
     * @type {Conversations}
     */
    get conversations(): Conversations<ContentTypes>;
    get backupType(): BackupType;
    get signedPublicKeyBundle(): SignedPublicKeyBundle;
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create<ContentCodecs extends ContentCodec<any>[] = []>(wallet: Signer | null, opts?: Partial<ClientOptions> & {
        codecs?: ContentCodecs;
    }): Promise<Client<ExtractDecodedType<[...ContentCodecs, TextCodec][number]> | undefined>>;
    /**
     * Export the XMTP PrivateKeyBundle from the SDK as a `Uint8Array`.
     *
     * This bundle can then be provided as `privateKeyOverride` in a
     * subsequent call to `Client.create(...)`
     *
     * Be very careful with these keys, as they can be used to
     * impersonate a user on the XMTP network and read the user's
     * messages.
     */
    static getKeys<U>(wallet: Signer | null, opts?: Partial<ClientOptions> & {
        codecs?: U;
    }): Promise<Uint8Array>;
    /**
     * Tells the caller whether the browser has a Snaps-compatible version of MetaMask installed
     */
    static isSnapsReady(): Promise<boolean>;
    private static setupBackupClient;
    private init;
    close(): Promise<void>;
    private ensureUserContactPublished;
    publishUserContact(legacy?: boolean): Promise<void>;
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     *
     * This throws if either the address is invalid or the contact is not published.
     * See also [#canMessage].
     */
    getUserContact(peerAddress: string): Promise<PublicKeyBundle | SignedPublicKeyBundle | undefined>;
    /**
     * Identical to getUserContact but for multiple peer addresses
     */
    getUserContacts(peerAddresses: string[]): Promise<(PublicKeyBundle | SignedPublicKeyBundle | undefined)[]>;
    /**
     * Used to force getUserContact fetch contact from the network.
     */
    forgetContact(peerAddress: string): void;
    canMessage(peerAddress: string): Promise<boolean>;
    canMessage(peerAddress: string[]): Promise<boolean[]>;
    static canMessage(peerAddress: string, opts?: Partial<NetworkOptions>): Promise<boolean>;
    static canMessage(peerAddress: string[], opts?: Partial<NetworkOptions>): Promise<boolean[]>;
    private validateEnvelope;
    /**
     * Low level method for publishing envelopes to the XMTP network with
     * no pre-processing or encryption applied.
     *
     * Primarily used internally
     *
     * @param envelopes PublishParams[]
     */
    publishEnvelopes(envelopes: PublishParams[]): Promise<void>;
    /**
     * Register a codec to be automatically used for encoding/decoding
     * messages of the given Content Type
     */
    registerCodec<Codec extends ContentCodec<any>>(codec: Codec): Client<ContentTypes | ExtractDecodedType<Codec>>;
    /**
     * Find a matching codec for a given `ContentTypeId` from the
     * client's codec registry
     */
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
    /**
     * Convert arbitrary content into a serialized `EncodedContent` instance
     * with the given options
     */
    encodeContent(content: ContentTypes, options?: SendOptions): Promise<Uint8Array>;
    decodeContent(contentBytes: Uint8Array): Promise<{
        content: ContentTypes;
        contentType: ContentTypeId;
        error?: Error;
        contentFallback?: string;
    }>;
    listInvitations(opts?: ListMessagesOptions): Promise<messageApi.Envelope[]>;
    /**
     * List stored messages from the specified topic.
     *
     * A specified mapper function will be applied to each envelope.
     * If the mapper function throws an error during processing, the
     * envelope will be discarded.
     */
    listEnvelopes<Out>(topic: string, mapper: EnvelopeMapper<Out>, opts?: ListMessagesOptions): Promise<Out[]>;
    /**
     * List messages on a given set of content topics, yielding one page at a time
     */
    listEnvelopesPaginated<Out>(contentTopic: string, mapper: EnvelopeMapper<Out>, opts?: ListMessagesPaginatedOptions): AsyncGenerator<Out[]>;
}
/**
 * Get the default list of `KeystoreProviders` used in the SDK
 *
 * Particularly useful if a developer wants to add their own
 * provider to the head of the list while falling back to the
 * default functionality
 */
declare function defaultKeystoreProviders(): KeystoreProvider[];

declare type Codec<T> = {
    decode(input: Reader | Uint8Array, length?: number): T;
    encode(message: T, writer?: Writer): Writer;
};
declare type RPC<Req, Res> = {
    req: Codec<Req> | null;
    res: Codec<Res>;
};
declare type ApiDefs = {
    [k: string]: RPC<any, any>;
};
declare const apiDefs: ApiDefs;

interface Authenticator {
    createToken(timestamp?: Date): Promise<Token>;
}

declare class AuthCache {
    private authenticator;
    private token?;
    maxAgeMs: number;
    constructor(authenticator: Authenticator, cacheExpirySeconds?: number);
    getToken(): Promise<string>;
    refresh(): Promise<void>;
}

declare const MessageApi: typeof messageApi.MessageApi;
declare const SortDirection: typeof messageApi.SortDirection;
declare const ApiUrls: {
    readonly local: "http://localhost:5555";
    readonly dev: "https://dev.xmtp.network";
    readonly production: "https://production.xmtp.network";
};
declare type QueryParams = {
    startTime?: Date;
    endTime?: Date;
    contentTopic: string;
};
declare type QueryAllOptions = {
    direction?: messageApi.SortDirection;
    limit?: number;
};
declare type QueryStreamOptions = Flatten<Omit<QueryAllOptions, 'limit'> & {
    pageSize?: number;
}>;
declare type Query = Flatten<QueryParams & QueryStreamOptions>;
declare type PublishParams = {
    contentTopic: string;
    message: Uint8Array;
    timestamp?: Date;
};
declare type SubscribeParams = {
    contentTopics: string[];
};
declare type ApiClientOptions = {
    maxRetries?: number;
    appVersion?: string;
};
declare type SubscribeCallback = NotifyStreamEntityArrival<messageApi.Envelope>;
declare type UnsubscribeFn = () => Promise<void>;
declare type UpdateContentTopics = (topics: string[]) => Promise<void>;
declare type SubscriptionManager = {
    unsubscribe: UnsubscribeFn;
    updateContentTopics?: UpdateContentTopics;
};
declare type OnConnectionLostCallback = () => void;
interface ApiClient {
    query(params: QueryParams, options: QueryAllOptions): Promise<messageApi.Envelope[]>;
    queryIterator(params: QueryParams, options: QueryStreamOptions): AsyncGenerator<messageApi.Envelope>;
    queryIteratePages(params: QueryParams, options: QueryStreamOptions): AsyncGenerator<messageApi.Envelope[]>;
    subscribe(params: SubscribeParams, callback: SubscribeCallback, onConnectionLost?: OnConnectionLostCallback): SubscriptionManager;
    publish(messages: PublishParams[]): ReturnType<typeof MessageApi.Publish>;
    batchQuery(queries: Query[]): Promise<messageApi.Envelope[][]>;
    setAuthenticator(authenticator: Authenticator, cacheExpirySeconds?: number): void;
}
/**
 * ApiClient provides a wrapper for calling the GRPC Gateway generated code.
 * It adds some helpers for dealing with paginated data and automatically retries idempotent calls
 */
declare class HttpApiClient implements ApiClient {
    pathPrefix: string;
    maxRetries: number;
    private authCache?;
    appVersion: string | undefined;
    version: string;
    constructor(pathPrefix: string, opts?: ApiClientOptions);
    private _query;
    private _batchQuery;
    private _publish;
    private _subscribe;
    query(params: QueryParams, { direction, limit, }: QueryAllOptions): Promise<messageApi.Envelope[]>;
    queryIterator(params: QueryParams, options: QueryStreamOptions): AsyncGenerator<messageApi.Envelope>;
    queryIteratePages({ contentTopic, startTime, endTime }: QueryParams, { direction, pageSize }: QueryStreamOptions): AsyncGenerator<messageApi.Envelope[]>;
    batchQuery(queries: Query[]): Promise<messageApi.Envelope[][]>;
    publish(messages: PublishParams[]): ReturnType<typeof MessageApi.Publish>;
    subscribe(params: SubscribeParams, callback: SubscribeCallback, onConnectionLost?: OnConnectionLostCallback): SubscriptionManager;
    private getToken;
    setAuthenticator(authenticator: Authenticator, cacheExpirySeconds?: number): void;
    headers(): Headers;
}

declare class PreparedMessage {
    messageEnvelope: Envelope;
    onSend: () => Promise<void>;
    constructor(messageEnvelope: Envelope, onSend: () => Promise<void>);
    messageID(): Promise<string>;
    send(): Promise<void>;
}

/**
 * Conversation represents either a V1 or V2 conversation with a common set of methods.
 */
interface Conversation<ContentTypes = any> {
    conversationVersion: 'v1' | 'v2';
    /**
     * The wallet address connected to the client
     */
    clientAddress: string;
    /**
     * A unique identifier for a conversation. Each conversation is stored on the network on one topic
     */
    topic: string;
    /**
     * A unique identifier for ephemeral envelopes for a conversation.
     */
    ephemeralTopic: string;
    /**
     * The wallet address of the other party in the conversation
     */
    peerAddress: string;
    /**
     * Timestamp the conversation was created at
     */
    createdAt: Date;
    /**
     * Optional field containing the `conversationId` and `metadata` for V2 conversations.
     * Will always be undefined on V1 conversations
     */
    context?: InvitationContext | undefined;
    /**
     * Retrieve messages in this conversation. Default to returning all messages.
     *
     * If only a subset is required, results can be narrowed by specifying a start/end
     * timestamp.
     *
     * ```ts
     * // Get all messages in the past 24 hours
     * const messages = await conversation.messages({
     *    startTime: new Date(+new Date() - 86_400)
     * })
     * ```
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage<ContentTypes>[]>;
    /**
     * @deprecated
     */
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage<ContentTypes>[]>;
    /**
     * Takes a XMTP envelope as input and will decrypt and decode it
     * returning a `DecodedMessage` instance.
     */
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage<ContentTypes>>;
    /**
     * Return a `Stream` of new messages in this conversation.
     *
     * Stream instances are async generators and can be used in
     * `for await` statements.
     *
     * ```ts
     * for await (const message of await conversation.stream()) {
     *    console.log(message.content)
     * }
     * ```
     */
    streamMessages(): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>>;
    /**
     * Send a message into the conversation
     *
     * ## Example
     * ```ts
     * await conversation.send('Hello world') // returns a `DecodedMessage` instance
     * ```
     */
    send(content: Exclude<ContentTypes, undefined>, options?: SendOptions): Promise<DecodedMessage<ContentTypes>>;
    /**
     * Return a `PreparedMessage` that has contains the message ID
     * of the message that will be sent.
     */
    prepareMessage(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<PreparedMessage>;
    /**
     * Return a `Stream` of new ephemeral messages from this conversation's
     * ephemeral topic.
     *
     * Stream instances are async generators and can be used in
     * `for await` statements.
     *
     * ```ts
     * for await (const message of await conversation.streamEphemeral()) {
     *    console.log(message.content)
     * }
     * ```
     */
    streamEphemeral(): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>>;
}
/**
 * ConversationV1 allows you to view, stream, and send messages to/from a peer address
 */
declare class ConversationV1<ContentTypes> implements Conversation<ContentTypes> {
    conversationVersion: "v1";
    peerAddress: string;
    createdAt: Date;
    context: undefined;
    private client;
    constructor(client: Client<ContentTypes>, address: string, createdAt: Date);
    get clientAddress(): string;
    get topic(): string;
    get ephemeralTopic(): string;
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage<ContentTypes>[]>;
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage<ContentTypes>[]>;
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage<ContentTypes>>;
    prepareMessage(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<PreparedMessage>;
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages(onConnectionLost?: OnConnectionLostCallback): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>>;
    processEnvelope({ message, contentTopic, }: messageApi.Envelope): Promise<MessageV1>;
    streamEphemeral(onConnectionLost?: OnConnectionLostCallback): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>>;
    /**
     * Send a message into the conversation.
     */
    send(content: Exclude<ContentTypes, undefined>, options?: SendOptions): Promise<DecodedMessage<ContentTypes>>;
    decryptBatch(messages: MessageV1[], topic: string, throwOnError?: boolean): Promise<DecodedMessage<ContentTypes>[]>;
    private buildDecodedMessage;
    createMessage(payload: Uint8Array, recipient: PublicKeyBundle, timestamp?: Date): Promise<MessageV1>;
}
/**
 * ConversationV2
 */
declare class ConversationV2<ContentTypes> implements Conversation<ContentTypes> {
    conversationVersion: "v2";
    client: Client<ContentTypes>;
    topic: string;
    peerAddress: string;
    createdAt: Date;
    context?: InvitationContext;
    constructor(client: Client<ContentTypes>, topic: string, peerAddress: string, createdAt: Date, context: InvitationContext | undefined);
    get clientAddress(): string;
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage<ContentTypes>[]>;
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage<ContentTypes>[]>;
    get ephemeralTopic(): string;
    streamEphemeral(onConnectionLost?: OnConnectionLostCallback): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>>;
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages(onConnectionLost?: OnConnectionLostCallback): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>>;
    /**
     * Send a message into the conversation
     */
    send(content: Exclude<ContentTypes, undefined>, options?: SendOptions): Promise<DecodedMessage<ContentTypes>>;
    createMessage(payload: Uint8Array, timestamp?: Date): Promise<MessageV2>;
    private decryptBatch;
    private buildDecryptRequest;
    private encryptMessage;
    private buildDecodedMessage;
    prepareMessage(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<PreparedMessage>;
    processEnvelope(env: messageApi.Envelope): Promise<MessageV2>;
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage<ContentTypes>>;
}

declare class MessageBase {
    headerBytes: Uint8Array;
    ciphertext: Ciphertext;
    contentType?: ContentTypeId;
    error?: Error;
    /**
     * Identifier that is deterministically derived from the bytes of the message
     * header and ciphertext, where all those bytes are authenticated. This can
     * be used in determining uniqueness of messages.
     */
    id: string;
    private bytes;
    constructor(id: string, bytes: Uint8Array, obj: message.Message);
    toBytes(): Uint8Array;
}
declare class MessageV1 extends MessageBase implements message.MessageV1 {
    header: message.MessageHeaderV1;
    senderAddress: string | undefined;
    conversation: undefined;
    constructor(id: string, bytes: Uint8Array, obj: message.Message, header: message.MessageHeaderV1, senderAddress: string | undefined);
    static create(obj: message.Message, header: message.MessageHeaderV1, bytes: Uint8Array): Promise<MessageV1>;
    get sent(): Date;
    get recipientAddress(): string | undefined;
    decrypt(keystore: Keystore, myPublicKeyBundle: PublicKeyBundle): Promise<Uint8Array>;
    static fromBytes(bytes: Uint8Array): Promise<MessageV1>;
    static encode(keystore: Keystore, payload: Uint8Array, sender: PublicKeyBundle, recipient: PublicKeyBundle, timestamp: Date): Promise<MessageV1>;
}
declare class MessageV2 extends MessageBase implements message.MessageV2 {
    senderAddress: string | undefined;
    private header;
    constructor(id: string, bytes: Uint8Array, obj: message.Message, header: message.MessageHeaderV2);
    static create(obj: message.Message, header: message.MessageHeaderV2, bytes: Uint8Array): Promise<MessageV2>;
    get sent(): Date;
}
declare type Message = MessageV1 | MessageV2;
declare class DecodedMessage<ContentTypes = any> {
    id: string;
    messageVersion: 'v1' | 'v2';
    senderAddress: string;
    recipientAddress?: string;
    sent: Date;
    contentTopic: string;
    conversation: Conversation<ContentTypes>;
    contentType: ContentTypeId;
    content: ContentTypes;
    error?: Error;
    contentBytes: Uint8Array;
    contentFallback?: string;
    constructor({ id, messageVersion, senderAddress, recipientAddress, conversation, contentBytes, contentType, contentTopic, content, sent, error, contentFallback, }: Omit<DecodedMessage<ContentTypes>, 'toBytes'>);
    toBytes(): Uint8Array;
    static fromBytes<ContentTypes>(data: Uint8Array, client: Client<ContentTypes>): Promise<DecodedMessage<ContentTypes>>;
    static fromV1Message<ContentTypes>(message: MessageV1, content: ContentTypes, contentType: ContentTypeId, contentBytes: Uint8Array, contentTopic: string, conversation: Conversation<ContentTypes>, error?: Error, contentFallback?: string): DecodedMessage<ContentTypes>;
    static fromV2Message<ContentTypes>(message: MessageV2, content: ContentTypes, contentType: ContentTypeId, contentTopic: string, contentBytes: Uint8Array, conversation: Conversation<ContentTypes>, senderAddress: string, error?: Error, contentFallback?: string): DecodedMessage<ContentTypes>;
}
declare function decodeContent<ContentTypes>(contentBytes: Uint8Array, client: Client<ContentTypes>): Promise<{
    content: ContentTypes;
    contentType: ContentTypeId;
    error?: Error | undefined;
    contentFallback?: string | undefined;
}>;

declare const ContentTypeComposite: ContentTypeId;
declare type Composite = {
    type: ContentTypeId;
    content: any;
} | {
    parts: Composite[];
};
declare class CompositeCodec implements ContentCodec<Composite> {
    get contentType(): ContentTypeId;
    encode(content: Composite, codecs: CodecRegistry): EncodedContent;
    decode(content: EncodedContent, codecs: CodecRegistry): Composite;
    private toProto;
    private fromProto;
    fallback(content: Composite): string | undefined;
}

declare function decodeContactBundle(bytes: Uint8Array): PublicKeyBundle | SignedPublicKeyBundle;

export { ApiClient, ApiUrls, AuthCache, Authenticator, BrowserStoragePersistence, Ciphertext, Client, ClientOptions, CodecRegistry, Composite, CompositeCodec, Compression, ContentCodec, ContentOptions, ContentTypeComposite, ContentTypeFallback, ContentTypeId, ContentTypeText, Conversation, ConversationV1, ConversationV2, Conversations, DecodedMessage, EncodedContent, EncryptedPersistence, ExtractDecodedType, GetMessageContentTypeFromClient, HttpApiClient, InMemoryKeystore, InMemoryPersistence, InvitationContext, KeyGeneratorKeystoreProvider, KeyStoreOptions, Keystore, KeystoreProvider, LegacyOptions, ListMessagesOptions, ListMessagesPaginatedOptions, LocalAuthenticator, Message, MessageV1, MessageV2, NetworkKeystoreProvider, NetworkOptions, OnConnectionLostCallback, Persistence, PrefixedPersistence, PrivateKey, PrivateKeyBundle, PrivateKeyBundleV1, PrivateKeyBundleV2, PublicKey, PublicKeyBundle, PublishParams, Query, QueryAllOptions, QueryParams, QueryStreamOptions, SealedInvitation, SendOptions, Signature, SignedPublicKey, SignedPublicKeyBundle, Signer, SnapKeystoreProvider as SnapProvider, SortDirection, StaticKeystoreProvider, Stream, SubscribeCallback, SubscribeParams, SubscriptionManager, TextCodec, TopicData, UnsubscribeFn, XmtpEnv, buildContentTopic, buildDirectMessageTopic, buildDirectMessageTopicV2, buildUserContactTopic, buildUserIntroTopic, buildUserInviteTopic, buildUserPrivateStoreTopic, dateToNs, decodeContactBundle, decodeContent, decrypt, defaultKeystoreProviders, encrypt, fromNanoString, apiDefs as keystoreApiDefs, mapPaginatedStream, nsToDate, retry, toNanoString };
