{"version":3,"sources":["external-global-plugin:crypto","../../node_modules/js-sha3/src/sha3.js","../../src/utils/topic.ts","../../src/utils/async.ts","../../src/utils/date.ts","../../src/utils/bytes.ts","../../src/utils/browser.ts","../../src/utils/semver.ts","../../src/conversations/Conversation.ts","../../src/Stream.ts","../../src/crypto/PublicKeyBundle.ts","../../src/crypto/PublicKey.ts","../../src/crypto/Signature.ts","../../src/crypto/PrivateKey.ts","../../src/crypto/Ciphertext.ts","../../src/crypto/crypto.ts","../../src/crypto/encryption.ts","../../src/crypto/utils.ts","../../src/crypto/PrivateKeyBundle.ts","../../src/crypto/errors.ts","../../src/crypto/SignedEciesCiphertext.ts","../../src/PreparedMessage.ts","../../src/utils/keystore.ts","../../src/keystore/errors.ts","../../src/MessageContent.ts","../../src/codecs/Text.ts","../../src/Message.ts","../../src/Client.ts","../../src/ApiClient.ts","../../src/authn/AuthCache.ts","../../package.json","../../src/constants.ts","../../src/conversations/Conversations.ts","../../src/conversations/JobRunner.ts","../../src/Compression.ts","../../src/ContactBundle.ts","../../src/authn/LocalAuthenticator.ts","../../src/authn/AuthData.ts","../../src/authn/Token.ts","../../src/authn/KeystoreAuthenticator.ts","../../src/message-backup/NoBackupClient.ts","../../src/message-backup/TopicStoreBackupClient.ts","../../src/message-backup/BackupClientFactory.ts","../../src/keystore/providers/errors.ts","../../src/keystore/InMemoryKeystore.ts","../../src/Invitation.ts","../../src/keystore/encryption.ts","../../src/keystore/utils.ts","../../src/keystore/conversationStores.ts","../../src/crypto/ecies.ts","../../src/keystore/persistence/TopicPersistence.ts","../../src/keystore/persistence/BrowserStoragePersistence.ts","../../src/keystore/persistence/LocalStoragePonyfill.ts","../../src/keystore/persistence/InMemoryPersistence.ts","../../src/keystore/persistence/PrefixedPersistence.ts","../../src/keystore/persistence/EncryptedPersistence.ts","../../src/keystore/providers/helpers.ts","../../src/keystore/providers/NetworkKeyManager.ts","../../src/keystore/providers/KeyGeneratorKeystoreProvider.ts","../../src/keystore/providers/NetworkKeystoreProvider.ts","../../src/keystore/providers/StaticKeystoreProvider.ts","../../src/keystore/snapHelpers.ts","../../src/utils/ethereum.ts","../../src/keystore/rpcDefinitions.ts","../../src/keystore/SnapKeystore.ts","../../src/keystore/providers/SnapProvider.ts","../../src/snapInfo.json","../../src/codecs/Composite.ts"],"names":["require_crypto","__commonJSMin","exports","module","require_sha3","INPUT_ERROR","FINALIZE_ERROR","WINDOW","root","WEB_WORKER","NODE_JS","COMMON_JS","AMD","ARRAY_BUFFER","HEX_CHARS","SHAKE_PADDING","CSHAKE_PADDING","KECCAK_PADDING","PADDING","SHIFT","RC","BITS","SHAKE_BITS","OUTPUT_TYPES","CSHAKE_BYTEPAD","obj","createOutputMethod","bits","padding","outputType","message","Keccak","createShakeOutputMethod","outputBits","createCshakeOutputMethod","n","s","methods","createKmacOutputMethod","key","createOutputMethods","method","createMethod","i","type","createShakeMethod","createCshakeMethod","w","createKmacMethod","Kmac","algorithms","methodNames","algorithm","j","methodName","newMethodName","notString","blocks","byteCount","length","blockCount","index","code","f","x","right","o","bytes","str","strs","paddingBytes","zeros","outputBlocks","extraBytes","hex","block","buffer","array","offset","h","l","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10","b11","b12","b13","b14","b15","b16","b17","b18","b19","b20","b21","b22","b23","b24","b25","b26","b27","b28","b29","b30","b31","b32","b33","b34","b35","b36","b37","b38","b39","b40","b41","b42","b43","b44","b45","b46","b47","b48","b49","utils","buildContentTopic","name","buildDirectMessageTopic","sender","recipient","members","buildDirectMessageTopicV2","randomString","buildUserContactTopic","walletAddr","buildUserIntroTopic","buildUserInviteTopic","buildUserPrivateStoreTopic","addrPrefixedKey","sleep","ms","resolve","defaultIsRetryableFn","err","retry","fn","args","maxRetries","sleepTime","isRetryableFn","retryCount","currRetry","e","mapPaginatedStream","gen","mapper","page","results","out","result","Long","dateToNs","date","nsToDate","ns","toNanoString","d","fromNanoString","fetcher","b64Decode","b64Encode","concat","a","b","ab","numberToUint8Array","num","uint8ArrayToNumber","arr","isBrowser","semverParse","version","major","minor","patch","isSameMajorVersion","semverGreaterThan","aSemver","bSemver","patchGreaterThan","aVersion","aExtra","bVersion","bExtra","aTag","aTagVersion","bTag","bTagVersion","Stream","client","topics","decoder","contentTopicUpdater","onConnectionLost","env","msg","resolver","stream","proto","publicKey","secp","signature","privateKey","ciphertext","KDFSaltSize","AESGCMNonceSize","AESGCMTagLength","Ciphertext","import_crypto","webcrypto","crypto","nodeCrypto","crypto_default","hkdfNoInfo","sha256","encrypt","plain","secret","additionalData","salt","nonce","hkdf","encrypted","aesGcmParams","decrypt","decrypted","spec","bytesToHex","hexToBytes","equalBytes","secp256k1Check","SignedPrivateKey","SignedPublicKey","signer","secp256k1","createdNs","unsigned","UnsignedPublicKey","signed","digest","recovery","Signature","pub","keyBytes","ecdsaSignerKey","peer","other","generatedPublicKey","signedByWallet","PrivateKey","PublicKey","timestamp","ecdsaCheck","sig","ecdsaEqual","WalletSigner","wallet","sigString","eSig","r","sigBytes","secp256k1UncompressedCheck","MS_NS_TIMESTAMP_THRESHOLD","pk","legacyKey","SignedPublicKeyBundle","bundle","PublicKeyBundle","decoded","NoMatchingPreKeyError","preKey","PrivateKeyBundleV2","k","identityKey","which","myPreKey","isRecipient","dh1","dh2","dh3","PrivateKeyBundleV1","decodePrivateKeyBundle","IV_LENGTH","EPHEMERAL_PUBLIC_KEY_LENGTH","MAC_LENGTH","AES_BLOCK_SIZE","assertEciesLengths","ecies","SignedEciesCiphertext","eciesBytes","pubKey","data","PreparedMessage","messageEnvelope","onSend","keystore","KeystoreError","getResultOrThrow","response","buildDecryptV1Request","messages","myPublicKeyBundle","m","isSender","ContentTypeId","contentTypeString","idString","versionString","authorityId","typeId","id","ContentTypeFallback","ContentTypeText","TextCodec","content","encoding","ConversationV1","address","createdAt","opts","topic","decryptResults","options","payload","contentTopic","MessageV1","senderAddress","recipientAddress","contentType","DecodedMessage","throwOnError","responses","error","contentFallback","ConversationV2","peerAddress","context","header","headerBytes","signedBytes","protoMsg","MessageV2","validatePrekeys","senderPreKey","senderIdentityKey","headerBytesAndCiphertext","MessageBase","messageVersion","conversation","contentBytes","sent","protoVal","conversationReferenceToConversation","reference","decodeContent","messageApi","DEFAULT_MAX_AGE_SECONDS","AuthCache","authenticator","cacheExpirySeconds","package_default","XMTP_DEV_WARNING","MessageApi","SortDirection","RETRY_SLEEP_TIME","ERR_CODE_UNAUTHENTICATED","clientVersionHeaderKey","appVersionHeaderKey","ApiUrls","GrpcError","isAbortError","isAuthError","isNotAuthError","normalizeEnvelope","HttpApiClient","pathPrefix","req","attemptNumber","authToken","headers","cb","abortController","startTime","params","direction","limit","envelope","endTime","pageSize","startTimeNs","endTimeNs","cursor","pagingInfo","queries","batchRequests","queriesInBatch","constructedQueries","queryParams","batchQueryRequest","batchQueryResponses","batch","allEnvelopes","batchResponse","queryResponse","toSend","dt","callback","Mutex","JobRunner","jobType","getProtoJobType","lastRun","lastRunNs","protoJobType","CLOCK_SKEW_OFFSET_MS","messageHasHeaders","Conversations","v1Convos","v2Convos","conversations","latestSeen","seenPeers","existing","newConversations","existingTopics","c","convo","envelopes","shouldThrow","convoRef","introTopic","inviteTopic","newPeer","decodeConversation","convoMap","decodeMessage","addConvo","val","convoMessage","have","contact","matchingConvo","matcherFn","isMatchingContext","existingMatch","newItemMatch","contextA","contextB","decompress","encoded","maxSize","sink","readStreamFromBytes","compressionIdFromCode","writeStreamToBytes","compress","chunkSize","position","controller","end","chunk","growBytes","newSize","bigger","decodeContactBundle","pb","encodeContactBundle","import_js_sha3","authn","authnProto","AuthData","res","Token","authDataBytes","authDataSignature","now","LocalAuthenticator","authSig","wrapToken","token","KeystoreAuthenticator","BACKUP_TYPE","NoBackupClient","configuration","TopicStoreBackupClient","walletAddress","createBackupClient","selectBackupProvider","fetchOrCreateConfiguration","backupConfiguration","KeystoreProviderUnavailableError","invitation","InvitationV1","aes256GcmHkdfSha256","keyMaterial","SealedInvitationHeaderV1","SealedInvitationV1","viewer","decryptedBytes","SealedInvitation","v1","sealed","envelopeTime","headerTime","created","invitationBytes","decryptV1","myKeys","peerKeys","encryptV1","keys","decryptV2","encryptV2","convertError","errorCode","wrapResult","mapAndConvertErrors","input","item","toPublicKeyBundle","toSignedPublicKeyBundle","validateObject","objectFields","arrayFields","field","getKeyMaterial","invite","topicDataToV2ConversationReference","isCompleteTopicData","topicDataToMap","topicMap","v","buildPersistenceKey","INVITE_STORAGE_KEY","V1_STORAGE_KEY","V2Store","persistence","persistenceKey","initialData","v2Store","topicData","currentRevision","number","rawData","isDirty","row","V1Store","v1Store","elliptic","EC","ec","subtle","EC_GROUP_ORDER","ZERO32","assert","condition","isScalar","isValidPrivateKey","equalConstTime","randomBytes","size","sha512","getAes","op","iv","importAlgorithm","cryptoKey","encAlgorithm","aesCbcEncrypt","aesCbcDecrypt","hmacSha256Sign","newKey","hmacSha256Verify","expectedSig","getPublic","derive","privateKeyA","publicKeyB","keyA","keyB","Px","publicKeyTo","ephemPrivateKey","ephemeralPublicKey","hash","encryptionKey","macKey","dataToMac","mac","px","ErrorCode","INVITE_SALT","deriveKey","info","InMemoryKeystore","timestampNs","toAdd","myAddress","theirAddress","sortedAddresses","msgString","msgBytes","infoString","derivedKey","prekeyIndex","convos","lastRunTime","TopicPersistence","apiClient","value","BrowserStoragePersistence","storage","LocalStoragePonyfill","InMemoryPersistence","PrefixedPersistence","prefix","EncryptedPersistence","buildPersistenceFromOptions","basePersistence","shouldEncrypt","KEY_BUNDLE_NAME","NetworkKeyManager","preEnableIdentityCallback","storageBuffer","needsUpdate","keyAddress","encodedBundle","wPreKey","storageSigRequestText","eBundle","getEncryptedBundle","needsUpdate2","getPrivateBundle","lastByte","newSecret","KeyGeneratorKeystoreProvider","NetworkKeystoreProvider","StaticKeystoreProvider","privateKeyOverride","keystoreProto","getEthereum","KeystoreStatus","InitKeystoreRequest","InitKeystoreResponse","GetKeystoreStatusRequest","GetKeystoreStatusResponse","snapRPC","codecs","meta","snapId","reqParam","reqBytes","responseString","snapRequest","hasMetamaskWithSnaps","ethereum","provider","getSnaps","getSnap","snaps","snap","connectSnap","getWalletStatusCodec","getWalletStatus","initKeystoreCodec","initSnap","apiDefs","getResponse","SnapKeystore","generatedMethods","snapMeta","apiDef","SNAP_LOCAL_ORIGIN","SnapKeystoreProvider","snapVersion","hasSnap","checkSnapLoaded","bundleFromOptions","createBundle","tmpKeystore","getOrCreateBundle","networkProvider","package","Compression","MaxContentSize","defaultOptions","_defaultOptions","defaultKeystoreProviders","createHttpApiClientFromOptions","Client","publicKeyBundle","backupClient","bootstrapKeystore","codec","legacy","getUserContactFromNetwork","existingBundle","newBundle","peerAddresses","normalizedAddresses","addressToBundle","uncachedAddresses","newBundles","getUserContactsFromNetwork","apiUrl","normalizedPeerAddresses","fallback","encodedContent","keyBundle","userContactTopics","topicToEnvelopes","signingAddress","ContentTypeComposite","CompositeCodec","part","composite","parts"],"mappings":"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","sourcesContent":["module.exports = { webcrypto: window.crypto }","/**\n * [js-sha3]{@link https://github.com/emn178/js-sha3}\n *\n * @version 0.8.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2015-2018\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var INPUT_ERROR = 'input is invalid type';\n  var FINALIZE_ERROR = 'finalize already called';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA3_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\n  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];\n  var KECCAK_PADDING = [1, 256, 65536, 16777216];\n  var PADDING = [6, 1536, 393216, 100663296];\n  var SHIFT = [0, 8, 16, 24];\n  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,\n    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,\n    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,\n    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,\n    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\n  var BITS = [224, 256, 384, 512];\n  var SHAKE_BITS = [128, 256];\n  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];\n  var CSHAKE_BYTEPAD = {\n    '128': 168,\n    '256': 136\n  };\n\n  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (bits, padding, outputType) {\n    return function (message) {\n      return new Keccak(bits, padding, bits).update(message)[outputType]();\n    };\n  };\n\n  var createShakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits) {\n      return new Keccak(bits, padding, outputBits).update(message)[outputType]();\n    };\n  };\n\n  var createCshakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits, n, s) {\n      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();\n    };\n  };\n\n  var createKmacOutputMethod = function (bits, padding, outputType) {\n    return function (key, message, outputBits, s) {\n      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();\n    };\n  };\n\n  var createOutputMethods = function (method, createMethod, bits, padding) {\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createMethod(bits, padding, type);\n    }\n    return method;\n  };\n\n  var createMethod = function (bits, padding) {\n    var method = createOutputMethod(bits, padding, 'hex');\n    method.create = function () {\n      return new Keccak(bits, padding, bits);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    return createOutputMethods(method, createOutputMethod, bits, padding);\n  };\n\n  var createShakeMethod = function (bits, padding) {\n    var method = createShakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits) {\n      return new Keccak(bits, padding, outputBits);\n    };\n    method.update = function (message, outputBits) {\n      return method.create(outputBits).update(message);\n    };\n    return createOutputMethods(method, createShakeOutputMethod, bits, padding);\n  };\n\n  var createCshakeMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createCshakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits, n, s) {\n      if (!n && !s) {\n        return methods['shake' + bits].create(outputBits);\n      } else {\n        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);\n      }\n    };\n    method.update = function (message, outputBits, n, s) {\n      return method.create(outputBits, n, s).update(message);\n    };\n    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);\n  };\n\n  var createKmacMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createKmacOutputMethod(bits, padding, 'hex');\n    method.create = function (key, outputBits, s) {\n      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);\n    };\n    method.update = function (key, message, outputBits, s) {\n      return method.create(key, outputBits, s).update(message);\n    };\n    return createOutputMethods(method, createKmacOutputMethod, bits, padding);\n  };\n\n  var algorithms = [\n    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },\n    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },\n    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }\n  ];\n\n  var methods = {}, methodNames = [];\n\n  for (var i = 0; i < algorithms.length; ++i) {\n    var algorithm = algorithms[i];\n    var bits = algorithm.bits;\n    for (var j = 0; j < bits.length; ++j) {\n      var methodName = algorithm.name + '_' + bits[j];\n      methodNames.push(methodName);\n      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\n      if (algorithm.name !== 'sha3') {\n        var newMethodName = algorithm.name + bits[j];\n        methodNames.push(newMethodName);\n        methods[newMethodName] = methods[methodName];\n      }\n    }\n  }\n\n  function Keccak(bits, padding, outputBits) {\n    this.blocks = [];\n    this.s = [];\n    this.padding = padding;\n    this.outputBits = outputBits;\n    this.reset = true;\n    this.finalized = false;\n    this.block = 0;\n    this.start = 0;\n    this.blockCount = (1600 - (bits << 1)) >> 5;\n    this.byteCount = this.blockCount << 2;\n    this.outputBlocks = outputBits >> 5;\n    this.extraBytes = (outputBits & 31) >> 3;\n\n    for (var i = 0; i < 50; ++i) {\n      this.s[i] = 0;\n    }\n  }\n\n  Keccak.prototype.update = function (message) {\n    if (this.finalized) {\n      throw new Error(FINALIZE_ERROR);\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,\n      blockCount = this.blockCount, index = 0, s = this.s, i, code;\n\n    while (index < length) {\n      if (this.reset) {\n        this.reset = false;\n        blocks[0] = this.block;\n        for (i = 1; i < blockCount + 1; ++i) {\n          blocks[i] = 0;\n        }\n      }\n      if (notString) {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n      this.lastByteIndex = i;\n      if (i >= byteCount) {\n        this.start = i - byteCount;\n        this.block = blocks[blockCount];\n        for (i = 0; i < blockCount; ++i) {\n          s[i] ^= blocks[i];\n        }\n        f(s);\n        this.reset = true;\n      } else {\n        this.start = i;\n      }\n    }\n    return this;\n  };\n\n  Keccak.prototype.encode = function (x, right) {\n    var o = x & 255, n = 1;\n    var bytes = [o];\n    x = x >> 8;\n    o = x & 255;\n    while (o > 0) {\n      bytes.unshift(o);\n      x = x >> 8;\n      o = x & 255;\n      ++n;\n    }\n    if (right) {\n      bytes.push(n);\n    } else {\n      bytes.unshift(n);\n    }\n    this.update(bytes);\n    return bytes.length;\n  };\n\n  Keccak.prototype.encodeString = function (str) {\n    var notString, type = typeof str;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (str === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {\n          str = new Uint8Array(str);\n        } else if (!Array.isArray(str)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var bytes = 0, length = str.length;\n    if (notString) {\n      bytes = length;\n    } else {\n      for (var i = 0; i < str.length; ++i) {\n        var code = str.charCodeAt(i);\n        if (code < 0x80) {\n          bytes += 1;\n        } else if (code < 0x800) {\n          bytes += 2;\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes += 3;\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));\n          bytes += 4;\n        }\n      }\n    }\n    bytes += this.encode(bytes * 8);\n    this.update(str);\n    return bytes;\n  };\n\n  Keccak.prototype.bytepad = function (strs, w) {\n    var bytes = this.encode(w);\n    for (var i = 0; i < strs.length; ++i) {\n      bytes += this.encodeString(strs[i]);\n    }\n    var paddingBytes = w - bytes % w;\n    var zeros = [];\n    zeros.length = paddingBytes;\n    this.update(zeros);\n    return this;\n  };\n\n  Keccak.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;\n    blocks[i >> 2] |= this.padding[i & 3];\n    if (this.lastByteIndex === this.byteCount) {\n      blocks[0] = blocks[blockCount];\n      for (i = 1; i < blockCount + 1; ++i) {\n        blocks[i] = 0;\n      }\n    }\n    blocks[blockCount - 1] |= 0x80000000;\n    for (i = 0; i < blockCount; ++i) {\n      s[i] ^= blocks[i];\n    }\n    f(s);\n  };\n\n  Keccak.prototype.toString = Keccak.prototype.hex = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var hex = '', block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        block = s[i];\n        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +\n          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +\n          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +\n          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n        i = 0;\n      }\n    }\n    if (extraBytes) {\n      block = s[i];\n      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];\n      if (extraBytes > 1) {\n        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];\n      }\n      if (extraBytes > 2) {\n        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];\n      }\n    }\n    return hex;\n  };\n\n  Keccak.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var bytes = this.outputBits >> 3;\n    var buffer;\n    if (extraBytes) {\n      buffer = new ArrayBuffer((outputBlocks + 1) << 2);\n    } else {\n      buffer = new ArrayBuffer(bytes);\n    }\n    var array = new Uint32Array(buffer);\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        array[j] = s[i];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      array[i] = s[i];\n      buffer = buffer.slice(0, bytes);\n    }\n    return buffer;\n  };\n\n  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\n\n  Keccak.prototype.digest = Keccak.prototype.array = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var array = [], offset, block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        offset = j << 2;\n        block = s[i];\n        array[offset] = block & 0xFF;\n        array[offset + 1] = (block >> 8) & 0xFF;\n        array[offset + 2] = (block >> 16) & 0xFF;\n        array[offset + 3] = (block >> 24) & 0xFF;\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      offset = j << 2;\n      block = s[i];\n      array[offset] = block & 0xFF;\n      if (extraBytes > 1) {\n        array[offset + 1] = (block >> 8) & 0xFF;\n      }\n      if (extraBytes > 2) {\n        array[offset + 2] = (block >> 16) & 0xFF;\n      }\n    }\n    return array;\n  };\n\n  function Kmac(bits, padding, outputBits) {\n    Keccak.call(this, bits, padding, outputBits);\n  }\n\n  Kmac.prototype = new Keccak();\n\n  Kmac.prototype.finalize = function () {\n    this.encode(this.outputBits, true);\n    return Keccak.prototype.finalize.call(this);\n  };\n\n  var f = function (s) {\n    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,\n      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,\n      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,\n      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n    for (n = 0; n < 48; n += 2) {\n      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n\n      h = c8 ^ ((c2 << 1) | (c3 >>> 31));\n      l = c9 ^ ((c3 << 1) | (c2 >>> 31));\n      s[0] ^= h;\n      s[1] ^= l;\n      s[10] ^= h;\n      s[11] ^= l;\n      s[20] ^= h;\n      s[21] ^= l;\n      s[30] ^= h;\n      s[31] ^= l;\n      s[40] ^= h;\n      s[41] ^= l;\n      h = c0 ^ ((c4 << 1) | (c5 >>> 31));\n      l = c1 ^ ((c5 << 1) | (c4 >>> 31));\n      s[2] ^= h;\n      s[3] ^= l;\n      s[12] ^= h;\n      s[13] ^= l;\n      s[22] ^= h;\n      s[23] ^= l;\n      s[32] ^= h;\n      s[33] ^= l;\n      s[42] ^= h;\n      s[43] ^= l;\n      h = c2 ^ ((c6 << 1) | (c7 >>> 31));\n      l = c3 ^ ((c7 << 1) | (c6 >>> 31));\n      s[4] ^= h;\n      s[5] ^= l;\n      s[14] ^= h;\n      s[15] ^= l;\n      s[24] ^= h;\n      s[25] ^= l;\n      s[34] ^= h;\n      s[35] ^= l;\n      s[44] ^= h;\n      s[45] ^= l;\n      h = c4 ^ ((c8 << 1) | (c9 >>> 31));\n      l = c5 ^ ((c9 << 1) | (c8 >>> 31));\n      s[6] ^= h;\n      s[7] ^= l;\n      s[16] ^= h;\n      s[17] ^= l;\n      s[26] ^= h;\n      s[27] ^= l;\n      s[36] ^= h;\n      s[37] ^= l;\n      s[46] ^= h;\n      s[47] ^= l;\n      h = c6 ^ ((c0 << 1) | (c1 >>> 31));\n      l = c7 ^ ((c1 << 1) | (c0 >>> 31));\n      s[8] ^= h;\n      s[9] ^= l;\n      s[18] ^= h;\n      s[19] ^= l;\n      s[28] ^= h;\n      s[29] ^= l;\n      s[38] ^= h;\n      s[39] ^= l;\n      s[48] ^= h;\n      s[49] ^= l;\n\n      b0 = s[0];\n      b1 = s[1];\n      b32 = (s[11] << 4) | (s[10] >>> 28);\n      b33 = (s[10] << 4) | (s[11] >>> 28);\n      b14 = (s[20] << 3) | (s[21] >>> 29);\n      b15 = (s[21] << 3) | (s[20] >>> 29);\n      b46 = (s[31] << 9) | (s[30] >>> 23);\n      b47 = (s[30] << 9) | (s[31] >>> 23);\n      b28 = (s[40] << 18) | (s[41] >>> 14);\n      b29 = (s[41] << 18) | (s[40] >>> 14);\n      b20 = (s[2] << 1) | (s[3] >>> 31);\n      b21 = (s[3] << 1) | (s[2] >>> 31);\n      b2 = (s[13] << 12) | (s[12] >>> 20);\n      b3 = (s[12] << 12) | (s[13] >>> 20);\n      b34 = (s[22] << 10) | (s[23] >>> 22);\n      b35 = (s[23] << 10) | (s[22] >>> 22);\n      b16 = (s[33] << 13) | (s[32] >>> 19);\n      b17 = (s[32] << 13) | (s[33] >>> 19);\n      b48 = (s[42] << 2) | (s[43] >>> 30);\n      b49 = (s[43] << 2) | (s[42] >>> 30);\n      b40 = (s[5] << 30) | (s[4] >>> 2);\n      b41 = (s[4] << 30) | (s[5] >>> 2);\n      b22 = (s[14] << 6) | (s[15] >>> 26);\n      b23 = (s[15] << 6) | (s[14] >>> 26);\n      b4 = (s[25] << 11) | (s[24] >>> 21);\n      b5 = (s[24] << 11) | (s[25] >>> 21);\n      b36 = (s[34] << 15) | (s[35] >>> 17);\n      b37 = (s[35] << 15) | (s[34] >>> 17);\n      b18 = (s[45] << 29) | (s[44] >>> 3);\n      b19 = (s[44] << 29) | (s[45] >>> 3);\n      b10 = (s[6] << 28) | (s[7] >>> 4);\n      b11 = (s[7] << 28) | (s[6] >>> 4);\n      b42 = (s[17] << 23) | (s[16] >>> 9);\n      b43 = (s[16] << 23) | (s[17] >>> 9);\n      b24 = (s[26] << 25) | (s[27] >>> 7);\n      b25 = (s[27] << 25) | (s[26] >>> 7);\n      b6 = (s[36] << 21) | (s[37] >>> 11);\n      b7 = (s[37] << 21) | (s[36] >>> 11);\n      b38 = (s[47] << 24) | (s[46] >>> 8);\n      b39 = (s[46] << 24) | (s[47] >>> 8);\n      b30 = (s[8] << 27) | (s[9] >>> 5);\n      b31 = (s[9] << 27) | (s[8] >>> 5);\n      b12 = (s[18] << 20) | (s[19] >>> 12);\n      b13 = (s[19] << 20) | (s[18] >>> 12);\n      b44 = (s[29] << 7) | (s[28] >>> 25);\n      b45 = (s[28] << 7) | (s[29] >>> 25);\n      b26 = (s[38] << 8) | (s[39] >>> 24);\n      b27 = (s[39] << 8) | (s[38] >>> 24);\n      b8 = (s[48] << 14) | (s[49] >>> 18);\n      b9 = (s[49] << 14) | (s[48] >>> 18);\n\n      s[0] = b0 ^ (~b2 & b4);\n      s[1] = b1 ^ (~b3 & b5);\n      s[10] = b10 ^ (~b12 & b14);\n      s[11] = b11 ^ (~b13 & b15);\n      s[20] = b20 ^ (~b22 & b24);\n      s[21] = b21 ^ (~b23 & b25);\n      s[30] = b30 ^ (~b32 & b34);\n      s[31] = b31 ^ (~b33 & b35);\n      s[40] = b40 ^ (~b42 & b44);\n      s[41] = b41 ^ (~b43 & b45);\n      s[2] = b2 ^ (~b4 & b6);\n      s[3] = b3 ^ (~b5 & b7);\n      s[12] = b12 ^ (~b14 & b16);\n      s[13] = b13 ^ (~b15 & b17);\n      s[22] = b22 ^ (~b24 & b26);\n      s[23] = b23 ^ (~b25 & b27);\n      s[32] = b32 ^ (~b34 & b36);\n      s[33] = b33 ^ (~b35 & b37);\n      s[42] = b42 ^ (~b44 & b46);\n      s[43] = b43 ^ (~b45 & b47);\n      s[4] = b4 ^ (~b6 & b8);\n      s[5] = b5 ^ (~b7 & b9);\n      s[14] = b14 ^ (~b16 & b18);\n      s[15] = b15 ^ (~b17 & b19);\n      s[24] = b24 ^ (~b26 & b28);\n      s[25] = b25 ^ (~b27 & b29);\n      s[34] = b34 ^ (~b36 & b38);\n      s[35] = b35 ^ (~b37 & b39);\n      s[44] = b44 ^ (~b46 & b48);\n      s[45] = b45 ^ (~b47 & b49);\n      s[6] = b6 ^ (~b8 & b0);\n      s[7] = b7 ^ (~b9 & b1);\n      s[16] = b16 ^ (~b18 & b10);\n      s[17] = b17 ^ (~b19 & b11);\n      s[26] = b26 ^ (~b28 & b20);\n      s[27] = b27 ^ (~b29 & b21);\n      s[36] = b36 ^ (~b38 & b30);\n      s[37] = b37 ^ (~b39 & b31);\n      s[46] = b46 ^ (~b48 & b40);\n      s[47] = b47 ^ (~b49 & b41);\n      s[8] = b8 ^ (~b0 & b2);\n      s[9] = b9 ^ (~b1 & b3);\n      s[18] = b18 ^ (~b10 & b12);\n      s[19] = b19 ^ (~b11 & b13);\n      s[28] = b28 ^ (~b20 & b22);\n      s[29] = b29 ^ (~b21 & b23);\n      s[38] = b38 ^ (~b30 & b32);\n      s[39] = b39 ^ (~b31 & b33);\n      s[48] = b48 ^ (~b40 & b42);\n      s[49] = b49 ^ (~b41 & b43);\n\n      s[0] ^= RC[n];\n      s[1] ^= RC[n + 1];\n    }\n  };\n\n  if (COMMON_JS) {\n    module.exports = methods;\n  } else {\n    for (i = 0; i < methodNames.length; ++i) {\n      root[methodNames[i]] = methods[methodNames[i]];\n    }\n    if (AMD) {\n      define(function () {\n        return methods;\n      });\n    }\n  }\n})();\n","import { utils } from 'ethers'\n\nexport const buildContentTopic = (name: string): string =>\n  `/xmtp/0/${name}/proto`\n\nexport const buildDirectMessageTopic = (\n  sender: string,\n  recipient: string\n): string => {\n  // EIP55 normalize the address case.\n  const members = [utils.getAddress(sender), utils.getAddress(recipient)]\n  members.sort()\n  return buildContentTopic(`dm-${members.join('-')}`)\n}\n\nexport const buildDirectMessageTopicV2 = (randomString: string): string => {\n  return buildContentTopic(`m-${randomString}`)\n}\n\nexport const buildUserContactTopic = (walletAddr: string): string => {\n  // EIP55 normalize the address case.\n  return buildContentTopic(`contact-${utils.getAddress(walletAddr)}`)\n}\n\nexport const buildUserIntroTopic = (walletAddr: string): string => {\n  // EIP55 normalize the address case.\n  return buildContentTopic(`intro-${utils.getAddress(walletAddr)}`)\n}\n\nexport const buildUserInviteTopic = (walletAddr: string): string => {\n  // EIP55 normalize the address case.\n  return buildContentTopic(`invite-${utils.getAddress(walletAddr)}`)\n}\nexport const buildUserPrivateStoreTopic = (addrPrefixedKey: string): string => {\n  // e.g. \"0x1111111111222222222233333333334444444444/key_bundle\"\n  return buildContentTopic(`privatestore-${addrPrefixedKey}`)\n}\n","import { messageApi } from '@xmtp/proto'\n\nexport type IsRetryable = (err?: Error) => boolean\n\nexport const sleep = (ms: number): Promise<void> =>\n  new Promise((resolve) => setTimeout(resolve, ms))\n\nexport const promiseWithTimeout = <T>(\n  timeoutMs: number,\n  promise: () => Promise<T>,\n  failureMessage?: string\n): Promise<T> => {\n  let timeoutHandle: NodeJS.Timeout\n  const timeoutPromise = new Promise<never>((_resolve, reject) => {\n    timeoutHandle = setTimeout(\n      () => reject(new Error(failureMessage)),\n      timeoutMs\n    )\n  })\n\n  return Promise.race([promise(), timeoutPromise]).then((result) => {\n    clearTimeout(timeoutHandle)\n    return result\n  })\n}\n\nconst defaultIsRetryableFn = (err?: Error) => !!err\n\n// Implements type safe retries of arbitrary async functions\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function retry<T extends (...arg0: any[]) => any>(\n  fn: T,\n  args: Parameters<T>,\n  maxRetries: number,\n  sleepTime: number,\n  isRetryableFn: IsRetryable = defaultIsRetryableFn,\n  retryCount = 1\n): Promise<Awaited<ReturnType<T>>> {\n  const currRetry = typeof retryCount === 'number' ? retryCount : 1\n  try {\n    const result = await fn(...args)\n    return result\n  } catch (e) {\n    if (!isRetryableFn(e as Error) || currRetry > maxRetries) {\n      throw e\n    }\n    await sleep(sleepTime)\n    return retry(fn, args, maxRetries, sleepTime, isRetryableFn, currRetry + 1)\n  }\n}\n\nexport type EnvelopeMapper<Out> = (env: messageApi.Envelope) => Promise<Out>\n\n// Takes an async generator returning pages of envelopes and converts to an async\n// generator returning pages of an arbitrary type using a mapper function\nexport async function* mapPaginatedStream<Out>(\n  gen: AsyncGenerator<messageApi.Envelope[]>,\n  mapper: EnvelopeMapper<Out>\n): AsyncGenerator<Out[]> {\n  for await (const page of gen) {\n    const results = await Promise.allSettled(page.map(mapper))\n    const out: Out[] = []\n    for (const result of results) {\n      if (result.status === 'fulfilled') {\n        out.push(result.value)\n      } else {\n        console.warn(\n          'Failed to process envelope due to reason: ',\n          result.reason\n        )\n      }\n    }\n\n    yield out\n  }\n}\n","import Long from 'long'\n\nexport function dateToNs(date: Date): Long {\n  return Long.fromNumber(date.valueOf()).multiply(1_000_000)\n}\n\nexport function nsToDate(ns: Long): Date {\n  return new Date(ns.divide(1_000_000).toNumber())\n}\n\nexport const toNanoString = (d: Date | undefined): undefined | string => {\n  return d && dateToNs(d).toString()\n}\n\nexport const fromNanoString = (s: string | undefined): undefined | Date => {\n  if (!s) {\n    return undefined\n  }\n  return nsToDate(Long.fromString(s))\n}\n","import { fetcher } from '@xmtp/proto'\n\nexport const { b64Decode, b64Encode } = fetcher\n\nexport function concat(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const ab = new Uint8Array(a.length + b.length)\n  ab.set(a)\n  ab.set(b, a.length)\n  return ab\n}\n\nexport function numberToUint8Array(num: number) {\n  // Create a buffer for a 32-bit integer\n  const buffer = new ArrayBuffer(4)\n  const view = new DataView(buffer)\n\n  // Set the number in the buffer\n  view.setInt32(0, num, true) // true for little-endian\n\n  // Create Uint8Array from buffer\n  return new Uint8Array(buffer)\n}\n\nexport function uint8ArrayToNumber(arr: Uint8Array) {\n  const buffer = arr.buffer\n  const view = new DataView(buffer)\n\n  // Read the number from the buffer\n  return view.getInt32(0, true) // true for little-endian\n}\n","export const isBrowser = () =>\n  typeof window !== 'undefined' && typeof window.document !== 'undefined'\n","export function semverParse(version: string) {\n  const [major, minor, ...patch] = version.split('.')\n\n  return {\n    major: Number(major),\n    minor: Number(minor),\n    // Keep patch as a string so that it can support prerelease versions\n    patch: patch.join('.'),\n  }\n}\n\nexport function isSameMajorVersion(a?: string, b?: string): boolean {\n  // If no version is provided, assume it is the same\n  if (!a || !b) {\n    return true\n  }\n  return semverParse(a).major === semverParse(b).major\n}\n\n// Checks if A semver is greater than B semver\nexport function semverGreaterThan(a?: string, b?: string): boolean {\n  if (!a || !b) {\n    return false\n  }\n  const aSemver = semverParse(a)\n  const bSemver = semverParse(b)\n  if (aSemver.major !== bSemver.major) {\n    return aSemver.major > bSemver.major\n  }\n  if (aSemver.minor !== bSemver.minor) {\n    return aSemver.minor > bSemver.minor\n  }\n\n  if (!aSemver.patch || !bSemver.patch) {\n    return false\n  }\n\n  return patchGreaterThan(aSemver.patch, bSemver.patch)\n}\n\n// Home-brewed attempt at comparing patch versions so we don't have to import semver package.\n// Example full version might be \"2.0.1-alpha.1\", and this will be operating on the \"1-alpha.1\" portion\nfunction patchGreaterThan(a: string, b: string): boolean {\n  const [aVersion, aExtra] = a.split('-')\n  const [bVersion, bExtra] = b.split('-')\n\n  if (Number(aVersion) !== Number(bVersion)) {\n    return Number(aVersion) > Number(bVersion)\n  }\n\n  if (!aExtra || !bExtra) {\n    return false\n  }\n\n  const [aTag, aTagVersion] = aExtra.split('.')\n  const [bTag, bTagVersion] = bExtra.split('.')\n  if (aTag !== bTag) {\n    return true\n  }\n\n  return Number(aTagVersion) > Number(bTagVersion)\n}\n","import { OnConnectionLostCallback } from './../ApiClient'\nimport {\n  buildUserIntroTopic,\n  buildDirectMessageTopic,\n  dateToNs,\n  concat,\n  toNanoString,\n} from '../utils'\nimport { utils } from 'ethers'\nimport Stream from '../Stream'\nimport Client, {\n  ListMessagesOptions,\n  ListMessagesPaginatedOptions,\n  SendOptions,\n} from '../Client'\nimport { InvitationContext } from '../Invitation'\nimport { DecodedMessage, MessageV1, MessageV2 } from '../Message'\nimport {\n  messageApi,\n  message,\n  content as proto,\n  keystore,\n  ciphertext,\n} from '@xmtp/proto'\nimport {\n  SignedPublicKey,\n  Signature,\n  PublicKeyBundle,\n  SignedPublicKeyBundle,\n} from '../crypto'\nimport { PreparedMessage } from '../PreparedMessage'\nimport { sha256 } from '../crypto/encryption'\nimport { buildDecryptV1Request, getResultOrThrow } from '../utils/keystore'\nimport { ContentTypeText } from '../codecs/Text'\n\n/**\n * Conversation represents either a V1 or V2 conversation with a common set of methods.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface Conversation<ContentTypes = any> {\n  conversationVersion: 'v1' | 'v2'\n  /**\n   * The wallet address connected to the client\n   */\n  clientAddress: string\n  /**\n   * A unique identifier for a conversation. Each conversation is stored on the network on one topic\n   */\n  topic: string\n  /**\n   * A unique identifier for ephemeral envelopes for a conversation.\n   */\n  ephemeralTopic: string\n  /**\n   * The wallet address of the other party in the conversation\n   */\n  peerAddress: string\n  /**\n   * Timestamp the conversation was created at\n   */\n  createdAt: Date\n\n  /**\n   * Optional field containing the `conversationId` and `metadata` for V2 conversations.\n   * Will always be undefined on V1 conversations\n   */\n  context?: InvitationContext | undefined\n\n  /**\n   * Retrieve messages in this conversation. Default to returning all messages.\n   *\n   * If only a subset is required, results can be narrowed by specifying a start/end\n   * timestamp.\n   *\n   * ```ts\n   * // Get all messages in the past 24 hours\n   * const messages = await conversation.messages({\n   *    startTime: new Date(+new Date() - 86_400)\n   * })\n   * ```\n   */\n  messages(opts?: ListMessagesOptions): Promise<DecodedMessage<ContentTypes>[]>\n  /**\n   * @deprecated\n   */\n  messagesPaginated(\n    opts?: ListMessagesPaginatedOptions\n  ): AsyncGenerator<DecodedMessage<ContentTypes>[]>\n  /**\n   * Takes a XMTP envelope as input and will decrypt and decode it\n   * returning a `DecodedMessage` instance.\n   */\n  decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage<ContentTypes>>\n  /**\n   * Return a `Stream` of new messages in this conversation.\n   *\n   * Stream instances are async generators and can be used in\n   * `for await` statements.\n   *\n   * ```ts\n   * for await (const message of await conversation.stream()) {\n   *    console.log(message.content)\n   * }\n   * ```\n   */\n  streamMessages(): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>>\n  /**\n   * Send a message into the conversation\n   *\n   * ## Example\n   * ```ts\n   * await conversation.send('Hello world') // returns a `DecodedMessage` instance\n   * ```\n   */\n  send(\n    content: Exclude<ContentTypes, undefined>,\n    options?: SendOptions\n  ): Promise<DecodedMessage<ContentTypes>>\n\n  /**\n   * Return a `PreparedMessage` that has contains the message ID\n   * of the message that will be sent.\n   */\n  prepareMessage(\n    content: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    options?: SendOptions\n  ): Promise<PreparedMessage>\n\n  /**\n   * Return a `Stream` of new ephemeral messages from this conversation's\n   * ephemeral topic.\n   *\n   * Stream instances are async generators and can be used in\n   * `for await` statements.\n   *\n   * ```ts\n   * for await (const message of await conversation.streamEphemeral()) {\n   *    console.log(message.content)\n   * }\n   * ```\n   */\n  streamEphemeral(): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>>\n}\n\n/**\n * ConversationV1 allows you to view, stream, and send messages to/from a peer address\n */\nexport class ConversationV1<ContentTypes>\n  implements Conversation<ContentTypes>\n{\n  conversationVersion = 'v1' as const\n  peerAddress: string\n  createdAt: Date\n  context = undefined\n  private client: Client<ContentTypes>\n\n  constructor(client: Client<ContentTypes>, address: string, createdAt: Date) {\n    this.peerAddress = utils.getAddress(address)\n    this.client = client\n    this.createdAt = createdAt\n  }\n\n  get clientAddress() {\n    return this.client.address\n  }\n\n  get topic(): string {\n    return buildDirectMessageTopic(this.peerAddress, this.client.address)\n  }\n\n  get ephemeralTopic(): string {\n    return buildDirectMessageTopic(\n      this.peerAddress,\n      this.client.address\n    ).replace('/xmtp/0/dm-', '/xmtp/0/dmE-')\n  }\n\n  /**\n   * Returns a list of all messages to/from the peerAddress\n   */\n  async messages(\n    opts?: ListMessagesOptions\n  ): Promise<DecodedMessage<ContentTypes>[]> {\n    const topic = buildDirectMessageTopic(this.peerAddress, this.client.address)\n    const messages = await this.client.listEnvelopes(\n      topic,\n      this.processEnvelope.bind(this),\n      opts\n    )\n\n    return this.decryptBatch(messages, topic, false)\n  }\n\n  messagesPaginated(\n    opts?: ListMessagesPaginatedOptions\n  ): AsyncGenerator<DecodedMessage<ContentTypes>[]> {\n    return this.client.listEnvelopesPaginated(\n      this.topic,\n      // This won't be performant once we start supporting a remote keystore\n      // TODO: Either better batch support or we ditch this under-utilized feature\n      this.decodeMessage.bind(this),\n      opts\n    )\n  }\n\n  // decodeMessage takes an envelope and either returns a `DecodedMessage` or throws if an error occurs\n  async decodeMessage(\n    env: messageApi.Envelope\n  ): Promise<DecodedMessage<ContentTypes>> {\n    if (!env.contentTopic) {\n      throw new Error('Missing content topic')\n    }\n    const msg = await this.processEnvelope(env)\n    const decryptResults = await this.decryptBatch(\n      [msg],\n      env.contentTopic,\n      true\n    )\n    if (!decryptResults.length) {\n      throw new Error('No results')\n    }\n    return decryptResults[0]\n  }\n\n  async prepareMessage(\n    content: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    options?: SendOptions\n  ): Promise<PreparedMessage> {\n    let topics: string[]\n    let recipient = await this.client.getUserContact(this.peerAddress)\n    if (!recipient) {\n      throw new Error(`recipient ${this.peerAddress} is not registered`)\n    }\n    if (!(recipient instanceof PublicKeyBundle)) {\n      recipient = recipient.toLegacyBundle()\n    }\n\n    if (!this.client.contacts.has(this.peerAddress)) {\n      topics = [\n        buildUserIntroTopic(this.peerAddress),\n        buildUserIntroTopic(this.client.address),\n        this.topic,\n      ]\n      this.client.contacts.add(this.peerAddress)\n    } else {\n      topics = [this.topic]\n    }\n    const payload = await this.client.encodeContent(content, options)\n    const msg = await this.createMessage(payload, recipient, options?.timestamp)\n\n    const env: messageApi.Envelope = {\n      contentTopic: this.topic,\n      message: msg.toBytes(),\n      timestampNs: toNanoString(msg.sent),\n    }\n\n    return new PreparedMessage(env, async () => {\n      await this.client.publishEnvelopes(\n        topics.map((topic) => ({\n          contentTopic: topic,\n          message: msg.toBytes(),\n          timestamp: msg.sent,\n        }))\n      )\n    })\n  }\n\n  /**\n   * Returns a Stream of any new messages to/from the peerAddress\n   */\n  streamMessages(\n    onConnectionLost?: OnConnectionLostCallback\n  ): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>> {\n    return Stream.create<DecodedMessage<ContentTypes>, ContentTypes>(\n      this.client,\n      [this.topic],\n      async (env: messageApi.Envelope) => this.decodeMessage(env),\n      undefined,\n      onConnectionLost\n    )\n  }\n\n  async processEnvelope({\n    message,\n    contentTopic,\n  }: messageApi.Envelope): Promise<MessageV1> {\n    if (!message || !message.length) {\n      throw new Error('empty envelope')\n    }\n    const decoded = await MessageV1.fromBytes(message)\n    const { senderAddress, recipientAddress } = decoded\n\n    // Filter for topics\n    if (\n      !senderAddress ||\n      !recipientAddress ||\n      !contentTopic ||\n      buildDirectMessageTopic(senderAddress, recipientAddress) !== this.topic\n    ) {\n      throw new Error('Headers do not match intended recipient')\n    }\n\n    return decoded\n  }\n\n  streamEphemeral(\n    onConnectionLost?: OnConnectionLostCallback\n  ): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>> {\n    return Stream.create<DecodedMessage<ContentTypes>, ContentTypes>(\n      this.client,\n      [this.ephemeralTopic],\n      this.decodeMessage.bind(this),\n      undefined,\n      onConnectionLost\n    )\n  }\n\n  /**\n   * Send a message into the conversation.\n   */\n  async send(\n    content: Exclude<ContentTypes, undefined>,\n    options?: SendOptions\n  ): Promise<DecodedMessage<ContentTypes>> {\n    let topics: string[]\n    let recipient = await this.client.getUserContact(this.peerAddress)\n    if (!recipient) {\n      throw new Error(`recipient ${this.peerAddress} is not registered`)\n    }\n    if (!(recipient instanceof PublicKeyBundle)) {\n      recipient = recipient.toLegacyBundle()\n    }\n\n    const topic = options?.ephemeral ? this.ephemeralTopic : this.topic\n\n    if (!this.client.contacts.has(this.peerAddress)) {\n      topics = [\n        buildUserIntroTopic(this.peerAddress),\n        buildUserIntroTopic(this.client.address),\n        topic,\n      ]\n      this.client.contacts.add(this.peerAddress)\n    } else {\n      topics = [this.topic]\n    }\n    const contentType = options?.contentType || ContentTypeText\n    const payload = await this.client.encodeContent(content, options)\n    const msg = await this.createMessage(payload, recipient, options?.timestamp)\n\n    await this.client.publishEnvelopes(\n      topics.map((topic) => ({\n        contentTopic: topic,\n        message: msg.toBytes(),\n        timestamp: msg.sent,\n      }))\n    )\n\n    return DecodedMessage.fromV1Message(\n      msg,\n      content,\n      contentType,\n      payload,\n      topics[0], // Just use the first topic for the returned value\n      this\n    )\n  }\n\n  async decryptBatch(\n    messages: MessageV1[],\n    topic: string,\n    throwOnError = false\n  ): Promise<DecodedMessage<ContentTypes>[]> {\n    const responses = (\n      await this.client.keystore.decryptV1(\n        buildDecryptV1Request(messages, this.client.publicKeyBundle)\n      )\n    ).responses\n\n    const out: DecodedMessage<ContentTypes>[] = []\n    for (let i = 0; i < responses.length; i++) {\n      const result = responses[i]\n      const message = messages[i]\n      try {\n        const { decrypted } = getResultOrThrow(result)\n        out.push(await this.buildDecodedMessage(message, decrypted, topic))\n      } catch (e) {\n        if (throwOnError) {\n          throw e\n        }\n        console.warn('Error decoding content', e)\n      }\n    }\n\n    return out\n  }\n\n  private async buildDecodedMessage(\n    message: MessageV1,\n    decrypted: Uint8Array,\n    topic: string\n  ): Promise<DecodedMessage<ContentTypes>> {\n    const { content, contentType, error, contentFallback } =\n      await this.client.decodeContent(decrypted)\n\n    return DecodedMessage.fromV1Message(\n      message,\n      content,\n      contentType,\n      decrypted,\n      topic,\n      this,\n      error,\n      contentFallback\n    )\n  }\n\n  async createMessage(\n    // Payload is expected to be the output of `client.encodeContent`\n    payload: Uint8Array,\n    recipient: PublicKeyBundle,\n    timestamp?: Date\n  ): Promise<MessageV1> {\n    timestamp = timestamp || new Date()\n\n    return MessageV1.encode(\n      this.client.keystore,\n      payload,\n      this.client.publicKeyBundle,\n      recipient,\n      timestamp\n    )\n  }\n}\n\n/**\n * ConversationV2\n */\nexport class ConversationV2<ContentTypes>\n  implements Conversation<ContentTypes>\n{\n  conversationVersion = 'v2' as const\n  client: Client<ContentTypes>\n  topic: string\n  peerAddress: string\n  createdAt: Date\n  context?: InvitationContext\n\n  constructor(\n    client: Client<ContentTypes>,\n    topic: string,\n    peerAddress: string,\n    createdAt: Date,\n    context: InvitationContext | undefined\n  ) {\n    this.topic = topic\n    this.createdAt = createdAt\n    this.context = context\n    this.client = client\n    this.peerAddress = peerAddress\n  }\n\n  get clientAddress() {\n    return this.client.address\n  }\n\n  /**\n   * Returns a list of all messages to/from the peerAddress\n   */\n  async messages(\n    opts?: ListMessagesOptions\n  ): Promise<DecodedMessage<ContentTypes>[]> {\n    const messages = await this.client.listEnvelopes(\n      this.topic,\n      this.processEnvelope.bind(this),\n      opts\n    )\n\n    return this.decryptBatch(messages, false)\n  }\n\n  messagesPaginated(\n    opts?: ListMessagesPaginatedOptions\n  ): AsyncGenerator<DecodedMessage<ContentTypes>[]> {\n    return this.client.listEnvelopesPaginated(\n      this.topic,\n      this.decodeMessage.bind(this),\n      opts\n    )\n  }\n\n  get ephemeralTopic(): string {\n    return this.topic.replace('/xmtp/0/m', '/xmtp/0/mE')\n  }\n\n  streamEphemeral(\n    onConnectionLost?: OnConnectionLostCallback\n  ): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>> {\n    return Stream.create<DecodedMessage<ContentTypes>, ContentTypes>(\n      this.client,\n      [this.ephemeralTopic],\n      this.decodeMessage.bind(this),\n      undefined,\n      onConnectionLost\n    )\n  }\n\n  /**\n   * Returns a Stream of any new messages to/from the peerAddress\n   */\n  streamMessages(\n    onConnectionLost?: OnConnectionLostCallback\n  ): Promise<Stream<DecodedMessage<ContentTypes>, ContentTypes>> {\n    return Stream.create<DecodedMessage<ContentTypes>, ContentTypes>(\n      this.client,\n      [this.topic],\n      this.decodeMessage.bind(this),\n      undefined,\n      onConnectionLost\n    )\n  }\n\n  /**\n   * Send a message into the conversation\n   */\n  async send(\n    content: Exclude<ContentTypes, undefined>,\n    options?: SendOptions\n  ): Promise<DecodedMessage<ContentTypes>> {\n    const payload = await this.client.encodeContent(content, options)\n    const msg = await this.createMessage(payload, options?.timestamp)\n\n    let topic: string\n    if (options?.ephemeral) {\n      topic = this.ephemeralTopic\n    } else {\n      topic = this.topic\n    }\n\n    await this.client.publishEnvelopes([\n      {\n        contentTopic: topic,\n        message: msg.toBytes(),\n        timestamp: msg.sent,\n      },\n    ])\n    const contentType = options?.contentType || ContentTypeText\n\n    return DecodedMessage.fromV2Message(\n      msg,\n      content,\n      contentType,\n      this.topic,\n      payload,\n      this,\n      this.client.address\n    )\n  }\n\n  async createMessage(\n    // Payload is expected to have already gone through `client.encodeContent`\n    payload: Uint8Array,\n    timestamp?: Date\n  ): Promise<MessageV2> {\n    const header: message.MessageHeaderV2 = {\n      topic: this.topic,\n      createdNs: dateToNs(timestamp || new Date()),\n    }\n    const headerBytes = message.MessageHeaderV2.encode(header).finish()\n    const digest = await sha256(concat(headerBytes, payload))\n    const signed = {\n      payload,\n      sender: this.client.signedPublicKeyBundle,\n      signature: await this.client.keystore.signDigest({\n        digest,\n        prekeyIndex: 0,\n        identityKey: undefined,\n      }),\n    }\n    const signedBytes = proto.SignedContent.encode(signed).finish()\n\n    const ciphertext = await this.encryptMessage(signedBytes, headerBytes)\n    const protoMsg = {\n      v1: undefined,\n      v2: { headerBytes, ciphertext },\n    }\n    const bytes = message.Message.encode(protoMsg).finish()\n\n    return MessageV2.create(protoMsg, header, bytes)\n  }\n\n  private async decryptBatch(\n    messages: MessageV2[],\n    throwOnError = false\n  ): Promise<DecodedMessage<ContentTypes>[]> {\n    const responses = (\n      await this.client.keystore.decryptV2(this.buildDecryptRequest(messages))\n    ).responses\n\n    const out: DecodedMessage<ContentTypes>[] = []\n    for (let i = 0; i < responses.length; i++) {\n      const result = responses[i]\n      const message = messages[i]\n\n      try {\n        const { decrypted } = getResultOrThrow(result)\n        out.push(await this.buildDecodedMessage(message, decrypted))\n      } catch (e) {\n        if (throwOnError) {\n          throw e\n        }\n        console.warn('Error decoding content', e)\n      }\n    }\n\n    return out\n  }\n\n  private buildDecryptRequest(\n    messages: message.MessageV2[]\n  ): keystore.DecryptV2Request {\n    return {\n      requests: messages.map((m) => {\n        return {\n          payload: m.ciphertext,\n          headerBytes: m.headerBytes,\n          contentTopic: this.topic,\n        }\n      }),\n    }\n  }\n\n  private async encryptMessage(\n    payload: Uint8Array,\n    headerBytes: Uint8Array\n  ): Promise<ciphertext.Ciphertext> {\n    const { responses } = await this.client.keystore.encryptV2({\n      requests: [\n        {\n          payload,\n          headerBytes,\n          contentTopic: this.topic,\n        },\n      ],\n    })\n    if (responses.length !== 1) {\n      throw new Error('Invalid response length')\n    }\n    const { encrypted } = getResultOrThrow(responses[0])\n    return encrypted\n  }\n\n  private async buildDecodedMessage(\n    msg: MessageV2,\n    decrypted: Uint8Array\n  ): Promise<DecodedMessage<ContentTypes>> {\n    // Decode the decrypted bytes into SignedContent\n    const signed = proto.SignedContent.decode(decrypted)\n    if (\n      !signed.sender?.identityKey ||\n      !signed.sender?.preKey ||\n      !signed.signature\n    ) {\n      throw new Error('incomplete signed content')\n    }\n\n    await validatePrekeys(signed)\n\n    // Verify the signature\n    const digest = await sha256(concat(msg.headerBytes, signed.payload))\n    if (\n      !new SignedPublicKey(signed.sender?.preKey).verify(\n        new Signature(signed.signature),\n        digest\n      )\n    ) {\n      throw new Error('invalid signature')\n    }\n\n    // Derive the sender address from the valid signature\n    const senderAddress = await new SignedPublicKeyBundle(\n      signed.sender\n    ).walletSignatureAddress()\n\n    const { content, contentType, error, contentFallback } =\n      await this.client.decodeContent(signed.payload)\n\n    return DecodedMessage.fromV2Message(\n      msg,\n      content,\n      contentType,\n      this.topic,\n      signed.payload,\n      this,\n      senderAddress,\n      error,\n      contentFallback\n    )\n  }\n\n  async prepareMessage(\n    content: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    options?: SendOptions\n  ): Promise<PreparedMessage> {\n    const payload = await this.client.encodeContent(content, options)\n    const msg = await this.createMessage(payload, options?.timestamp)\n\n    const topic = options?.ephemeral ? this.ephemeralTopic : this.topic\n\n    const env: messageApi.Envelope = {\n      contentTopic: topic,\n      message: msg.toBytes(),\n      timestampNs: toNanoString(msg.sent),\n    }\n\n    return new PreparedMessage(env, async () => {\n      await this.client.publishEnvelopes([\n        {\n          contentTopic: this.topic,\n          message: msg.toBytes(),\n          timestamp: msg.sent,\n        },\n      ])\n    })\n  }\n\n  async processEnvelope(env: messageApi.Envelope): Promise<MessageV2> {\n    if (!env.message || !env.contentTopic) {\n      throw new Error('empty envelope')\n    }\n    const msg = message.Message.decode(env.message)\n\n    if (!msg.v2) {\n      throw new Error('unknown message version')\n    }\n\n    const header = message.MessageHeaderV2.decode(msg.v2.headerBytes)\n    if (header.topic !== this.topic) {\n      throw new Error('topic mismatch')\n    }\n\n    return MessageV2.create(msg, header, env.message)\n  }\n\n  async decodeMessage(\n    env: messageApi.Envelope\n  ): Promise<DecodedMessage<ContentTypes>> {\n    if (!env.contentTopic) {\n      throw new Error('Missing content topic')\n    }\n    const msg = await this.processEnvelope(env)\n    const decryptResults = await this.decryptBatch([msg], true)\n    if (!decryptResults.length) {\n      throw new Error('No results')\n    }\n    return decryptResults[0]\n  }\n}\n\nasync function validatePrekeys(signed: proto.SignedContent) {\n  // Check that the pre key is signed by the identity key\n  // this is required to chain the prekey-signed message to the identity key\n  // and finally to the user's wallet address\n  const senderPreKey = signed.sender?.preKey\n  if (!senderPreKey || !senderPreKey.signature || !senderPreKey.keyBytes) {\n    throw new Error('missing pre-key or pre-key signature')\n  }\n  const senderIdentityKey = signed.sender?.identityKey\n  if (!senderIdentityKey) {\n    throw new Error('missing identity key in bundle')\n  }\n  const isValidPrekey = await new SignedPublicKey(senderIdentityKey).verifyKey(\n    new SignedPublicKey(senderPreKey)\n  )\n  if (!isValidPrekey) {\n    throw new Error('pre key not signed by identity key')\n  }\n}\n","import {\n  OnConnectionLostCallback,\n  SubscriptionManager,\n  UnsubscribeFn,\n} from './ApiClient'\nimport Client from './Client'\nimport { messageApi } from '@xmtp/proto'\n\nexport type MessageDecoder<M> = (\n  env: messageApi.Envelope\n) => Promise<M | undefined>\n\nexport type ContentTopicUpdater<M> = (msg: M) => string[] | undefined\n\n/**\n * Stream implements an Asynchronous Iterable over messages received from a topic.\n * As such can be used with constructs like for-await-of, yield*, array destructing, etc.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default class Stream<T, ClientType = any> {\n  topics: string[]\n  client: Client<ClientType>\n  // queue of incoming Waku messages\n  messages: T[]\n  // queue of already pending Promises\n  resolvers: ((value: IteratorResult<T>) => void)[]\n  // cache the callback so that it can be properly deregistered in Waku\n  // if callback is undefined the stream is closed\n  callback: ((env: messageApi.Envelope) => Promise<void>) | undefined\n\n  subscriptionManager?: SubscriptionManager\n\n  onConnectionLost?: OnConnectionLostCallback\n\n  constructor(\n    client: Client<ClientType>,\n    topics: string[],\n    decoder: MessageDecoder<T>,\n    contentTopicUpdater?: ContentTopicUpdater<T>,\n    onConnectionLost?: OnConnectionLostCallback\n  ) {\n    this.messages = []\n    this.resolvers = []\n    this.topics = topics\n    this.client = client\n    this.callback = this.newMessageCallback(decoder, contentTopicUpdater)\n    this.onConnectionLost = onConnectionLost\n  }\n\n  // returns new closure to handle incoming messages\n  private newMessageCallback(\n    decoder: MessageDecoder<T>,\n    contentTopicUpdater?: ContentTopicUpdater<T>\n  ): (env: messageApi.Envelope) => Promise<void> {\n    return async (env: messageApi.Envelope) => {\n      if (!env.message) {\n        return\n      }\n      try {\n        const msg = await decoder(env)\n        // decoder can return undefined to signal a message to ignore/skip.\n        if (!msg) {\n          return\n        }\n        // Check to see if we should update the stream's content topic subscription\n        if (contentTopicUpdater) {\n          const topics = contentTopicUpdater(msg)\n          if (topics) {\n            this.resubscribeToTopics(topics)\n          }\n        }\n        // is there a Promise already pending?\n        const resolver = this.resolvers.pop()\n        if (resolver) {\n          // yes, resolve it\n          resolver({ value: msg })\n        } else {\n          // no, push the message into the queue\n          this.messages.unshift(msg)\n        }\n      } catch (e) {\n        console.warn(e)\n      }\n    }\n  }\n\n  private async start(): Promise<void> {\n    if (!this.callback) {\n      throw new Error('Missing callback for stream')\n    }\n\n    this.subscriptionManager = this.client.apiClient.subscribe(\n      {\n        contentTopics: this.topics,\n      },\n      async (env: messageApi.Envelope) => {\n        if (!this.callback) return\n        await this?.callback(env)\n      },\n      this.onConnectionLost\n    )\n  }\n\n  static async create<T, ClientType = string>(\n    client: Client<ClientType>,\n    topics: string[],\n    decoder: MessageDecoder<T>,\n    contentTopicUpdater?: ContentTopicUpdater<T>,\n    onConnectionLost?: OnConnectionLostCallback\n  ): Promise<Stream<T, ClientType>> {\n    const stream = new Stream(\n      client,\n      topics,\n      decoder,\n      contentTopicUpdater,\n      onConnectionLost\n    )\n    await stream.start()\n    return stream\n  }\n\n  // To make Stream proper Async Iterable\n  [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n    return this\n  }\n\n  // return should be called if the interpreter detects that the stream won't be used anymore,\n  // e.g. a for/of loop was exited via a break. It can also be called explicitly.\n  // https://tc39.es/ecma262/#table-iterator-interface-optional-properties\n  // Note that this means the Stream will be closed after it was used in a for-await-of or yield* or similar.\n  async return(): Promise<IteratorResult<T>> {\n    if (this.subscriptionManager) {\n      await this.subscriptionManager.unsubscribe()\n    }\n    if (!this.callback) {\n      return { value: undefined, done: true }\n    }\n    this.callback = undefined\n    this.resolvers.forEach((resolve) =>\n      resolve({ value: undefined, done: true })\n    )\n    return { value: undefined, done: true }\n  }\n\n  // To make Stream proper Async Iterator\n  // Note that next() will still provide whatever messages were already pending\n  // even after the stream was closed via return().\n  next(): Promise<IteratorResult<T>> {\n    // Is there a message already pending?\n    const msg = this.messages.pop()\n    if (msg) {\n      // yes, return resolved promise\n      return Promise.resolve({ value: msg })\n    }\n    if (!this.callback) {\n      return Promise.resolve({ value: undefined, done: true })\n    }\n    // otherwise return empty Promise and queue its resolver\n    return new Promise((resolve) => this.resolvers.unshift(resolve))\n  }\n\n  // Unsubscribe from the existing content topics and resubscribe to the given topics.\n  private async resubscribeToTopics(topics: string[]): Promise<void> {\n    if (!this.callback || !this.subscriptionManager) {\n      throw new Error('Missing callback for stream')\n    }\n\n    if (typeof this.subscriptionManager?.updateContentTopics === 'function') {\n      return this.subscriptionManager.updateContentTopics(topics)\n    }\n\n    await this.subscriptionManager.unsubscribe()\n    this.topics = topics\n    this.subscriptionManager = this.client.apiClient.subscribe(\n      {\n        contentTopics: this.topics,\n      },\n      async (env: messageApi.Envelope) => {\n        if (!this.callback) return\n        await this?.callback(env)\n      },\n      this.onConnectionLost\n    )\n  }\n}\n","import { publicKey } from '@xmtp/proto'\nimport { PublicKey, SignedPublicKey } from './PublicKey'\n\n// LEGACY: PublicKeyBundle packages all the keys that a participant should advertise.\n// The PreKey must be signed by the IdentityKey.\n// The IdentityKey must be signed by the wallet to authenticate it.\nexport class SignedPublicKeyBundle implements publicKey.SignedPublicKeyBundle {\n  identityKey: SignedPublicKey\n  preKey: SignedPublicKey\n\n  constructor(bundle: publicKey.SignedPublicKeyBundle) {\n    if (!bundle.identityKey) {\n      throw new Error('missing identity key')\n    }\n    if (!bundle.preKey) {\n      throw new Error('missing pre-key')\n    }\n    this.identityKey = new SignedPublicKey(bundle.identityKey)\n    this.preKey = new SignedPublicKey(bundle.preKey)\n  }\n\n  walletSignatureAddress(): Promise<string> {\n    return this.identityKey.walletSignatureAddress()\n  }\n\n  equals(other: this): boolean {\n    return (\n      this.identityKey.equals(other.identityKey) &&\n      this.preKey.equals(other.preKey)\n    )\n  }\n\n  toBytes(): Uint8Array {\n    return publicKey.SignedPublicKeyBundle.encode(this).finish()\n  }\n\n  isFromLegacyBundle(): boolean {\n    return this.identityKey.isFromLegacyKey() && this.preKey.isFromLegacyKey()\n  }\n\n  toLegacyBundle(): PublicKeyBundle {\n    return new PublicKeyBundle({\n      identityKey: this.identityKey.toLegacyKey(),\n      preKey: this.preKey.toLegacyKey(),\n    })\n  }\n\n  static fromBytes(bytes: Uint8Array): SignedPublicKeyBundle {\n    const decoded = publicKey.SignedPublicKeyBundle.decode(bytes)\n    return new SignedPublicKeyBundle(decoded)\n  }\n\n  static fromLegacyBundle(bundle: PublicKeyBundle): SignedPublicKeyBundle {\n    return new SignedPublicKeyBundle({\n      // Note: I am assuming all PublicKeyBundles passed into this have had their identity keys signed by a wallet\n      // Maybe that is not universally true in the future\n      identityKey: SignedPublicKey.fromLegacyKey(bundle.identityKey, true),\n      preKey: SignedPublicKey.fromLegacyKey(bundle.preKey),\n    })\n  }\n}\n\n// LEGACY: PublicKeyBundle packages all the keys that a participant should advertise.\n// The PreKey must be signed by the IdentityKey.\n// The IdentityKey can be signed by the wallet to authenticate it.\nexport class PublicKeyBundle implements publicKey.PublicKeyBundle {\n  identityKey: PublicKey\n  preKey: PublicKey\n\n  constructor(bundle: publicKey.PublicKeyBundle) {\n    if (!bundle.identityKey) {\n      throw new Error('missing identity key')\n    }\n    if (!bundle.preKey) {\n      throw new Error('missing pre-key')\n    }\n    this.identityKey = new PublicKey(bundle.identityKey)\n    this.preKey = new PublicKey(bundle.preKey)\n  }\n\n  equals(other: this): boolean {\n    return (\n      this.identityKey.equals(other.identityKey) &&\n      this.preKey.equals(other.preKey)\n    )\n  }\n\n  walletSignatureAddress(): string {\n    return this.identityKey.walletSignatureAddress()\n  }\n\n  toBytes(): Uint8Array {\n    return publicKey.PublicKeyBundle.encode(this).finish()\n  }\n\n  static fromBytes(bytes: Uint8Array): PublicKeyBundle {\n    const decoded = publicKey.PublicKeyBundle.decode(bytes)\n    return new PublicKeyBundle(decoded)\n  }\n}\n","import { publicKey } from '@xmtp/proto'\nimport * as secp from '@noble/secp256k1'\nimport Long from 'long'\nimport Signature, { WalletSigner } from './Signature'\nimport { equalBytes, hexToBytes } from './utils'\nimport { utils } from 'ethers'\nimport { Signer } from '../types/Signer'\nimport { sha256 } from './encryption'\n\n// SECP256k1 public key in uncompressed format with prefix\ntype secp256k1Uncompressed = {\n  // uncompressed point with prefix (0x04) [ P || X || Y ], 65 bytes\n  bytes: Uint8Array\n}\n\n// Validate a key.\nfunction secp256k1UncompressedCheck(key: secp256k1Uncompressed): void {\n  if (key.bytes.length !== 65) {\n    throw new Error(`invalid public key length: ${key.bytes.length}`)\n  }\n  if (key.bytes[0] !== 4) {\n    throw new Error(`unrecognized public key prefix: ${key.bytes[0]}`)\n  }\n}\n\nconst MS_NS_TIMESTAMP_THRESHOLD = new Long(10 ** 9).mul(10 ** 9)\n\n// Basic public key without a signature.\nexport class UnsignedPublicKey implements publicKey.UnsignedPublicKey {\n  // time the key was generated, normally ns since epoch, however\n  // to allow transparent conversion of pre-existing signed PublicKey to SignedPublicKey\n  // it can also be ms since epoch; use MS_NS_TIMESTAMP_THRESHOLD to distinguish\n  // the two cases.\n  createdNs: Long\n  secp256k1Uncompressed: secp256k1Uncompressed // eslint-disable-line camelcase\n\n  constructor(obj: publicKey.UnsignedPublicKey) {\n    if (!obj?.secp256k1Uncompressed) {\n      throw new Error('invalid public key')\n    }\n    secp256k1UncompressedCheck(obj.secp256k1Uncompressed)\n    this.secp256k1Uncompressed = obj.secp256k1Uncompressed\n    this.createdNs = obj.createdNs.toUnsigned()\n  }\n\n  // The time the key was generated.\n  generated(): Date | undefined {\n    return new Date(this.timestamp.toNumber())\n  }\n\n  isFromLegacyKey(): boolean {\n    return this.createdNs.lessThan(MS_NS_TIMESTAMP_THRESHOLD)\n  }\n\n  // creation time in milliseconds\n  get timestamp(): Long {\n    return (\n      this.isFromLegacyKey() ? this.createdNs : this.createdNs.div(1000000)\n    ).toUnsigned()\n  }\n\n  // Verify that signature was created from the digest using matching private key.\n  verify(signature: Signature, digest: Uint8Array): boolean {\n    if (!signature.ecdsaCompact) {\n      return false\n    }\n    return secp.verify(\n      signature.ecdsaCompact.bytes,\n      digest,\n      this.secp256k1Uncompressed.bytes\n    )\n  }\n\n  // Verify that the provided public key was signed by matching private key.\n  async verifyKey(pub: PublicKey | SignedPublicKey): Promise<boolean> {\n    if (!pub.signature) {\n      return false\n    }\n    const digest = await sha256(pub.bytesToSign())\n    return this.verify(pub.signature, digest)\n  }\n\n  // Is other the same/equivalent public key?\n  equals(other: this): boolean {\n    return equalBytes(\n      this.secp256k1Uncompressed.bytes,\n      other.secp256k1Uncompressed.bytes\n    )\n  }\n\n  // Derive Ethereum address from this public key.\n  getEthereumAddress(): string {\n    return utils.computeAddress(this.secp256k1Uncompressed.bytes)\n  }\n\n  // Encode public key into bytes.\n  toBytes(): Uint8Array {\n    return publicKey.UnsignedPublicKey.encode(this).finish()\n  }\n\n  // Decode public key from bytes.\n  static fromBytes(bytes: Uint8Array): UnsignedPublicKey {\n    return new UnsignedPublicKey(publicKey.UnsignedPublicKey.decode(bytes))\n  }\n}\n\n// Public key signed by another key pair or a wallet.\nexport class SignedPublicKey\n  extends UnsignedPublicKey\n  implements publicKey.SignedPublicKey\n{\n  keyBytes: Uint8Array // caches the bytes of the encoded unsigned key\n  signature: Signature\n\n  constructor(obj: publicKey.SignedPublicKey) {\n    if (!obj.keyBytes) {\n      throw new Error('missing key bytes')\n    }\n    super(publicKey.UnsignedPublicKey.decode(obj.keyBytes))\n    this.keyBytes = obj.keyBytes\n    if (!obj.signature) {\n      throw new Error('missing key signature')\n    }\n    this.signature = new Signature(obj.signature)\n  }\n\n  // Return the key without the signature.\n  get unsignedKey(): UnsignedPublicKey {\n    return new UnsignedPublicKey({\n      createdNs: this.createdNs,\n      secp256k1Uncompressed: this.secp256k1Uncompressed,\n    })\n  }\n\n  // Return public key of the signer of this key.\n  signerKey(): Promise<UnsignedPublicKey | undefined> {\n    return this.signature.signerKey(this)\n  }\n\n  // Assume the key was signed by a wallet and\n  // return the wallet address that validates\n  // the signature of this key.\n  async walletSignatureAddress(): Promise<string> {\n    if (!this.signature.walletEcdsaCompact) {\n      throw new Error('key was not signed by a wallet')\n    }\n    const pk = await this.signerKey()\n    if (!pk) {\n      throw new Error('key signature not valid')\n    }\n    return pk.getEthereumAddress()\n  }\n\n  // Is other the same/equivalent public key?\n  equals(other: this): boolean {\n    return (\n      this.unsignedKey.equals(other.unsignedKey) &&\n      this.signature.equals(other.signature)\n    )\n  }\n\n  // Return bytes of the encoded unsigned key.\n  bytesToSign(): Uint8Array {\n    return this.keyBytes\n  }\n\n  // Encode signed key into bytes.\n  toBytes(): Uint8Array {\n    return publicKey.SignedPublicKey.encode(this).finish()\n  }\n\n  // Decode signed key from bytes.\n  static fromBytes(bytes: Uint8Array): SignedPublicKey {\n    return new SignedPublicKey(publicKey.SignedPublicKey.decode(bytes))\n  }\n\n  toLegacyKey(): PublicKey {\n    if (!this.isFromLegacyKey()) {\n      throw new Error('cannot be converted to legacy key')\n    }\n    let signature = this.signature\n    if (signature.walletEcdsaCompact) {\n      signature = new Signature({\n        ecdsaCompact: signature.walletEcdsaCompact,\n      })\n    }\n    return new PublicKey({\n      timestamp: this.timestamp,\n      secp256k1Uncompressed: this.secp256k1Uncompressed,\n      signature,\n    })\n  }\n\n  static fromLegacyKey(\n    legacyKey: PublicKey,\n    signedByWallet?: boolean\n  ): SignedPublicKey {\n    if (!legacyKey.signature) {\n      throw new Error('key is not signed')\n    }\n    let signature = legacyKey.signature\n    if (signedByWallet) {\n      signature = new Signature({\n        walletEcdsaCompact: signature.ecdsaCompact,\n      })\n    }\n    return new SignedPublicKey({\n      keyBytes: legacyKey.bytesToSign(),\n      signature,\n    })\n  }\n}\n\n// LEGACY: PublicKey optionally signed with another trusted key pair or a wallet.\n// PublicKeys can be generated through PrivateKey.generate()\nexport class PublicKey\n  extends UnsignedPublicKey\n  implements publicKey.PublicKey\n{\n  signature?: Signature\n\n  constructor(obj: publicKey.PublicKey) {\n    super({\n      createdNs: obj.timestamp.mul(1000000),\n      secp256k1Uncompressed: obj.secp256k1Uncompressed,\n    })\n    if (obj.signature) {\n      // Handle a case where Flutter was publishing signatures with walletEcdsaCompact\n      // instead of ecdsaCompact for v1 keys.\n      if (!obj.signature.ecdsaCompact && obj.signature.walletEcdsaCompact) {\n        this.signature = new Signature({\n          ecdsaCompact: {\n            bytes: obj.signature.walletEcdsaCompact.bytes,\n            recovery: obj.signature.walletEcdsaCompact.recovery,\n          },\n        })\n      } else {\n        this.signature = new Signature(obj.signature)\n      }\n    }\n  }\n\n  get timestamp(): Long {\n    return this.createdNs.div(1000000)\n  }\n\n  bytesToSign(): Uint8Array {\n    return publicKey.PublicKey.encode({\n      timestamp: this.timestamp,\n      secp256k1Uncompressed: this.secp256k1Uncompressed,\n    }).finish()\n  }\n\n  // sign the key using a wallet\n  async signWithWallet(wallet: Signer): Promise<void> {\n    const sigString = await wallet.signMessage(\n      WalletSigner.identitySigRequestText(this.bytesToSign())\n    )\n    const eSig = utils.splitSignature(sigString)\n    const r = hexToBytes(eSig.r)\n    const s = hexToBytes(eSig.s)\n    const sigBytes = new Uint8Array(64)\n    sigBytes.set(r)\n    sigBytes.set(s, r.length)\n    this.signature = new Signature({\n      ecdsaCompact: {\n        bytes: sigBytes,\n        recovery: eSig.recoveryParam,\n      },\n    })\n  }\n\n  // Assume the key was signed by a wallet and\n  // return the wallet address that validates\n  // the signature for this key.\n  walletSignatureAddress(): string {\n    if (!this.signature) {\n      throw new Error('key is not signed')\n    }\n    const digest = hexToBytes(\n      utils.hashMessage(WalletSigner.identitySigRequestText(this.bytesToSign()))\n    )\n    const pk = this.signature.getPublicKey(digest)\n    if (!pk) {\n      throw new Error('key signature is malformed')\n    }\n    return pk.getEthereumAddress()\n  }\n\n  toBytes(): Uint8Array {\n    return publicKey.PublicKey.encode(this).finish()\n  }\n\n  static fromBytes(bytes: Uint8Array): PublicKey {\n    return new PublicKey(publicKey.PublicKey.decode(bytes))\n  }\n}\n","import { signature } from '@xmtp/proto'\nimport Long from 'long'\nimport * as secp from '@noble/secp256k1'\nimport { PublicKey, UnsignedPublicKey, SignedPublicKey } from './PublicKey'\nimport { SignedPrivateKey } from './PrivateKey'\nimport { utils } from 'ethers'\nimport { Signer } from '../types/Signer'\nimport { bytesToHex, equalBytes, hexToBytes } from './utils'\n\n// ECDSA signature with recovery bit.\nexport type ECDSACompactWithRecovery = {\n  bytes: Uint8Array // compact representation [ R || S ], 64 bytes\n  recovery: number // recovery bit\n}\n\n// Validate signature.\nfunction ecdsaCheck(sig: ECDSACompactWithRecovery): void {\n  if (sig.bytes.length !== 64) {\n    throw new Error(`invalid signature length: ${sig.bytes.length}`)\n  }\n  if (sig.recovery !== 0 && sig.recovery !== 1) {\n    throw new Error(`invalid recovery bit: ${sig.recovery}`)\n  }\n}\n\n// Compare signatures.\nfunction ecdsaEqual(\n  a: ECDSACompactWithRecovery,\n  b: ECDSACompactWithRecovery\n): boolean {\n  return a.recovery === b.recovery && equalBytes(a.bytes, b.bytes)\n}\n\n// Derive public key of the signer from the digest and the signature.\nexport function ecdsaSignerKey(\n  digest: Uint8Array,\n  signature: ECDSACompactWithRecovery\n): UnsignedPublicKey | undefined {\n  const bytes = secp.recoverPublicKey(\n    digest,\n    signature.bytes,\n    signature.recovery\n  )\n  return bytes\n    ? new UnsignedPublicKey({\n        secp256k1Uncompressed: { bytes },\n        createdNs: Long.fromNumber(0),\n      })\n    : undefined\n}\n\nexport default class Signature implements signature.Signature {\n  // SECP256k1/SHA256 ECDSA signature\n  ecdsaCompact: ECDSACompactWithRecovery | undefined // eslint-disable-line camelcase\n  // SECP256k1/keccak256 ECDSA signature created with Signer.signMessage (see WalletSigner)\n  walletEcdsaCompact: ECDSACompactWithRecovery | undefined // eslint-disable-line camelcase\n\n  constructor(obj: Partial<signature.Signature>) {\n    if (obj.ecdsaCompact) {\n      ecdsaCheck(obj.ecdsaCompact)\n      this.ecdsaCompact = obj.ecdsaCompact\n    } else if (obj.walletEcdsaCompact) {\n      ecdsaCheck(obj.walletEcdsaCompact)\n      this.walletEcdsaCompact = obj.walletEcdsaCompact\n    } else {\n      throw new Error('invalid signature')\n    }\n  }\n\n  // Return the public key that validates provided key's signature.\n  async signerKey(\n    key: SignedPublicKey\n  ): Promise<UnsignedPublicKey | undefined> {\n    if (this.ecdsaCompact) {\n      return SignedPrivateKey.signerKey(key, this.ecdsaCompact)\n    } else if (this.walletEcdsaCompact) {\n      return WalletSigner.signerKey(key, this.walletEcdsaCompact)\n    } else {\n      return undefined\n    }\n  }\n\n  // LEGACY: Return the public key that validates this signature given the provided digest.\n  // Return undefined if the signature is malformed.\n  getPublicKey(digest: Uint8Array): PublicKey | undefined {\n    let bytes: Uint8Array | undefined\n    if (this.ecdsaCompact) {\n      bytes = secp.recoverPublicKey(\n        digest,\n        this.ecdsaCompact.bytes,\n        this.ecdsaCompact.recovery\n      )\n    } else if (this.walletEcdsaCompact) {\n      bytes = secp.recoverPublicKey(\n        digest,\n        this.walletEcdsaCompact.bytes,\n        this.walletEcdsaCompact.recovery\n      )\n    } else {\n      throw new Error('invalid v1 signature')\n    }\n    return bytes\n      ? new PublicKey({\n          secp256k1Uncompressed: { bytes },\n          timestamp: Long.fromNumber(0),\n        })\n      : undefined\n  }\n\n  // Is this the same/equivalent signature as other?\n  equals(other: Signature): boolean {\n    if (this.ecdsaCompact && other.ecdsaCompact) {\n      return ecdsaEqual(this.ecdsaCompact, other.ecdsaCompact)\n    }\n    if (this.walletEcdsaCompact && other.walletEcdsaCompact) {\n      return ecdsaEqual(this.walletEcdsaCompact, other.walletEcdsaCompact)\n    }\n    return false\n  }\n\n  toBytes(): Uint8Array {\n    return signature.Signature.encode(this).finish()\n  }\n\n  static fromBytes(bytes: Uint8Array): Signature {\n    return new Signature(signature.Signature.decode(bytes))\n  }\n}\n\n// Deprecation in progress\n// A signer that can be used to sign public keys.\nexport interface KeySigner {\n  signKey(key: UnsignedPublicKey): Promise<SignedPublicKey>\n}\n\nexport enum AccountLinkedRole {\n  INBOX_KEY,\n  SEND_KEY,\n}\n\n// A wallet based KeySigner.\nexport class WalletSigner implements KeySigner {\n  wallet: Signer\n\n  constructor(wallet: Signer) {\n    this.wallet = wallet\n  }\n\n  static identitySigRequestText(keyBytes: Uint8Array): string {\n    // Note that an update to this signature request text will require\n    // addition of backward compatibility for existing signatures\n    // and/or a migration; otherwise clients will fail to verify previously\n    // signed keys.\n    return (\n      'XMTP : Create Identity\\n' +\n      `${bytesToHex(keyBytes)}\\n` +\n      '\\n' +\n      'For more info: https://xmtp.org/signatures/'\n    )\n  }\n\n  static signerKey(\n    key: SignedPublicKey,\n    signature: ECDSACompactWithRecovery\n  ): UnsignedPublicKey | undefined {\n    const digest = hexToBytes(\n      utils.hashMessage(this.identitySigRequestText(key.bytesToSign()))\n    )\n    return ecdsaSignerKey(digest, signature)\n  }\n\n  async signKey(key: UnsignedPublicKey): Promise<SignedPublicKey> {\n    const keyBytes = key.toBytes()\n    const sigString = await this.wallet.signMessage(\n      WalletSigner.identitySigRequestText(keyBytes)\n    )\n    const eSig = utils.splitSignature(sigString)\n    const r = hexToBytes(eSig.r)\n    const s = hexToBytes(eSig.s)\n    const sigBytes = new Uint8Array(64)\n    sigBytes.set(r)\n    sigBytes.set(s, r.length)\n    const signature = new Signature({\n      walletEcdsaCompact: {\n        bytes: sigBytes,\n        recovery: eSig.recoveryParam,\n      },\n    })\n    return new SignedPublicKey({ keyBytes, signature })\n  }\n}\n","import { privateKey } from '@xmtp/proto'\nimport * as secp from '@noble/secp256k1'\nimport Long from 'long'\nimport Signature, {\n  ECDSACompactWithRecovery,\n  ecdsaSignerKey,\n  KeySigner,\n} from './Signature'\nimport { PublicKey, SignedPublicKey, UnsignedPublicKey } from './PublicKey'\nimport Ciphertext from './Ciphertext'\nimport { decrypt, encrypt, sha256 } from './encryption'\nimport { equalBytes } from './utils'\n\n// SECP256k1 private key\ntype secp256k1 = {\n  bytes: Uint8Array // D big-endian, 32 bytes\n}\n\n// Validate SECP256k1 private key\nfunction secp256k1Check(key: secp256k1): void {\n  if (key.bytes.length !== 32) {\n    throw new Error(`invalid private key length: ${key.bytes.length}`)\n  }\n}\n\n// A private key signed with another key pair or a wallet.\nexport class SignedPrivateKey\n  implements privateKey.SignedPrivateKey, KeySigner\n{\n  createdNs: Long // time the key was generated, ns since epoch\n  secp256k1: secp256k1 // eslint-disable-line camelcase\n  publicKey: SignedPublicKey // caches corresponding PublicKey\n\n  constructor(obj: privateKey.SignedPrivateKey) {\n    if (!obj.secp256k1) {\n      throw new Error('invalid private key')\n    }\n    secp256k1Check(obj.secp256k1)\n    this.secp256k1 = obj.secp256k1\n    this.createdNs = obj.createdNs\n    if (!obj.publicKey) {\n      throw new Error('missing public key')\n    }\n    this.publicKey = new SignedPublicKey(obj.publicKey)\n  }\n\n  // Create a random key pair signed by the signer.\n  static async generate(signer: KeySigner): Promise<SignedPrivateKey> {\n    const secp256k1 = {\n      bytes: secp.utils.randomPrivateKey(),\n    }\n    const createdNs = Long.fromNumber(new Date().getTime()).mul(1000000)\n    const unsigned = new UnsignedPublicKey({\n      secp256k1Uncompressed: {\n        bytes: secp.getPublicKey(secp256k1.bytes),\n      },\n      createdNs,\n    })\n    const signed = await signer.signKey(unsigned)\n    return new SignedPrivateKey({\n      secp256k1,\n      createdNs,\n      publicKey: signed,\n    })\n  }\n\n  // Time the key was generated.\n  generated(): Date | undefined {\n    return new Date(this.createdNs.div(1000000).toNumber())\n  }\n\n  // Sign provided digest.\n  async sign(digest: Uint8Array): Promise<Signature> {\n    const [signature, recovery] = await secp.sign(\n      digest,\n      this.secp256k1.bytes,\n      {\n        recovered: true,\n        der: false,\n      }\n    )\n    return new Signature({\n      ecdsaCompact: { bytes: signature, recovery },\n    })\n  }\n\n  // Sign provided public key.\n  async signKey(pub: UnsignedPublicKey): Promise<SignedPublicKey> {\n    const keyBytes = pub.toBytes()\n    const digest = await sha256(keyBytes)\n    const signature = await this.sign(digest)\n    return new SignedPublicKey({\n      keyBytes,\n      signature,\n    })\n  }\n\n  // Return public key of the signer of the provided signed key.\n  static async signerKey(\n    key: SignedPublicKey,\n    signature: ECDSACompactWithRecovery\n  ): Promise<UnsignedPublicKey | undefined> {\n    const digest = await sha256(key.bytesToSign())\n    return ecdsaSignerKey(digest, signature)\n  }\n\n  // Derive shared secret from peer's PublicKey;\n  // the peer can derive the same secret using their private key and our public key.\n  sharedSecret(peer: SignedPublicKey | UnsignedPublicKey): Uint8Array {\n    return secp.getSharedSecret(\n      this.secp256k1.bytes,\n      peer.secp256k1Uncompressed.bytes,\n      false\n    )\n  }\n\n  // encrypt plain bytes using a shared secret derived from peer's PublicKey;\n  // additionalData allows including unencrypted parts of a Message in the authentication\n  // protection provided by the encrypted part (to make the whole Message tamper evident)\n  encrypt(\n    plain: Uint8Array,\n    peer: UnsignedPublicKey,\n    additionalData?: Uint8Array\n  ): Promise<Ciphertext> {\n    const secret = this.sharedSecret(peer)\n    return encrypt(plain, secret, additionalData)\n  }\n\n  // decrypt Ciphertext using a shared secret derived from peer's PublicKey;\n  // throws if any part of Ciphertext or additionalData was tampered with\n  decrypt(\n    encrypted: Ciphertext,\n    peer: UnsignedPublicKey,\n    additionalData?: Uint8Array\n  ): Promise<Uint8Array> {\n    const secret = this.sharedSecret(peer)\n    return decrypt(encrypted, secret, additionalData)\n  }\n\n  // Does the provided PublicKey correspond to this PrivateKey?\n  matches(key: SignedPublicKey): boolean {\n    return this.publicKey.equals(key)\n  }\n\n  // Is other the same/equivalent key?\n  equals(other: this): boolean {\n    return (\n      equalBytes(this.secp256k1.bytes, other.secp256k1.bytes) &&\n      this.publicKey.equals(other.publicKey)\n    )\n  }\n\n  // Encode this key into bytes.\n  toBytes(): Uint8Array {\n    return privateKey.SignedPrivateKey.encode(this).finish()\n  }\n\n  validatePublicKey(): boolean {\n    const generatedPublicKey = secp.getPublicKey(this.secp256k1.bytes)\n    return equalBytes(\n      generatedPublicKey,\n      this.publicKey.secp256k1Uncompressed.bytes\n    )\n  }\n\n  // Decode key from bytes.\n  static fromBytes(bytes: Uint8Array): SignedPrivateKey {\n    return new SignedPrivateKey(privateKey.SignedPrivateKey.decode(bytes))\n  }\n\n  static fromLegacyKey(\n    key: PrivateKey,\n    signedByWallet?: boolean\n  ): SignedPrivateKey {\n    return new SignedPrivateKey({\n      createdNs: key.timestamp.mul(1000000),\n      secp256k1: key.secp256k1,\n      publicKey: SignedPublicKey.fromLegacyKey(key.publicKey, signedByWallet),\n    })\n  }\n}\n\n// LEGACY: PrivateKey represents a secp256k1 private key.\nexport class PrivateKey implements privateKey.PrivateKey {\n  timestamp: Long\n  secp256k1: secp256k1 // eslint-disable-line camelcase\n  publicKey: PublicKey // caches corresponding PublicKey\n\n  constructor(obj: privateKey.PrivateKey) {\n    if (!obj.secp256k1) {\n      throw new Error('invalid private key')\n    }\n    secp256k1Check(obj.secp256k1)\n    this.timestamp = obj.timestamp\n    this.secp256k1 = obj.secp256k1\n    if (!obj.publicKey) {\n      throw new Error('missing public key')\n    }\n    this.publicKey = new PublicKey(obj.publicKey)\n  }\n\n  // create a random PrivateKey/PublicKey pair.\n  static generate(): PrivateKey {\n    const secp256k1 = {\n      bytes: secp.utils.randomPrivateKey(),\n    }\n    const timestamp = Long.fromNumber(new Date().getTime())\n    return new PrivateKey({\n      secp256k1,\n      timestamp,\n      publicKey: new PublicKey({\n        secp256k1Uncompressed: {\n          bytes: secp.getPublicKey(secp256k1.bytes),\n        },\n        timestamp,\n      }),\n    })\n  }\n\n  generated(): Date | undefined {\n    return new Date(this.timestamp.toNumber())\n  }\n\n  // sign provided digest\n  async sign(digest: Uint8Array): Promise<Signature> {\n    const [signature, recovery] = await secp.sign(\n      digest,\n      this.secp256k1.bytes,\n      {\n        recovered: true,\n        der: false,\n      }\n    )\n    return new Signature({\n      ecdsaCompact: { bytes: signature, recovery },\n    })\n  }\n\n  // sign provided public key\n  async signKey(pub: PublicKey): Promise<PublicKey> {\n    const digest = await sha256(pub.bytesToSign())\n    pub.signature = await this.sign(digest)\n    return pub\n  }\n\n  // derive shared secret from peer's PublicKey;\n  // the peer can derive the same secret using their PrivateKey and our PublicKey\n  sharedSecret(peer: PublicKey | SignedPublicKey): Uint8Array {\n    return secp.getSharedSecret(\n      this.secp256k1.bytes,\n      peer.secp256k1Uncompressed.bytes,\n      false\n    )\n  }\n\n  // encrypt plain bytes using a shared secret derived from peer's PublicKey;\n  // additionalData allows including unencrypted parts of a Message in the authentication\n  // protection provided by the encrypted part (to make the whole Message tamper evident)\n  encrypt(\n    plain: Uint8Array,\n    peer: PublicKey,\n    additionalData?: Uint8Array\n  ): Promise<Ciphertext> {\n    const secret = this.sharedSecret(peer)\n    return encrypt(plain, secret, additionalData)\n  }\n\n  // decrypt Ciphertext using a shared secret derived from peer's PublicKey;\n  // throws if any part of Ciphertext or additionalData was tampered with\n  decrypt(\n    encrypted: Ciphertext,\n    peer: PublicKey,\n    additionalData?: Uint8Array\n  ): Promise<Uint8Array> {\n    const secret = this.sharedSecret(peer)\n    return decrypt(encrypted, secret, additionalData)\n  }\n\n  // Does the provided PublicKey correspond to this PrivateKey?\n  matches(key: PublicKey): boolean {\n    return this.publicKey.equals(key)\n  }\n\n  validatePublicKey(): boolean {\n    const generatedPublicKey = secp.getPublicKey(this.secp256k1.bytes)\n    return equalBytes(\n      generatedPublicKey,\n      this.publicKey.secp256k1Uncompressed.bytes\n    )\n  }\n\n  // Encode this key into bytes.\n  toBytes(): Uint8Array {\n    return privateKey.PrivateKey.encode(this).finish()\n  }\n\n  // Decode key from bytes.\n  static fromBytes(bytes: Uint8Array): PrivateKey {\n    return new PrivateKey(privateKey.PrivateKey.decode(bytes))\n  }\n}\n","import { ciphertext } from '@xmtp/proto'\n\nexport const AESKeySize = 32 // bytes\nexport const KDFSaltSize = 32 // bytes\n// AES-GCM defaults from https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\nexport const AESGCMNonceSize = 12 // property iv\nexport const AESGCMTagLength = 16 // property tagLength\n\n// Ciphertext packages the encrypted ciphertext with the salt and nonce used to produce it.\n// salt and nonce are not secret, and should be transmitted/stored along with the encrypted ciphertext.\nexport default class Ciphertext implements ciphertext.Ciphertext {\n  aes256GcmHkdfSha256: ciphertext.Ciphertext_Aes256gcmHkdfsha256 | undefined // eslint-disable-line camelcase\n\n  constructor(obj: ciphertext.Ciphertext) {\n    if (!obj.aes256GcmHkdfSha256) {\n      throw new Error('invalid ciphertext')\n    }\n    if (obj.aes256GcmHkdfSha256.payload.length < AESGCMTagLength) {\n      throw new Error(\n        `invalid ciphertext ciphertext length: ${obj.aes256GcmHkdfSha256.payload.length}`\n      )\n    }\n    if (obj.aes256GcmHkdfSha256.hkdfSalt.length !== KDFSaltSize) {\n      throw new Error(\n        `invalid ciphertext salt length: ${obj.aes256GcmHkdfSha256.hkdfSalt.length}`\n      )\n    }\n    if (obj.aes256GcmHkdfSha256.gcmNonce.length !== AESGCMNonceSize) {\n      throw new Error(\n        `invalid ciphertext nonce length: ${obj.aes256GcmHkdfSha256.gcmNonce.length}`\n      )\n    }\n    this.aes256GcmHkdfSha256 = obj.aes256GcmHkdfSha256\n  }\n\n  toBytes(): Uint8Array {\n    return ciphertext.Ciphertext.encode(this).finish()\n  }\n\n  static fromBytes(bytes: Uint8Array): Ciphertext {\n    return new Ciphertext(ciphertext.Ciphertext.decode(bytes))\n  }\n}\n","/**\n * This file is necessary to ensure that the crypto library is available\n * in node and the browser\n */\n\n// eslint-disable-next-line no-restricted-syntax\nimport { webcrypto as nodeCrypto } from 'crypto'\n\nconst webcrypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis\n    ? (globalThis.crypto as nodeCrypto.Crypto)\n    : undefined\n\nconst crypto = webcrypto ?? nodeCrypto\n\nexport default crypto\n","import { ciphertext } from '@xmtp/proto'\nimport Ciphertext, { AESGCMNonceSize, KDFSaltSize } from './Ciphertext'\nimport crypto from './crypto'\n\nconst hkdfNoInfo = new ArrayBuffer(0)\n\n// This is a variation of https://github.com/paulmillr/noble-secp256k1/blob/main/index.ts#L1378-L1388\n// that uses `digest('SHA-256', bytes)` instead of `digest('SHA-256', bytes.buffer)`\n// which seems to produce different results.\nexport async function sha256(bytes: Uint8Array): Promise<Uint8Array> {\n  return new Uint8Array(await crypto.subtle.digest('SHA-256', bytes))\n}\n\n// symmetric authenticated encryption of plaintext using the secret;\n// additionalData is used to protect un-encrypted parts of the message (header)\n// in the authentication scope of the encryption.\nexport async function encrypt(\n  plain: Uint8Array,\n  secret: Uint8Array,\n  additionalData?: Uint8Array\n): Promise<Ciphertext> {\n  const salt = crypto.getRandomValues(new Uint8Array(KDFSaltSize))\n  const nonce = crypto.getRandomValues(new Uint8Array(AESGCMNonceSize))\n  const key = await hkdf(secret, salt)\n  const encrypted: ArrayBuffer = await crypto.subtle.encrypt(\n    aesGcmParams(nonce, additionalData),\n    key,\n    plain\n  )\n  return new Ciphertext({\n    aes256GcmHkdfSha256: {\n      payload: new Uint8Array(encrypted),\n      hkdfSalt: salt,\n      gcmNonce: nonce,\n    },\n  })\n}\n\n// symmetric authenticated decryption of the encrypted ciphertext using the secret and additionalData\nexport async function decrypt(\n  encrypted: Ciphertext | ciphertext.Ciphertext,\n  secret: Uint8Array,\n  additionalData?: Uint8Array\n): Promise<Uint8Array> {\n  if (!encrypted.aes256GcmHkdfSha256) {\n    throw new Error('invalid payload ciphertext')\n  }\n  const key = await hkdf(secret, encrypted.aes256GcmHkdfSha256.hkdfSalt)\n  const decrypted: ArrayBuffer = await crypto.subtle.decrypt(\n    aesGcmParams(encrypted.aes256GcmHkdfSha256.gcmNonce, additionalData),\n    key,\n    encrypted.aes256GcmHkdfSha256.payload\n  )\n  return new Uint8Array(decrypted)\n}\n\n// helper for building Web Crypto API encryption parameter structure\nfunction aesGcmParams(\n  nonce: Uint8Array,\n  additionalData?: Uint8Array\n): AesGcmParams {\n  const spec: AesGcmParams = {\n    name: 'AES-GCM',\n    iv: nonce,\n  }\n  if (additionalData) {\n    spec.additionalData = additionalData\n  }\n  return spec\n}\n\n// Derive AES-256-GCM key from a shared secret and salt.\n// Returns crypto.CryptoKey suitable for the encrypt/decrypt API\nasync function hkdf(secret: Uint8Array, salt: Uint8Array): Promise<CryptoKey> {\n  const key = await crypto.subtle.importKey('raw', secret, 'HKDF', false, [\n    'deriveKey',\n  ])\n  return crypto.subtle.deriveKey(\n    { name: 'HKDF', hash: 'SHA-256', salt, info: hkdfNoInfo },\n    key,\n    { name: 'AES-GCM', length: 256 },\n    false,\n    ['encrypt', 'decrypt']\n  )\n}\n","import * as secp from '@noble/secp256k1'\n\nexport const bytesToHex = secp.utils.bytesToHex\n\nexport function hexToBytes(s: string): Uint8Array {\n  if (s.startsWith('0x')) {\n    s = s.slice(2)\n  }\n  const bytes = new Uint8Array(s.length / 2)\n  for (let i = 0; i < bytes.length; i++) {\n    const j = i * 2\n    bytes[i] = Number.parseInt(s.slice(j, j + 2), 16)\n  }\n  return bytes\n}\n\nexport function bytesToBase64(bytes: Uint8Array): string {\n  return Buffer.from(bytes).toString('base64')\n}\n\nexport function equalBytes(b1: Uint8Array, b2: Uint8Array): boolean {\n  if (b1.length !== b2.length) {\n    return false\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] !== b2[i]) {\n      return false\n    }\n  }\n  return true\n}\n","import { privateKey as proto } from '@xmtp/proto'\nimport { PrivateKey, SignedPrivateKey } from './PrivateKey'\nimport { WalletSigner } from './Signature'\nimport { PublicKey, SignedPublicKey } from './PublicKey'\nimport { PublicKeyBundle, SignedPublicKeyBundle } from './PublicKeyBundle'\nimport { Signer } from '../types/Signer'\nimport { NoMatchingPreKeyError } from './errors'\n\n// PrivateKeyBundle bundles the private keys corresponding to a PublicKeyBundle for convenience.\n// This bundle must not be shared with anyone, although will have to be persisted\n// somehow so that older messages can be decrypted again.\nexport class PrivateKeyBundleV2 implements proto.PrivateKeyBundleV2 {\n  identityKey: SignedPrivateKey\n  preKeys: SignedPrivateKey[]\n  version = 2\n  private _publicKeyBundle?: SignedPublicKeyBundle\n\n  constructor(bundle: proto.PrivateKeyBundleV2) {\n    if (!bundle.identityKey) {\n      throw new Error('missing identity key')\n    }\n    this.identityKey = new SignedPrivateKey(bundle.identityKey)\n    this.preKeys = (bundle.preKeys || []).map((k) => new SignedPrivateKey(k))\n  }\n\n  // Generate a new key bundle with the preKey signed byt the identityKey.\n  // Optionally sign the identityKey with the provided wallet as well.\n  static async generate(wallet: Signer): Promise<PrivateKeyBundleV2> {\n    const identityKey = await SignedPrivateKey.generate(\n      new WalletSigner(wallet)\n    )\n    const bundle = new PrivateKeyBundleV2({\n      identityKey,\n      preKeys: [],\n    })\n    await bundle.addPreKey()\n    return bundle\n  }\n\n  // Return the current (latest) pre-key (to be advertised).\n  getCurrentPreKey(): SignedPrivateKey {\n    return this.preKeys[0]\n  }\n\n  // Find pre-key matching the provided public key.\n  findPreKey(which: SignedPublicKey): SignedPrivateKey {\n    const preKey = this.preKeys.find((key) => key.matches(which))\n    if (!preKey) {\n      throw new NoMatchingPreKeyError(which)\n    }\n    return preKey\n  }\n\n  // Generate a new pre-key to be used as the current pre-key.\n  async addPreKey(): Promise<void> {\n    this._publicKeyBundle = undefined\n    const preKey = await SignedPrivateKey.generate(this.identityKey)\n    this.preKeys.unshift(preKey)\n  }\n\n  // Return a key bundle with the current pre-key.\n  getPublicKeyBundle(): SignedPublicKeyBundle {\n    if (!this._publicKeyBundle) {\n      this._publicKeyBundle = new SignedPublicKeyBundle({\n        identityKey: this.identityKey.publicKey,\n        preKey: this.getCurrentPreKey().publicKey,\n      })\n    }\n    return this._publicKeyBundle\n  }\n\n  // sharedSecret derives a secret from peer's key bundles using a variation of X3DH protocol\n  // where the sender's ephemeral key pair is replaced by the sender's pre-key.\n  // @peer is the peer's public key bundle\n  // @myPreKey indicates which of my preKeys should be used to derive the secret\n  // @recipient indicates if this is the sending or receiving side.\n  async sharedSecret(\n    peer: SignedPublicKeyBundle,\n    myPreKey: SignedPublicKey,\n    isRecipient: boolean\n  ): Promise<Uint8Array> {\n    if (!peer.identityKey || !peer.preKey) {\n      throw new Error('invalid peer key bundle')\n    }\n    if (!(await peer.identityKey.verifyKey(peer.preKey))) {\n      throw new Error('peer preKey signature invalid')\n    }\n    if (!this.identityKey) {\n      throw new Error('missing identity key')\n    }\n    let dh1: Uint8Array, dh2: Uint8Array, preKey: SignedPrivateKey\n    if (isRecipient) {\n      preKey = this.findPreKey(myPreKey)\n      dh1 = preKey.sharedSecret(peer.identityKey)\n      dh2 = this.identityKey.sharedSecret(peer.preKey)\n    } else {\n      preKey = this.findPreKey(myPreKey)\n      dh1 = this.identityKey.sharedSecret(peer.preKey)\n      dh2 = preKey.sharedSecret(peer.identityKey)\n    }\n    const dh3 = preKey.sharedSecret(peer.preKey)\n    const secret = new Uint8Array(dh1.length + dh2.length + dh3.length)\n    secret.set(dh1, 0)\n    secret.set(dh2, dh1.length)\n    secret.set(dh3, dh1.length + dh2.length)\n    return secret\n  }\n\n  encode(): Uint8Array {\n    return proto.PrivateKeyBundle.encode({\n      v1: undefined,\n      v2: this,\n    }).finish()\n  }\n\n  validatePublicKeys(): boolean {\n    if (!this.identityKey.validatePublicKey()) {\n      return false\n    }\n\n    return this.preKeys.every((key) => key.validatePublicKey())\n  }\n\n  equals(other: this): boolean {\n    if (this.preKeys.length !== other.preKeys.length) {\n      return false\n    }\n    for (let i = 0; i < this.preKeys.length; i++) {\n      if (!this.preKeys[i].equals(other.preKeys[i])) {\n        return false\n      }\n    }\n    return this.identityKey.equals(other.identityKey)\n  }\n\n  static fromLegacyBundle(bundle: PrivateKeyBundleV1): PrivateKeyBundleV2 {\n    return new PrivateKeyBundleV2({\n      identityKey: SignedPrivateKey.fromLegacyKey(bundle.identityKey, true),\n      preKeys: bundle.preKeys.map((k: PrivateKey) =>\n        SignedPrivateKey.fromLegacyKey(k)\n      ),\n    })\n  }\n}\n\n// PrivateKeyBundle bundles the private keys corresponding to a PublicKeyBundle for convenience.\n// This bundle must not be shared with anyone, although will have to be persisted\n// somehow so that older messages can be decrypted again.\nexport class PrivateKeyBundleV1 implements proto.PrivateKeyBundleV1 {\n  identityKey: PrivateKey\n  preKeys: PrivateKey[]\n  version = 1\n  private _publicKeyBundle?: PublicKeyBundle\n\n  constructor(bundle: proto.PrivateKeyBundleV1) {\n    if (!bundle.identityKey) {\n      throw new Error('missing identity key')\n    }\n    this.identityKey = new PrivateKey(bundle.identityKey)\n    this.preKeys = (bundle.preKeys || []).map((k) => new PrivateKey(k))\n  }\n\n  // Generate a new key bundle with the preKey signed byt the identityKey.\n  // Optionally sign the identityKey with the provided wallet as well.\n  static async generate(wallet?: Signer): Promise<PrivateKeyBundleV1> {\n    const identityKey = PrivateKey.generate()\n    if (wallet) {\n      await identityKey.publicKey.signWithWallet(wallet)\n    }\n    const bundle = new PrivateKeyBundleV1({\n      identityKey,\n      preKeys: [],\n    })\n    await bundle.addPreKey()\n    return bundle\n  }\n\n  // Return the current (latest) pre-key (to be advertised).\n  getCurrentPreKey(): PrivateKey {\n    return this.preKeys[0]\n  }\n\n  // Find pre-key matching the provided public key.\n  findPreKey(which: PublicKey): PrivateKey {\n    const preKey = this.preKeys.find((key) => key.matches(which))\n    if (!preKey) {\n      throw new NoMatchingPreKeyError(which)\n    }\n    return preKey\n  }\n\n  // Generate a new pre-key to be used as the current pre-key.\n  async addPreKey(): Promise<void> {\n    this._publicKeyBundle = undefined\n    const preKey = PrivateKey.generate()\n    await this.identityKey.signKey(preKey.publicKey)\n    this.preKeys.unshift(preKey)\n  }\n\n  // Return a key bundle with the current pre-key.\n  getPublicKeyBundle(): PublicKeyBundle {\n    if (!this._publicKeyBundle) {\n      this._publicKeyBundle = new PublicKeyBundle({\n        identityKey: this.identityKey.publicKey,\n        preKey: this.getCurrentPreKey().publicKey,\n      })\n    }\n    return this._publicKeyBundle\n  }\n\n  validatePublicKeys(): boolean {\n    if (!this.identityKey.validatePublicKey()) {\n      return false\n    }\n\n    return this.preKeys.every((key) => key.validatePublicKey())\n  }\n\n  // sharedSecret derives a secret from peer's key bundles using a variation of X3DH protocol\n  // where the sender's ephemeral key pair is replaced by the sender's pre-key.\n  // @peer is the peer's public key bundle\n  // @myPreKey indicates which of my preKeys should be used to derive the secret\n  // @recipient indicates if this is the sending or receiving side.\n  async sharedSecret(\n    peer: PublicKeyBundle | SignedPublicKeyBundle,\n    myPreKey: PublicKey,\n    isRecipient: boolean\n  ): Promise<Uint8Array> {\n    if (!peer.identityKey || !peer.preKey) {\n      throw new Error('invalid peer key bundle')\n    }\n    if (!(await peer.identityKey.verifyKey(peer.preKey))) {\n      throw new Error('peer preKey signature invalid')\n    }\n    if (!this.identityKey) {\n      throw new Error('missing identity key')\n    }\n    let dh1: Uint8Array, dh2: Uint8Array, preKey: PrivateKey\n    if (isRecipient) {\n      preKey = this.findPreKey(myPreKey)\n      dh1 = preKey.sharedSecret(peer.identityKey)\n      dh2 = this.identityKey.sharedSecret(peer.preKey)\n    } else {\n      preKey = this.findPreKey(myPreKey)\n      dh1 = this.identityKey.sharedSecret(peer.preKey)\n      dh2 = preKey.sharedSecret(peer.identityKey)\n    }\n    const dh3 = preKey.sharedSecret(peer.preKey)\n    const secret = new Uint8Array(dh1.length + dh2.length + dh3.length)\n    secret.set(dh1, 0)\n    secret.set(dh2, dh1.length)\n    secret.set(dh3, dh1.length + dh2.length)\n    return secret\n  }\n\n  encode(): Uint8Array {\n    return proto.PrivateKeyBundle.encode({\n      v1: this,\n      v2: undefined,\n    }).finish()\n  }\n}\n\nexport type PrivateKeyBundle = PrivateKeyBundleV1 | PrivateKeyBundleV2\n\nexport function decodePrivateKeyBundle(bytes: Uint8Array): PrivateKeyBundle {\n  const b = proto.PrivateKeyBundle.decode(bytes)\n  if (b.v1) {\n    return new PrivateKeyBundleV1(b.v1)\n  }\n  if (b.v2) {\n    return new PrivateKeyBundleV2(b.v2)\n  }\n  throw new Error('unknown private key bundle version')\n}\n","import { PublicKey, SignedPublicKey } from './PublicKey'\nimport { bytesToHex } from './utils'\n\nexport class NoMatchingPreKeyError extends Error {\n  constructor(preKey: PublicKey | SignedPublicKey) {\n    super(\n      `no pre-key matches: ${bytesToHex(preKey.secp256k1Uncompressed.bytes)}`\n    )\n  }\n}\n","import { ciphertext } from '@xmtp/proto'\nimport { sha256 } from './encryption'\nimport { PrivateKey, SignedPrivateKey } from './PrivateKey'\nimport { PublicKey, SignedPublicKey } from './PublicKey'\nimport Signature from './Signature'\n\nconst IV_LENGTH = 16\nconst EPHEMERAL_PUBLIC_KEY_LENGTH = 65\nconst MAC_LENGTH = 32\nconst AES_BLOCK_SIZE = 16\n\nconst assertEciesLengths = (\n  ecies: ciphertext.SignedEciesCiphertext_Ecies\n): void => {\n  if (ecies.iv.length !== IV_LENGTH) {\n    throw new Error('Invalid iv length')\n  }\n  if (ecies.ephemeralPublicKey.length !== EPHEMERAL_PUBLIC_KEY_LENGTH) {\n    throw new Error('Invalid ephemPublicKey length')\n  }\n  if (\n    ecies.ciphertext.length < 1 ||\n    ecies.ciphertext.length % AES_BLOCK_SIZE !== 0\n  ) {\n    throw new Error('Invalid ciphertext length')\n  }\n  if (ecies.mac.length !== MAC_LENGTH) {\n    throw new Error('Invalid mac length')\n  }\n}\n\nexport default class SignedEciesCiphertext\n  implements ciphertext.SignedEciesCiphertext\n{\n  eciesBytes: Uint8Array\n  signature: Signature\n  ciphertext: ciphertext.SignedEciesCiphertext_Ecies\n\n  constructor({ eciesBytes, signature }: ciphertext.SignedEciesCiphertext) {\n    if (!eciesBytes || !eciesBytes.length) {\n      throw new Error('eciesBytes is empty')\n    }\n    if (!signature) {\n      throw new Error('signature is undefined')\n    }\n    this.eciesBytes = eciesBytes\n    this.signature = new Signature(signature)\n    this.ciphertext = ciphertext.SignedEciesCiphertext_Ecies.decode(eciesBytes)\n  }\n\n  toBytes(): Uint8Array {\n    return ciphertext.SignedEciesCiphertext.encode(this).finish()\n  }\n\n  async verify(pubKey: PublicKey | SignedPublicKey): Promise<boolean> {\n    return pubKey.verify(this.signature, await sha256(this.eciesBytes))\n  }\n\n  static fromBytes(data: Uint8Array): SignedEciesCiphertext {\n    const obj = ciphertext.SignedEciesCiphertext.decode(data)\n\n    return new SignedEciesCiphertext(obj)\n  }\n\n  static async create(\n    ecies: ciphertext.SignedEciesCiphertext_Ecies,\n    signer: PrivateKey | SignedPrivateKey\n  ): Promise<SignedEciesCiphertext> {\n    assertEciesLengths(ecies)\n\n    const eciesBytes =\n      ciphertext.SignedEciesCiphertext_Ecies.encode(ecies).finish()\n    const signature = await signer.sign(await sha256(eciesBytes))\n\n    return new SignedEciesCiphertext({ eciesBytes, signature })\n  }\n}\n","import { Envelope } from '@xmtp/proto/ts/dist/types/message_api/v1/message_api.pb'\nimport { bytesToHex } from './crypto/utils'\nimport { sha256 } from './crypto/encryption'\n\nexport class PreparedMessage {\n  messageEnvelope: Envelope\n  onSend: () => Promise<void>\n\n  constructor(messageEnvelope: Envelope, onSend: () => Promise<void>) {\n    this.messageEnvelope = messageEnvelope\n    this.onSend = onSend\n  }\n\n  async messageID(): Promise<string> {\n    if (!this.messageEnvelope.message) {\n      throw new Error('no envelope message')\n    }\n\n    return bytesToHex(await sha256(this.messageEnvelope.message))\n  }\n\n  async send() {\n    await this.onSend()\n  }\n}\n","import { keystore } from '@xmtp/proto'\nimport { PublicKeyBundle } from '../crypto/PublicKeyBundle'\nimport { KeystoreError } from '../keystore/errors'\nimport { MessageV1 } from '../Message'\nimport { WithoutUndefined } from './typedefs'\n\n// Validates the Keystore response. Throws on errors or missing fields.\n// Returns a type with all possibly undefined fields required to be defined\nexport const getResultOrThrow = <\n  T extends\n    | keystore.DecryptResponse_Response\n    | keystore.EncryptResponse_Response\n>(\n  response: T\n): WithoutUndefined<NonNullable<T['result']>> => {\n  if (response.error) {\n    throw new KeystoreError(response.error.code, response.error.message)\n  }\n  if (!response.result) {\n    throw new KeystoreError(\n      keystore.ErrorCode.ERROR_CODE_UNSPECIFIED,\n      'No result from Keystore'\n    )\n  }\n\n  if ('encrypted' in response.result && !response.result.encrypted) {\n    throw new Error('Missing ciphertext')\n  }\n\n  if ('decrypted' in response.result && !response.result.decrypted) {\n    throw new Error('Missing decrypted result')\n  }\n\n  return response.result as unknown as WithoutUndefined<\n    NonNullable<T['result']>\n  >\n}\n\nexport const buildDecryptV1Request = (\n  messages: MessageV1[],\n  myPublicKeyBundle: PublicKeyBundle\n): keystore.DecryptV1Request => {\n  return {\n    requests: messages.map((m: MessageV1) => {\n      const sender = new PublicKeyBundle({\n        identityKey: m.header.sender?.identityKey,\n        preKey: m.header.sender?.preKey,\n      })\n\n      const isSender = myPublicKeyBundle.equals(sender)\n\n      return {\n        payload: m.ciphertext,\n        peerKeys: isSender\n          ? new PublicKeyBundle({\n              identityKey: m.header.recipient?.identityKey,\n              preKey: m.header.recipient?.preKey,\n            })\n          : sender,\n        headerBytes: m.headerBytes,\n        isSender,\n      }\n    }),\n  }\n}\n","import { keystore } from '@xmtp/proto'\n\nexport class KeystoreError extends Error implements keystore.KeystoreError {\n  code: keystore.ErrorCode\n\n  constructor(code: keystore.ErrorCode, message: string) {\n    super(message)\n    this.code = code\n  }\n}\n","import { content as proto } from '@xmtp/proto'\n\n// Represents proto.ContentTypeId\nexport class ContentTypeId {\n  authorityId: string\n  typeId: string\n  versionMajor: number\n  versionMinor: number\n\n  constructor(obj: proto.ContentTypeId) {\n    this.authorityId = obj.authorityId\n    this.typeId = obj.typeId\n    this.versionMajor = obj.versionMajor\n    this.versionMinor = obj.versionMinor\n  }\n\n  toString(): string {\n    return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`\n  }\n\n  static fromString(contentTypeString: string): ContentTypeId {\n    const [idString, versionString] = contentTypeString.split(':')\n    const [authorityId, typeId] = idString.split('/')\n    const [major, minor] = versionString.split('.')\n    return new ContentTypeId({\n      authorityId,\n      typeId,\n      versionMajor: Number(major),\n      versionMinor: Number(minor),\n    })\n  }\n\n  sameAs(id: ContentTypeId): boolean {\n    return this.authorityId === id.authorityId && this.typeId === id.typeId\n  }\n}\n\n// Represents proto.EncodedContent\nexport interface EncodedContent<Parameters = Record<string, string>> {\n  type: ContentTypeId\n  parameters: Parameters\n  fallback?: string\n  compression?: number\n  content: Uint8Array\n}\n\n// Define an interface for the encoding machinery for a specific content type\n// associated with a given ContentTypeId\n// A codec can be registered with a Client to be automatically invoked when\n// handling content of the corresponding content type.\nexport interface CodecRegistry {\n  // eslint-disable-next-line no-use-before-define, @typescript-eslint/no-explicit-any\n  codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined\n}\n\nexport interface ContentCodec<T> {\n  contentType: ContentTypeId\n  encode(content: T, registry: CodecRegistry): EncodedContent\n  decode(content: EncodedContent, registry: CodecRegistry): T\n  fallback(content: T): string | undefined\n}\n\n// xmtp.org/fallback\n//\n// This is not a real content type, it is used to signal to the recipient\n// that the content in the message is the fallback description (if present)\n// in case the original content type is not supported.\n// This content type MUST NOT be used to send content.\nexport const ContentTypeFallback = new ContentTypeId({\n  authorityId: 'xmtp.org',\n  typeId: 'fallback',\n  versionMajor: 1,\n  versionMinor: 0,\n})\n","import {\n  ContentTypeId,\n  ContentCodec,\n  EncodedContent,\n  CodecRegistry,\n} from '../MessageContent'\n\n// xmtp.org/text\n//\n// This content type is used for a plain text content represented by a simple string\nexport const ContentTypeText = new ContentTypeId({\n  authorityId: 'xmtp.org',\n  typeId: 'text',\n  versionMajor: 1,\n  versionMinor: 0,\n})\n\nexport enum Encoding {\n  utf8 = 'UTF-8',\n}\n\nexport class TextCodec implements ContentCodec<string> {\n  get contentType(): ContentTypeId {\n    return ContentTypeText\n  }\n\n  encode(content: string): EncodedContent {\n    return {\n      type: ContentTypeText,\n      parameters: { encoding: Encoding.utf8 },\n      content: new TextEncoder().encode(content),\n    }\n  }\n\n  decode(content: EncodedContent): string {\n    const encoding = content.parameters.encoding\n    if (encoding && encoding !== Encoding.utf8) {\n      throw new Error(`unrecognized encoding ${encoding}`)\n    }\n    return new TextDecoder().decode(content.content)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  fallback(content: string): string | undefined {\n    return undefined\n  }\n}\n","import {\n  Conversation,\n  ConversationV1,\n  ConversationV2,\n} from './conversations/Conversation'\nimport type Client from './Client'\nimport { message as proto, conversationReference } from '@xmtp/proto'\nimport Long from 'long'\nimport Ciphertext from './crypto/Ciphertext'\nimport { PublicKeyBundle, PublicKey } from './crypto'\nimport { bytesToHex } from './crypto/utils'\nimport { sha256 } from './crypto/encryption'\nimport { ContentTypeId } from './MessageContent'\nimport { dateToNs, nsToDate } from './utils'\nimport { Keystore } from './keystore'\nimport { buildDecryptV1Request, getResultOrThrow } from './utils/keystore'\n\nconst headerBytesAndCiphertext = (\n  msg: proto.Message\n): [Uint8Array, Ciphertext] => {\n  if (msg.v1?.ciphertext) {\n    return [msg.v1.headerBytes, new Ciphertext(msg.v1.ciphertext)]\n  }\n  if (msg.v2?.ciphertext) {\n    return [msg.v2.headerBytes, new Ciphertext(msg.v2.ciphertext)]\n  }\n  throw new Error('unknown message version')\n}\n\n// Message is basic unit of communication on the network.\n// Message timestamp is set by the sender.\nclass MessageBase {\n  headerBytes: Uint8Array // encoded header bytes\n  ciphertext: Ciphertext\n  // content allows attaching decoded content to the Message\n  // the message receiving APIs need to return a Message to provide access to the header fields like sender/recipient\n  contentType?: ContentTypeId\n  error?: Error\n  /**\n   * Identifier that is deterministically derived from the bytes of the message\n   * header and ciphertext, where all those bytes are authenticated. This can\n   * be used in determining uniqueness of messages.\n   */\n  id: string\n  private bytes: Uint8Array\n\n  constructor(id: string, bytes: Uint8Array, obj: proto.Message) {\n    ;[this.headerBytes, this.ciphertext] = headerBytesAndCiphertext(obj)\n    this.id = id\n    this.bytes = bytes\n  }\n\n  toBytes(): Uint8Array {\n    return this.bytes\n  }\n}\n\n// Message header carries the sender and recipient keys used to protect message.\n// Message timestamp is set by the sender.\nexport class MessageV1 extends MessageBase implements proto.MessageV1 {\n  header: proto.MessageHeaderV1 // eslint-disable-line camelcase\n  // wallet address derived from the signature of the message recipient\n  senderAddress: string | undefined\n  conversation = undefined\n\n  constructor(\n    id: string,\n    bytes: Uint8Array,\n    obj: proto.Message,\n    header: proto.MessageHeaderV1,\n    senderAddress: string | undefined\n  ) {\n    super(id, bytes, obj)\n    this.senderAddress = senderAddress\n    this.header = header\n  }\n\n  static async create(\n    obj: proto.Message,\n    header: proto.MessageHeaderV1,\n    bytes: Uint8Array\n  ): Promise<MessageV1> {\n    if (!header.sender) {\n      throw new Error('missing message sender')\n    }\n    const senderAddress = new PublicKeyBundle(\n      header.sender\n    ).walletSignatureAddress()\n    const id = bytesToHex(await sha256(bytes))\n    return new MessageV1(id, bytes, obj, header, senderAddress)\n  }\n\n  get sent(): Date {\n    return new Date(this.header.timestamp.toNumber())\n  }\n\n  // wallet address derived from the signature of the message recipient\n  get recipientAddress(): string | undefined {\n    if (!this.header?.recipient?.identityKey) {\n      return undefined\n    }\n    return new PublicKey(\n      this.header.recipient.identityKey\n    ).walletSignatureAddress()\n  }\n\n  async decrypt(\n    keystore: Keystore,\n    myPublicKeyBundle: PublicKeyBundle\n  ): Promise<Uint8Array> {\n    const responses = (\n      await keystore.decryptV1(buildDecryptV1Request([this], myPublicKeyBundle))\n    ).responses\n\n    if (!responses.length) {\n      throw new Error('No response from Keystore')\n    }\n\n    const { decrypted } = getResultOrThrow(responses[0])\n\n    return decrypted\n  }\n\n  static fromBytes(bytes: Uint8Array): Promise<MessageV1> {\n    const message = proto.Message.decode(bytes)\n    const [headerBytes] = headerBytesAndCiphertext(message)\n    const header = proto.MessageHeaderV1.decode(headerBytes)\n    if (!header) {\n      throw new Error('missing message header')\n    }\n    if (!header.sender) {\n      throw new Error('missing message sender')\n    }\n    if (!header.sender.identityKey) {\n      throw new Error('missing message sender identity key')\n    }\n    if (!header.sender.preKey) {\n      throw new Error('missing message sender pre-key')\n    }\n    if (!header.recipient) {\n      throw new Error('missing message recipient')\n    }\n    if (!header.recipient.identityKey) {\n      throw new Error('missing message recipient identity-key')\n    }\n    if (!header.recipient.preKey) {\n      throw new Error('missing message recipient pre-key')\n    }\n\n    return MessageV1.create(message, header, bytes)\n  }\n\n  static async encode(\n    keystore: Keystore,\n    payload: Uint8Array,\n    sender: PublicKeyBundle,\n    recipient: PublicKeyBundle,\n    timestamp: Date\n  ): Promise<MessageV1> {\n    const header: proto.MessageHeaderV1 = {\n      sender,\n      recipient,\n      timestamp: Long.fromNumber(timestamp.getTime()),\n    }\n    const headerBytes = proto.MessageHeaderV1.encode(header).finish()\n    const results = await keystore.encryptV1({\n      requests: [\n        {\n          recipient,\n          headerBytes,\n          payload,\n        },\n      ],\n    })\n\n    if (!results.responses.length) {\n      throw new Error('No response from Keystore')\n    }\n\n    const { encrypted: ciphertext } = getResultOrThrow(results.responses[0])\n\n    const protoMsg = {\n      v1: { headerBytes, ciphertext },\n      v2: undefined,\n    }\n    const bytes = proto.Message.encode(protoMsg).finish()\n    return MessageV1.create(protoMsg, header, bytes)\n  }\n}\n\nexport class MessageV2 extends MessageBase implements proto.MessageV2 {\n  senderAddress: string | undefined\n  private header: proto.MessageHeaderV2 // eslint-disable-line camelcase\n\n  constructor(\n    id: string,\n    bytes: Uint8Array,\n    obj: proto.Message,\n    header: proto.MessageHeaderV2\n  ) {\n    super(id, bytes, obj)\n    this.header = header\n  }\n\n  static async create(\n    obj: proto.Message,\n    header: proto.MessageHeaderV2,\n    bytes: Uint8Array\n  ): Promise<MessageV2> {\n    const id = bytesToHex(await sha256(bytes))\n\n    return new MessageV2(id, bytes, obj, header)\n  }\n\n  get sent(): Date {\n    return nsToDate(this.header.createdNs)\n  }\n}\n\nexport type Message = MessageV1 | MessageV2\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class DecodedMessage<ContentTypes = any> {\n  id: string\n  messageVersion: 'v1' | 'v2'\n  senderAddress: string\n  recipientAddress?: string\n  sent: Date\n  contentTopic: string\n  conversation: Conversation<ContentTypes>\n  contentType: ContentTypeId\n  content: ContentTypes\n  error?: Error\n  contentBytes: Uint8Array\n  contentFallback?: string\n\n  constructor({\n    id,\n    messageVersion,\n    senderAddress,\n    recipientAddress,\n    conversation,\n    contentBytes,\n    contentType,\n    contentTopic,\n    content,\n    sent,\n    error,\n    contentFallback,\n  }: Omit<DecodedMessage<ContentTypes>, 'toBytes'>) {\n    this.id = id\n    this.messageVersion = messageVersion\n    this.senderAddress = senderAddress\n    this.recipientAddress = recipientAddress\n    this.conversation = conversation\n    this.contentType = contentType\n    this.sent = sent\n    this.error = error\n    this.content = content\n    this.contentTopic = contentTopic\n    this.contentBytes = contentBytes\n    this.contentFallback = contentFallback\n  }\n\n  toBytes(): Uint8Array {\n    return proto.DecodedMessage.encode({\n      ...this,\n      conversation: {\n        topic: this.conversation.topic,\n        context: this.conversation.context ?? undefined,\n        createdNs: dateToNs(this.conversation.createdAt),\n        peerAddress: this.conversation.peerAddress,\n      },\n      sentNs: dateToNs(this.sent),\n    }).finish()\n  }\n\n  static async fromBytes<ContentTypes>(\n    data: Uint8Array,\n    client: Client<ContentTypes>\n  ): Promise<DecodedMessage<ContentTypes>> {\n    const protoVal = proto.DecodedMessage.decode(data)\n    const messageVersion = protoVal.messageVersion\n\n    if (messageVersion !== 'v1' && messageVersion !== 'v2') {\n      throw new Error('Invalid message version')\n    }\n\n    if (!protoVal.conversation) {\n      throw new Error('No conversation reference found')\n    }\n\n    const { content, contentType, error, contentFallback } =\n      await client.decodeContent(protoVal.contentBytes)\n\n    return new DecodedMessage({\n      ...protoVal,\n      content,\n      contentType,\n      error,\n      messageVersion,\n      sent: nsToDate(protoVal.sentNs),\n      conversation: conversationReferenceToConversation(\n        protoVal.conversation,\n        client,\n        messageVersion\n      ),\n      contentFallback,\n    })\n  }\n\n  static fromV1Message<ContentTypes>(\n    message: MessageV1,\n    content: ContentTypes,\n    contentType: ContentTypeId,\n    contentBytes: Uint8Array,\n    contentTopic: string,\n    conversation: Conversation<ContentTypes>,\n    error?: Error,\n    contentFallback?: string\n  ): DecodedMessage<ContentTypes> {\n    const { id, senderAddress, recipientAddress, sent } = message\n    if (!senderAddress) {\n      throw new Error('Sender address is required')\n    }\n    return new DecodedMessage({\n      id,\n      messageVersion: 'v1',\n      senderAddress,\n      recipientAddress,\n      sent,\n      content,\n      contentBytes,\n      contentType,\n      contentTopic,\n      conversation,\n      error,\n      contentFallback,\n    })\n  }\n\n  static fromV2Message<ContentTypes>(\n    message: MessageV2,\n    content: ContentTypes,\n    contentType: ContentTypeId,\n    contentTopic: string,\n    contentBytes: Uint8Array,\n    conversation: Conversation<ContentTypes>,\n    senderAddress: string,\n    error?: Error,\n    contentFallback?: string\n  ): DecodedMessage<ContentTypes> {\n    const { id, sent } = message\n\n    return new DecodedMessage({\n      id,\n      messageVersion: 'v2',\n      senderAddress,\n      sent,\n      content,\n      contentBytes,\n      contentType,\n      contentTopic,\n      conversation,\n      error,\n      contentFallback,\n    })\n  }\n}\n\nfunction conversationReferenceToConversation<ContentTypes>(\n  reference: conversationReference.ConversationReference,\n  client: Client<ContentTypes>,\n  version: DecodedMessage['messageVersion']\n): Conversation<ContentTypes> {\n  if (version === 'v1') {\n    return new ConversationV1(\n      client,\n      reference.peerAddress,\n      nsToDate(reference.createdNs)\n    )\n  }\n  if (version === 'v2') {\n    return new ConversationV2(\n      client,\n      reference.topic,\n      reference.peerAddress,\n      nsToDate(reference.createdNs),\n      reference.context\n    )\n  }\n  throw new Error(`Unknown conversation version ${version}`)\n}\n\nexport function decodeContent<ContentTypes>(\n  contentBytes: Uint8Array,\n  client: Client<ContentTypes>\n) {\n  return client.decodeContent(contentBytes)\n}\n","import { PrivateKeyBundleV1 } from './crypto/PrivateKeyBundle'\nimport { PublicKeyBundle, SignedPublicKeyBundle } from './crypto'\nimport {\n  buildUserContactTopic,\n  mapPaginatedStream,\n  EnvelopeMapper,\n  buildUserInviteTopic,\n  isBrowser,\n} from './utils'\nimport { utils } from 'ethers'\nimport { Signer } from './types/Signer'\nimport { Conversations } from './conversations'\nimport { ContentTypeText, TextCodec } from './codecs/Text'\nimport { ContentTypeId, ContentCodec, EncodedContent } from './MessageContent'\nimport { compress, decompress } from './Compression'\nimport { content as proto, messageApi } from '@xmtp/proto'\nimport { decodeContactBundle, encodeContactBundle } from './ContactBundle'\nimport HttpApiClient, {\n  ApiUrls,\n  ApiClient,\n  PublishParams,\n  SortDirection,\n} from './ApiClient'\nimport { KeystoreAuthenticator } from './authn'\nimport { Flatten } from './utils/typedefs'\nimport BackupClient, { BackupType } from './message-backup/BackupClient'\nimport { createBackupClient } from './message-backup/BackupClientFactory'\nimport { Keystore } from './keystore'\nimport {\n  KeyGeneratorKeystoreProvider,\n  KeystoreProvider,\n  KeystoreProviderUnavailableError,\n  NetworkKeystoreProvider,\n  SnapProvider,\n  StaticKeystoreProvider,\n} from './keystore/providers'\nimport {\n  BrowserStoragePersistence,\n  InMemoryPersistence,\n  Persistence,\n} from './keystore/persistence'\nimport { hasMetamaskWithSnaps } from './keystore/snapHelpers'\nimport { version as snapVersion, package as snapPackage } from './snapInfo.json'\nimport { ExtractDecodedType } from './types/client'\nconst { Compression } = proto\n\n// eslint-disable @typescript-eslint/explicit-module-boundary-types\n// eslint-disable @typescript-eslint/no-explicit-any\n\n// Default maximum allowed content size\nconst MaxContentSize = 100 * 1024 * 1024 // 100M\n\n// Parameters for the listMessages functions\nexport type ListMessagesOptions = {\n  checkAddresses?: boolean\n  startTime?: Date\n  endTime?: Date\n  limit?: number\n  direction?: messageApi.SortDirection\n}\n\nexport type ListMessagesPaginatedOptions = {\n  startTime?: Date\n  endTime?: Date\n  pageSize?: number\n  direction?: messageApi.SortDirection\n}\n\n// Parameters for the send functions\nexport type SendOptions = {\n  contentType?: ContentTypeId\n  compression?: proto.Compression\n  timestamp?: Date\n  ephemeral?: boolean\n}\n\nexport { Compression }\n\nexport type XmtpEnv = keyof typeof ApiUrls\nexport type PreEventCallback = () => Promise<void>\n\n/**\n * Network startup options\n */\nexport type NetworkOptions = {\n  /**\n   * Specify which XMTP environment to connect to. (default: `dev`)\n   */\n  env: XmtpEnv\n  /**\n   * apiUrl can be used to override the `env` flag and connect to a\n   * specific endpoint\n   */\n  apiUrl: string | undefined\n  /**\n   * identifier that's included with API requests.\n   *\n   * For example, you can use the following format:\n   * `appVersion: APP_NAME + '/' + APP_VERSION`.\n   * Setting this value provides telemetry that shows which apps are\n   * using the XMTP client SDK. This information can help XMTP developers\n   * provide app support, especially around communicating important\n   * SDK updates, including deprecations and required upgrades.\n   */\n  appVersion?: string\n  /**\n   * Skip publishing the user's contact bundle as part of Client startup.\n   *\n   * This flag should be used with caution, as we rely on contact publishing to\n   * let other users know your public key and periodically run migrations on\n   * this data with new SDK versions.\n   *\n   * Your application should have this flag set to `false` at least _some_ of the\n   * time.\n   *\n   * The most common use-case for setting this to `true` is cases where the Client\n   * instance is very short-lived. For example, spinning up a Client to decrypt\n   * a push notification.\n   */\n  skipContactPublishing: boolean\n\n  apiClientFactory: (options: NetworkOptions) => ApiClient\n}\n\nexport type ContentOptions = {\n  /**\n   * Allow configuring codecs for additional content types\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  codecs: ContentCodec<any>[]\n\n  /**\n   * Set the maximum content size in bytes that is allowed by the Client.\n   * Currently only checked when decompressing compressed content.\n   */\n  maxContentSize: number\n}\n\nexport type KeyStoreOptions = {\n  /**\n   * Provide an array of KeystoreProviders.\n   * The client will attempt to use each one in sequence until one successfully\n   * returns a Keystore instance\n   */\n  keystoreProviders: KeystoreProvider[]\n  /**\n   * Enable the Keystore to persist conversations in the provided storage interface\n   */\n  persistConversations: boolean\n  /**\n   * Provide a XMTP PrivateKeyBundle encoded as a Uint8Array.\n   * A bundle can be retried using `Client.getKeys(...)`\n   */\n  privateKeyOverride?: Uint8Array\n\n  /**\n   * Override the base persistence provider.\n   * Defaults to LocalStoragePersistence, which is fine for most implementations\n   */\n  basePersistence: Persistence\n  /**\n   * Whether or not the persistence provider should encrypt the values.\n   * Only disable if you are using a secure datastore that already has encryption\n   */\n  disablePersistenceEncryption: boolean\n  /**\n   * A single option to allow Metamask Snaps to be used as a keystore provider\n   */\n  useSnaps: boolean\n}\n\nexport type LegacyOptions = {\n  publishLegacyContact?: boolean\n}\n\nexport type PreEventCallbackOptions = {\n  /**\n   * preCreateIdentityCallback will be called immediately before a Create Identity\n   * wallet signature is requested from the user.\n   *\n   * The provided function must return a Promise and will be awaited, allowing the\n   * developer to update the UI or insert a required delay before requesting a signature.\n   */\n  preCreateIdentityCallback?: PreEventCallback\n  /**\n   * preEnableIdentityCallback will be called immediately before an Enable Identity\n   * wallet signature is requested from the user.\n   *\n   * The provided function must return a Promise and will be awaited, allowing the\n   * developer to update the UI or insert a required delay before requesting a signature.\n   */\n  preEnableIdentityCallback?: PreEventCallback\n}\n\n/**\n * Aggregate type for client options. Optional properties are used when the default value is calculated on invocation, and are computed\n * as needed by each function. All other defaults are specified in defaultOptions.\n */\nexport type ClientOptions = Flatten<\n  NetworkOptions &\n    KeyStoreOptions &\n    ContentOptions &\n    LegacyOptions &\n    PreEventCallbackOptions\n>\n\n/**\n * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations\n *\n * @param opts additional options to override the default settings\n */\nexport function defaultOptions(opts?: Partial<ClientOptions>): ClientOptions {\n  const _defaultOptions: ClientOptions = {\n    privateKeyOverride: undefined,\n    env: 'dev',\n    apiUrl: undefined,\n    codecs: [new TextCodec()],\n    maxContentSize: MaxContentSize,\n    persistConversations: true,\n    skipContactPublishing: false,\n    useSnaps: false,\n    basePersistence: isBrowser()\n      ? BrowserStoragePersistence.create()\n      : InMemoryPersistence.create(),\n    disablePersistenceEncryption: false,\n    keystoreProviders: defaultKeystoreProviders(),\n    apiClientFactory: createHttpApiClientFromOptions,\n  }\n\n  if (opts?.codecs) {\n    opts.codecs = _defaultOptions.codecs.concat(opts.codecs)\n  }\n\n  if (opts?.useSnaps) {\n    opts.keystoreProviders = [\n      new SnapProvider(`npm:${snapPackage}`, snapVersion),\n      ..._defaultOptions.keystoreProviders,\n    ]\n  }\n\n  return { ..._defaultOptions, ...opts } as ClientOptions\n}\n\n/**\n * Client class initiates connection to the XMTP network.\n * Should be created with `await Client.create(options)`\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default class Client<ContentTypes = any> {\n  address: string\n  keystore: Keystore\n  apiClient: ApiClient\n  contacts: Set<string> // address which we have connected to\n  publicKeyBundle: PublicKeyBundle\n  private knownPublicKeyBundles: Map<\n    string,\n    PublicKeyBundle | SignedPublicKeyBundle\n  > // addresses and key bundles that we have witnessed\n\n  private _backupClient: BackupClient\n  private readonly _conversations: Conversations<ContentTypes>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _codecs: Map<string, ContentCodec<any>>\n  private _maxContentSize: number\n\n  constructor(\n    publicKeyBundle: PublicKeyBundle,\n    apiClient: ApiClient,\n    backupClient: BackupClient,\n    keystore: Keystore\n  ) {\n    this.contacts = new Set<string>()\n    this.knownPublicKeyBundles = new Map<\n      string,\n      PublicKeyBundle | SignedPublicKeyBundle\n    >()\n    // TODO: Remove keys and legacyKeys\n    this.keystore = keystore\n    this.publicKeyBundle = publicKeyBundle\n    this.address = publicKeyBundle.walletSignatureAddress()\n    this._conversations = new Conversations(this)\n    this._codecs = new Map()\n    this._maxContentSize = MaxContentSize\n    this.apiClient = apiClient\n    this._backupClient = backupClient\n  }\n\n  /**\n   * @type {Conversations}\n   */\n  get conversations(): Conversations<ContentTypes> {\n    return this._conversations\n  }\n\n  get backupType(): BackupType {\n    return this._backupClient.backupType\n  }\n\n  get signedPublicKeyBundle(): SignedPublicKeyBundle {\n    return SignedPublicKeyBundle.fromLegacyBundle(this.publicKeyBundle)\n  }\n\n  /**\n   * Create and start a client associated with given wallet.\n   *\n   * @param wallet the wallet as a Signer instance\n   * @param opts specify how to to connect to the network\n   */\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static async create<ContentCodecs extends ContentCodec<any>[] = []>(\n    wallet: Signer | null,\n    opts?: Partial<ClientOptions> & { codecs?: ContentCodecs }\n  ): Promise<\n    Client<\n      ExtractDecodedType<[...ContentCodecs, TextCodec][number]> | undefined\n    >\n  > {\n    const options = defaultOptions(opts)\n    const apiClient = options.apiClientFactory(options)\n    const keystore = await bootstrapKeystore(options, apiClient, wallet)\n    const publicKeyBundle = new PublicKeyBundle(\n      await keystore.getPublicKeyBundle()\n    )\n    const address = publicKeyBundle.walletSignatureAddress()\n    apiClient.setAuthenticator(new KeystoreAuthenticator(keystore))\n    const backupClient = await Client.setupBackupClient(address, options.env)\n    const client = new Client<\n      ExtractDecodedType<[...ContentCodecs, TextCodec][number]> | undefined\n    >(publicKeyBundle, apiClient, backupClient, keystore)\n    await client.init(options)\n    return client\n  }\n\n  /**\n   * Export the XMTP PrivateKeyBundle from the SDK as a `Uint8Array`.\n   *\n   * This bundle can then be provided as `privateKeyOverride` in a\n   * subsequent call to `Client.create(...)`\n   *\n   * Be very careful with these keys, as they can be used to\n   * impersonate a user on the XMTP network and read the user's\n   * messages.\n   */\n  static async getKeys<U>(\n    wallet: Signer | null,\n    opts?: Partial<ClientOptions> & { codecs?: U }\n  ): Promise<Uint8Array> {\n    const client = await Client.create(wallet, opts)\n    const keys = await client.keystore.getPrivateKeyBundle()\n    return new PrivateKeyBundleV1(keys).encode()\n  }\n\n  /**\n   * Tells the caller whether the browser has a Snaps-compatible version of MetaMask installed\n   */\n  static isSnapsReady() {\n    return hasMetamaskWithSnaps()\n  }\n\n  private static async setupBackupClient(\n    walletAddress: string,\n    env: keyof typeof ApiUrls\n  ): Promise<BackupClient> {\n    // Hard-code the provider to use for now\n    const selectBackupProvider = async () => {\n      return Promise.resolve({\n        type: env === 'local' ? BackupType.xmtpTopicStore : BackupType.none,\n      })\n    }\n    return createBackupClient(walletAddress, selectBackupProvider)\n  }\n\n  private async init(options: ClientOptions): Promise<void> {\n    options.codecs.forEach((codec) => {\n      this.registerCodec(codec)\n    })\n    this._maxContentSize = options.maxContentSize\n    if (!options.skipContactPublishing) {\n      await this.ensureUserContactPublished(options.publishLegacyContact)\n    }\n  }\n\n  // gracefully shut down the client\n  async close(): Promise<void> {\n    return undefined\n  }\n\n  private async ensureUserContactPublished(legacy = false): Promise<void> {\n    const bundle = await getUserContactFromNetwork(this.apiClient, this.address)\n    if (\n      bundle &&\n      bundle instanceof SignedPublicKeyBundle &&\n      this.signedPublicKeyBundle.equals(bundle)\n    ) {\n      return\n    }\n    // TEMPORARY: publish V1 contact to make sure there is one in the topic\n    // in order to preserve compatibility with pre-v7 clients.\n    // Remove when pre-v7 clients are deprecated\n    await this.publishUserContact(true)\n    if (!legacy) {\n      await this.publishUserContact(legacy)\n    }\n  }\n\n  // PRIVATE: publish the key bundle into the contact topic\n  // left public for testing purposes\n  async publishUserContact(legacy = false): Promise<void> {\n    const bundle = legacy ? this.publicKeyBundle : this.signedPublicKeyBundle\n    await this.publishEnvelopes([\n      {\n        contentTopic: buildUserContactTopic(this.address),\n        message: encodeContactBundle(bundle),\n      },\n    ])\n  }\n\n  /**\n   * Returns the cached PublicKeyBundle if one is known for the given address or fetches\n   * one from the network\n   *\n   * This throws if either the address is invalid or the contact is not published.\n   * See also [#canMessage].\n   */\n  async getUserContact(\n    peerAddress: string\n  ): Promise<PublicKeyBundle | SignedPublicKeyBundle | undefined> {\n    peerAddress = utils.getAddress(peerAddress) // EIP55 normalize the address case.\n    const existingBundle = this.knownPublicKeyBundles.get(peerAddress)\n    if (existingBundle) {\n      return existingBundle\n    }\n\n    const newBundle = await getUserContactFromNetwork(\n      this.apiClient,\n      peerAddress\n    )\n\n    if (newBundle) {\n      this.knownPublicKeyBundles.set(peerAddress, newBundle)\n    }\n\n    return newBundle\n  }\n\n  /**\n   * Identical to getUserContact but for multiple peer addresses\n   */\n  async getUserContacts(\n    peerAddresses: string[]\n  ): Promise<(PublicKeyBundle | SignedPublicKeyBundle | undefined)[]> {\n    // EIP55 normalize all peer addresses\n    const normalizedAddresses = peerAddresses.map((address) =>\n      utils.getAddress(address)\n    )\n    // The logic here is tricky because we need to do a batch query for any uncached bundles,\n    // then interleave back into an ordered array. So we create a map<string, keybundle|undefined>\n    // and fill it with cached values, then take any undefined entries and form a BatchQuery from those.\n    const addressToBundle = new Map<\n      string,\n      PublicKeyBundle | SignedPublicKeyBundle | undefined\n    >()\n    const uncachedAddresses = []\n    for (const address of normalizedAddresses) {\n      const existingBundle = this.knownPublicKeyBundles.get(address)\n      if (existingBundle) {\n        addressToBundle.set(address, existingBundle)\n      } else {\n        addressToBundle.set(address, undefined)\n        uncachedAddresses.push(address)\n      }\n    }\n\n    // Now do a getUserContactsFromNetwork call\n    const newBundles = await getUserContactsFromNetwork(\n      this.apiClient,\n      uncachedAddresses\n    )\n\n    // Now merge the newBundles into the addressToBundle map\n    for (let i = 0; i < newBundles.length; i++) {\n      const address = uncachedAddresses[i]\n      const bundle = newBundles[i]\n      addressToBundle.set(address, bundle)\n      // If the bundle is not undefined, cache it\n      if (bundle) {\n        this.knownPublicKeyBundles.set(address, bundle)\n      }\n    }\n\n    // Finally return the bundles in the same order as the input addresses\n    return normalizedAddresses.map((address) => addressToBundle.get(address))\n  }\n\n  /**\n   * Used to force getUserContact fetch contact from the network.\n   */\n  forgetContact(peerAddress: string) {\n    peerAddress = utils.getAddress(peerAddress) // EIP55 normalize the address case.\n    this.knownPublicKeyBundles.delete(peerAddress)\n  }\n\n  public async canMessage(peerAddress: string): Promise<boolean>\n  public async canMessage(peerAddress: string[]): Promise<boolean[]>\n\n  /**\n   * Check if @peerAddress can be messaged, specifically\n   * it checks that a PublicKeyBundle can be found for the given address\n   */\n  public async canMessage(\n    peerAddress: string | string[]\n  ): Promise<boolean | boolean[]> {\n    try {\n      if (Array.isArray(peerAddress)) {\n        const contacts = await this.getUserContacts(peerAddress)\n        return contacts.map((contact) => !!contact)\n      }\n      // Else do the single address case\n      const keyBundle = await this.getUserContact(peerAddress)\n      return keyBundle !== undefined\n    } catch (e) {\n      // Instead of throwing, a bad address should just return false.\n      return false\n    }\n  }\n\n  static async canMessage(\n    peerAddress: string,\n    opts?: Partial<NetworkOptions>\n  ): Promise<boolean>\n\n  static async canMessage(\n    peerAddress: string[],\n    opts?: Partial<NetworkOptions>\n  ): Promise<boolean[]>\n\n  static async canMessage(\n    peerAddress: string | string[],\n    opts?: Partial<NetworkOptions>\n  ): Promise<boolean | boolean[]> {\n    const apiUrl = opts?.apiUrl || ApiUrls[opts?.env || 'dev']\n    const apiClient = new HttpApiClient(apiUrl, {\n      appVersion: opts?.appVersion,\n    })\n\n    if (Array.isArray(peerAddress)) {\n      const rawPeerAddresses: string[] = peerAddress\n      // Try to normalize each of the peer addresses\n      const normalizedPeerAddresses = rawPeerAddresses.map((address) =>\n        utils.getAddress(address)\n      )\n      // The getUserContactsFromNetwork will return false instead of throwing\n      // on invalid envelopes\n      const contacts = await getUserContactsFromNetwork(\n        apiClient,\n        normalizedPeerAddresses\n      )\n      return contacts.map((contact) => !!contact)\n    }\n    try {\n      peerAddress = utils.getAddress(peerAddress) // EIP55 normalize the address case.\n    } catch (e) {\n      return false\n    }\n    const keyBundle = await getUserContactFromNetwork(apiClient, peerAddress)\n    return keyBundle !== undefined\n  }\n\n  private validateEnvelope(env: PublishParams): void {\n    const bytes = env.message\n    if (!env.contentTopic) {\n      throw new Error('Missing content topic')\n    }\n\n    if (!bytes || !bytes.length) {\n      throw new Error('Cannot publish empty message')\n    }\n  }\n\n  /**\n   * Low level method for publishing envelopes to the XMTP network with\n   * no pre-processing or encryption applied.\n   *\n   * Primarily used internally\n   *\n   * @param envelopes PublishParams[]\n   */\n  async publishEnvelopes(envelopes: PublishParams[]): Promise<void> {\n    for (const env of envelopes) {\n      this.validateEnvelope(env)\n    }\n\n    await this.apiClient.publish(envelopes)\n  }\n\n  /**\n   * Register a codec to be automatically used for encoding/decoding\n   * messages of the given Content Type\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  registerCodec<Codec extends ContentCodec<any>>(\n    codec: Codec\n  ): Client<ContentTypes | ExtractDecodedType<Codec>> {\n    const id = codec.contentType\n    const key = `${id.authorityId}/${id.typeId}`\n    this._codecs.set(key, codec)\n    return this\n  }\n\n  /**\n   * Find a matching codec for a given `ContentTypeId` from the\n   * client's codec registry\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined {\n    const key = `${contentType.authorityId}/${contentType.typeId}`\n    const codec = this._codecs.get(key)\n    if (!codec) {\n      return undefined\n    }\n    if (contentType.versionMajor > codec.contentType.versionMajor) {\n      return undefined\n    }\n    return codec\n  }\n\n  /**\n   * Convert arbitrary content into a serialized `EncodedContent` instance\n   * with the given options\n   */\n  async encodeContent(\n    content: ContentTypes,\n    options?: SendOptions\n  ): Promise<Uint8Array> {\n    const contentType = options?.contentType || ContentTypeText\n    const codec = this.codecFor(contentType)\n    if (!codec) {\n      throw new Error('unknown content type ' + contentType)\n    }\n    const encoded = codec.encode(content, this)\n\n    const fallback = codec.fallback(content)\n    if (fallback) {\n      encoded.fallback = fallback\n    }\n    if (typeof options?.compression === 'number') {\n      encoded.compression = options.compression\n    }\n    await compress(encoded)\n    return proto.EncodedContent.encode(encoded).finish()\n  }\n\n  async decodeContent(contentBytes: Uint8Array): Promise<{\n    content: ContentTypes\n    contentType: ContentTypeId\n    error?: Error\n    contentFallback?: string\n  }> {\n    const encodedContent = proto.EncodedContent.decode(contentBytes)\n\n    if (!encodedContent.type) {\n      throw new Error('missing content type')\n    }\n\n    let content: any // eslint-disable-line @typescript-eslint/no-explicit-any\n    const contentType = new ContentTypeId(encodedContent.type)\n    let error: Error | undefined\n\n    await decompress(encodedContent, 1000)\n\n    const codec = this.codecFor(contentType)\n    if (codec) {\n      content = codec.decode(encodedContent as EncodedContent, this)\n    } else {\n      error = new Error('unknown content type ' + contentType)\n    }\n\n    return {\n      content,\n      contentType,\n      error,\n      contentFallback: encodedContent.fallback,\n    }\n  }\n\n  listInvitations(opts?: ListMessagesOptions): Promise<messageApi.Envelope[]> {\n    return this.listEnvelopes(\n      buildUserInviteTopic(this.address),\n      async (env) => env,\n      opts\n    )\n  }\n\n  /**\n   * List stored messages from the specified topic.\n   *\n   * A specified mapper function will be applied to each envelope.\n   * If the mapper function throws an error during processing, the\n   * envelope will be discarded.\n   */\n  async listEnvelopes<Out>(\n    topic: string,\n    mapper: EnvelopeMapper<Out>,\n    opts?: ListMessagesOptions\n  ): Promise<Out[]> {\n    if (!opts) {\n      opts = {}\n    }\n    const { startTime, endTime, limit } = opts\n\n    const envelopes = await this.apiClient.query(\n      { contentTopic: topic, startTime, endTime },\n      {\n        direction:\n          opts.direction || messageApi.SortDirection.SORT_DIRECTION_ASCENDING,\n        limit,\n      }\n    )\n    const results: Out[] = []\n    for (const env of envelopes) {\n      if (!env.message) continue\n      try {\n        const res = await mapper(env)\n        results.push(res)\n      } catch (e) {\n        console.warn('Error in listEnvelopes mapper', e)\n      }\n    }\n    return results\n  }\n\n  /**\n   * List messages on a given set of content topics, yielding one page at a time\n   */\n  listEnvelopesPaginated<Out>(\n    contentTopic: string,\n    mapper: EnvelopeMapper<Out>,\n    opts?: ListMessagesPaginatedOptions\n  ): AsyncGenerator<Out[]> {\n    return mapPaginatedStream(\n      this.apiClient.queryIteratePages(\n        {\n          contentTopic,\n          startTime: opts?.startTime,\n          endTime: opts?.endTime,\n        },\n        { direction: opts?.direction, pageSize: opts?.pageSize || 100 }\n      ),\n      mapper\n    )\n  }\n}\n\nfunction createHttpApiClientFromOptions(options: NetworkOptions): ApiClient {\n  const apiUrl = options.apiUrl || ApiUrls[options.env]\n  return new HttpApiClient(apiUrl, { appVersion: options.appVersion })\n}\n\n/**\n * Retrieve a key bundle from given user's contact topic\n */\nasync function getUserContactFromNetwork(\n  apiClient: ApiClient,\n  peerAddress: string\n): Promise<PublicKeyBundle | SignedPublicKeyBundle | undefined> {\n  const stream = apiClient.queryIterator(\n    { contentTopic: buildUserContactTopic(peerAddress) },\n    { pageSize: 5, direction: SortDirection.SORT_DIRECTION_DESCENDING }\n  )\n\n  for await (const env of stream) {\n    if (!env.message) continue\n    const keyBundle = decodeContactBundle(env.message)\n    let address: string | undefined\n    try {\n      address = await keyBundle?.walletSignatureAddress()\n    } catch (e) {\n      address = undefined\n    }\n\n    if (address === peerAddress) {\n      return keyBundle\n    }\n  }\n  return undefined\n}\n\n/**\n * Retrieve a list of key bundles given a list of user addresses\n */\nasync function getUserContactsFromNetwork(\n  apiClient: ApiClient,\n  peerAddresses: string[]\n): Promise<(PublicKeyBundle | SignedPublicKeyBundle | undefined)[]> {\n  const userContactTopics = peerAddresses.map(buildUserContactTopic)\n  const topicToEnvelopes = await apiClient.batchQuery(\n    userContactTopics.map((topic) => ({\n      contentTopic: topic,\n      pageSize: 5,\n      direction: SortDirection.SORT_DIRECTION_DESCENDING,\n    }))\n  )\n\n  // Transform topicToEnvelopes into a list of PublicKeyBundles or undefined\n  // by going through each message and attempting to decode\n  return Promise.all(\n    peerAddresses.map(async (address: string, index: number) => {\n      const envelopes = topicToEnvelopes[index]\n      if (!envelopes) {\n        return undefined\n      }\n      for (const env of envelopes) {\n        if (!env.message) continue\n        try {\n          const keyBundle = decodeContactBundle(env.message)\n          const signingAddress = await keyBundle?.walletSignatureAddress()\n          if (address === signingAddress) {\n            return keyBundle\n          } else {\n            console.info('Received contact bundle with incorrect address')\n          }\n        } catch (e) {\n          console.info('Invalid contact bundle', e)\n        }\n      }\n      return undefined\n    })\n  )\n}\n\n/**\n * Get the default list of `KeystoreProviders` used in the SDK\n *\n * Particularly useful if a developer wants to add their own\n * provider to the head of the list while falling back to the\n * default functionality\n */\nexport function defaultKeystoreProviders(): KeystoreProvider[] {\n  return [\n    // First check to see if a `privateKeyOverride` is provided and use that\n    new StaticKeystoreProvider(),\n    // Next check to see if a EncryptedPrivateKeyBundle exists on the network for the wallet\n    new NetworkKeystoreProvider(),\n    // If the first two failed with `KeystoreProviderUnavailableError`, then generate a new key and write it to the network\n    new KeyGeneratorKeystoreProvider(),\n  ]\n}\n\n/**\n * Take an array of KeystoreProviders from the options and try them until one succeeds\n */\nasync function bootstrapKeystore(\n  opts: ClientOptions,\n  apiClient: ApiClient,\n  wallet: Signer | null\n): Promise<Keystore> {\n  for (const provider of opts.keystoreProviders) {\n    try {\n      return await provider.newKeystore(opts, apiClient, wallet ?? undefined)\n    } catch (err) {\n      if (err instanceof KeystoreProviderUnavailableError) {\n        continue\n      }\n      throw err\n    }\n  }\n  throw new Error('No keystore providers available')\n}\n","import { messageApi } from '@xmtp/proto'\nimport { NotifyStreamEntityArrival } from '@xmtp/proto/ts/dist/types/fetch.pb'\nimport { b64Decode, retry, sleep, toNanoString } from './utils'\nimport AuthCache from './authn/AuthCache'\nimport { Authenticator } from './authn'\nimport packageJson from '../package.json'\nimport { XMTP_DEV_WARNING } from './constants'\nimport { Flatten } from './utils/typedefs'\nexport const { MessageApi, SortDirection } = messageApi\n\nconst RETRY_SLEEP_TIME = 100\nconst ERR_CODE_UNAUTHENTICATED = 16\n\nconst clientVersionHeaderKey = 'X-Client-Version'\nconst appVersionHeaderKey = 'X-App-Version'\n\nexport const ApiUrls = {\n  local: 'http://localhost:5555',\n  dev: 'https://dev.xmtp.network',\n  production: 'https://production.xmtp.network',\n} as const\n\nexport enum GrpcStatus {\n  OK = 0,\n  CANCELLED,\n  UNKNOWN,\n  INVALID_ARGUMENT,\n  DEADLINE_EXCEEDED,\n  NOT_FOUND,\n  ALREADY_EXISTS,\n  PERMISSION_DENIED,\n  RESOURCE_EXHAUSTED,\n  FAILED_PRECONDITION,\n  ABORTED,\n  OUT_OF_RANGE,\n  UNIMPLEMENTED,\n  INTERNAL,\n  UNAVAILABLE,\n  DATA_LOSS,\n  UNAUTHENTICATED,\n}\n\nexport class GrpcError extends Error {\n  code: GrpcStatus\n\n  constructor(message: string, code: GrpcStatus) {\n    super(message)\n    this.code = code\n  }\n\n  static fromObject(err: { code: GrpcStatus; message: string }): GrpcError {\n    return new GrpcError(err.message, err.code)\n  }\n}\n\nexport type QueryParams = {\n  startTime?: Date\n  endTime?: Date\n  contentTopic: string\n}\n\nexport type QueryAllOptions = {\n  direction?: messageApi.SortDirection\n  limit?: number\n}\n\nexport type QueryStreamOptions = Flatten<\n  Omit<QueryAllOptions, 'limit'> & {\n    pageSize?: number\n  }\n>\n\n// All of the fields in both QueryParams and QueryStreamOptions\nexport type Query = Flatten<QueryParams & QueryStreamOptions>\n\nexport type PublishParams = {\n  contentTopic: string\n  message: Uint8Array\n  timestamp?: Date\n}\n\nexport type SubscribeParams = {\n  contentTopics: string[]\n}\n\nexport type ApiClientOptions = {\n  maxRetries?: number\n  appVersion?: string\n}\n\nexport type SubscribeCallback = NotifyStreamEntityArrival<messageApi.Envelope>\n\nexport type UnsubscribeFn = () => Promise<void>\n\nexport type UpdateContentTopics = (topics: string[]) => Promise<void>\n\nexport type SubscriptionManager = {\n  unsubscribe: UnsubscribeFn\n  updateContentTopics?: UpdateContentTopics\n}\n\nexport type OnConnectionLostCallback = () => void\n\nconst isAbortError = (err?: Error): boolean => {\n  if (!err) {\n    return false\n  }\n  if (err.name === 'AbortError' || err.message.includes('aborted')) {\n    return true\n  }\n  return false\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isAuthError = (err?: GrpcError | Error): boolean => {\n  if (err && 'code' in err && err.code === ERR_CODE_UNAUTHENTICATED) {\n    return true\n  }\n  return false\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isNotAuthError = (err?: Error): boolean => !isAuthError(err)\n\nexport interface ApiClient {\n  query(\n    params: QueryParams,\n    options: QueryAllOptions\n  ): Promise<messageApi.Envelope[]>\n  queryIterator(\n    params: QueryParams,\n    options: QueryStreamOptions\n  ): AsyncGenerator<messageApi.Envelope>\n  queryIteratePages(\n    params: QueryParams,\n    options: QueryStreamOptions\n  ): AsyncGenerator<messageApi.Envelope[]>\n  subscribe(\n    params: SubscribeParams,\n    callback: SubscribeCallback,\n    onConnectionLost?: OnConnectionLostCallback\n  ): SubscriptionManager\n  publish(messages: PublishParams[]): ReturnType<typeof MessageApi.Publish>\n  batchQuery(queries: Query[]): Promise<messageApi.Envelope[][]>\n  setAuthenticator(\n    authenticator: Authenticator,\n    cacheExpirySeconds?: number\n  ): void\n}\n\nconst normalizeEnvelope = (env: messageApi.Envelope): messageApi.Envelope => {\n  if (!env.message || !env.message.length) {\n    return env\n  }\n  if (typeof env.message === 'string') {\n    env.message = b64Decode(env.message)\n  }\n  return env\n}\n\n/**\n * ApiClient provides a wrapper for calling the GRPC Gateway generated code.\n * It adds some helpers for dealing with paginated data and automatically retries idempotent calls\n */\nexport default class HttpApiClient implements ApiClient {\n  pathPrefix: string\n  maxRetries: number\n  private authCache?: AuthCache\n  appVersion: string | undefined\n  version: string\n\n  constructor(pathPrefix: string, opts?: ApiClientOptions) {\n    this.pathPrefix = pathPrefix\n    this.maxRetries = opts?.maxRetries || 5\n    this.appVersion = opts?.appVersion\n    this.version = 'xmtp-js/' + packageJson.version\n\n    if (pathPrefix === ApiUrls.dev) {\n      console.info(XMTP_DEV_WARNING)\n    }\n  }\n\n  // Raw method for querying the API\n  private async _query(\n    req: messageApi.QueryRequest\n  ): ReturnType<typeof MessageApi.Query> {\n    try {\n      return await retry(\n        MessageApi.Query,\n        [\n          req,\n          {\n            pathPrefix: this.pathPrefix,\n            mode: 'cors',\n            headers: this.headers(),\n          },\n        ],\n        this.maxRetries,\n        RETRY_SLEEP_TIME\n      )\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw GrpcError.fromObject(e)\n    }\n  }\n\n  // Raw method for batch-querying the API\n  private _batchQuery(\n    req: messageApi.BatchQueryRequest\n  ): ReturnType<typeof MessageApi.BatchQuery> {\n    return retry(\n      MessageApi.BatchQuery,\n      [\n        req,\n        {\n          pathPrefix: this.pathPrefix,\n          mode: 'cors',\n          headers: this.headers(),\n        },\n      ],\n      this.maxRetries,\n      RETRY_SLEEP_TIME\n    )\n  }\n\n  // Raw method for publishing to the API\n  private async _publish(\n    req: messageApi.PublishRequest,\n    attemptNumber = 0\n  ): ReturnType<typeof MessageApi.Publish> {\n    const authToken = await this.getToken()\n    const headers = this.headers()\n    headers.set('Authorization', `Bearer ${authToken}`)\n    try {\n      return await retry(\n        MessageApi.Publish,\n        [\n          req,\n          {\n            pathPrefix: this.pathPrefix,\n            mode: 'cors',\n            headers,\n          },\n        ],\n        this.maxRetries,\n        RETRY_SLEEP_TIME,\n        // Do not retry UnauthenticatedErrors\n        isNotAuthError\n      )\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      // Try at most 2X. If refreshing the auth token doesn't work the first time, it won't work the second time\n      if (isNotAuthError(e) || attemptNumber >= 1) {\n        throw GrpcError.fromObject(e)\n      }\n      await this.authCache?.refresh()\n      return this._publish(req, attemptNumber + 1)\n    }\n  }\n\n  // Raw method for subscribing\n  private _subscribe(\n    req: messageApi.SubscribeRequest,\n    cb: NotifyStreamEntityArrival<messageApi.Envelope>,\n    onConnectionLost?: OnConnectionLostCallback\n  ): SubscriptionManager {\n    const abortController = new AbortController()\n\n    const doSubscribe = async () => {\n      while (true) {\n        const startTime = new Date().getTime()\n        try {\n          await MessageApi.Subscribe(req, cb, {\n            pathPrefix: this.pathPrefix,\n            signal: abortController.signal,\n            mode: 'cors',\n            headers: this.headers(),\n          })\n          if (abortController.signal.aborted) {\n            return\n          }\n          console.info('Stream connection closed. Resubscribing')\n          if (new Date().getTime() - startTime < 1000) {\n            await sleep(1000)\n          }\n\n          onConnectionLost?.()\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (err: any) {\n          if (isAbortError(err) || abortController.signal.aborted) {\n            return\n          }\n          console.info(\n            'Stream connection closed. Resubscribing',\n            err.toString()\n          )\n\n          if (new Date().getTime() - startTime < 1000) {\n            await sleep(1000)\n          }\n\n          onConnectionLost?.()\n        }\n      }\n    }\n    doSubscribe()\n\n    return {\n      unsubscribe: async () => {\n        abortController?.abort()\n      },\n    }\n  }\n\n  // Use the Query API to return the full contents of any specified topics\n  async query(\n    params: QueryParams,\n    {\n      direction = SortDirection.SORT_DIRECTION_ASCENDING,\n      limit,\n    }: QueryAllOptions\n  ): Promise<messageApi.Envelope[]> {\n    const out: messageApi.Envelope[] = []\n    // Use queryIteratePages for better performance. 1/100th the number of Promises to resolve compared to queryStream\n    for await (const page of this.queryIteratePages(params, {\n      direction,\n      // If there is a limit of < 100, use that as the page size. Otherwise use 100 and stop if/when limit reached.\n      pageSize: limit && limit < 100 ? limit : 100,\n    })) {\n      for (const envelope of page) {\n        out.push(envelope)\n        if (limit && out.length === limit) {\n          return out\n        }\n      }\n    }\n    return out\n  }\n\n  // Will produce an AsyncGenerator of Envelopes\n  // Uses queryStreamPages under the hood\n  async *queryIterator(\n    params: QueryParams,\n    options: QueryStreamOptions\n  ): AsyncGenerator<messageApi.Envelope> {\n    for await (const page of this.queryIteratePages(params, options)) {\n      for (const envelope of page) {\n        yield envelope\n      }\n    }\n  }\n\n  // Creates an async generator that will paginate through the Query API until it reaches the end\n  // Will yield each page of results as needed\n  async *queryIteratePages(\n    { contentTopic, startTime, endTime }: QueryParams,\n    { direction, pageSize = 10 }: QueryStreamOptions\n  ): AsyncGenerator<messageApi.Envelope[]> {\n    if (!contentTopic || !contentTopic.length) {\n      throw new Error('Must specify content topics')\n    }\n\n    const startTimeNs = toNanoString(startTime)\n    const endTimeNs = toNanoString(endTime)\n    let cursor: messageApi.Cursor | undefined\n\n    while (true) {\n      const pagingInfo: messageApi.PagingInfo = {\n        limit: pageSize,\n        direction,\n        cursor,\n      }\n\n      const result = await this._query({\n        contentTopics: [contentTopic],\n        startTimeNs,\n        endTimeNs,\n        pagingInfo,\n      })\n\n      if (result.envelopes?.length) {\n        yield result.envelopes.map(normalizeEnvelope)\n      } else {\n        return\n      }\n\n      if (result.pagingInfo?.cursor) {\n        cursor = result.pagingInfo?.cursor\n      } else {\n        return\n      }\n    }\n  }\n\n  // Take a list of queries and execute them in batches\n  async batchQuery(queries: Query[]): Promise<messageApi.Envelope[][]> {\n    // Group queries into batches of 50 (implicit server-side limit) and then perform BatchQueries\n    const BATCH_SIZE = 50\n    // Keep a list of BatchQueryRequests to execute all at once later\n    const batchRequests: messageApi.BatchQueryRequest[] = []\n\n    // Assemble batches\n    for (let i = 0; i < queries.length; i += BATCH_SIZE) {\n      const queriesInBatch = queries.slice(i, i + BATCH_SIZE)\n      // Perform batch query by first compiling a list of repeated individual QueryRequests\n      // then populating a BatchQueryRequest with that list\n      const constructedQueries: messageApi.QueryRequest[] = []\n\n      for (const queryParams of queriesInBatch) {\n        constructedQueries.push({\n          contentTopics: [queryParams.contentTopic],\n          startTimeNs: toNanoString(queryParams.startTime),\n          endTimeNs: toNanoString(queryParams.endTime),\n          pagingInfo: {\n            limit: queryParams.pageSize || 10,\n            direction:\n              queryParams.direction || SortDirection.SORT_DIRECTION_ASCENDING,\n          },\n        })\n      }\n      const batchQueryRequest = {\n        requests: constructedQueries,\n      }\n      batchRequests.push(batchQueryRequest)\n    }\n\n    // Execute batches\n    const batchQueryResponses = await Promise.all(\n      batchRequests.map(async (batch) => this._batchQuery(batch))\n    )\n\n    // For every batch, read all responses within the batch, and add to a list of lists of envelopes\n    // one top-level list for every original query\n    const allEnvelopes: messageApi.Envelope[][] = []\n    for (const batchResponse of batchQueryResponses) {\n      if (!batchResponse.responses) {\n        // An error on any of the batch query is propagated to the caller\n        // for simplicity, rather than trying to return partial results\n        throw new Error('BatchQueryResponse missing responses')\n      }\n      for (const queryResponse of batchResponse.responses) {\n        if (queryResponse.envelopes) {\n          allEnvelopes.push(queryResponse.envelopes.map(normalizeEnvelope))\n        } else {\n          // If no envelopes provided, then add an empty list\n          allEnvelopes.push([])\n        }\n      }\n    }\n    return allEnvelopes\n  }\n\n  // Publish a message to the network\n  // Will convert timestamps to the appropriate format expected by the network\n  async publish(\n    messages: PublishParams[]\n  ): ReturnType<typeof MessageApi.Publish> {\n    const toSend: messageApi.Envelope[] = []\n    for (const { contentTopic, message, timestamp } of messages) {\n      if (!contentTopic.length) {\n        throw new Error('Content topic cannot be empty string')\n      }\n\n      if (!message.length) {\n        throw new Error('0 length messages not allowed')\n      }\n\n      const dt = timestamp || new Date()\n      toSend.push({\n        contentTopic,\n        timestampNs: toNanoString(dt),\n        message: Uint8Array.from(message),\n      })\n    }\n\n    return this._publish({ envelopes: toSend })\n  }\n\n  // Subscribe to a list of topics.\n  // Provided callback function will be called on each new message\n  // Returns an unsubscribe function that can be used to end the subscription\n  subscribe(\n    params: SubscribeParams,\n    callback: SubscribeCallback,\n    onConnectionLost?: OnConnectionLostCallback\n  ): SubscriptionManager {\n    if (!params.contentTopics.length) {\n      throw new Error('Must provide list of contentTopics to subscribe to')\n    }\n\n    return this._subscribe(\n      params,\n      (env) => callback(normalizeEnvelope(env)),\n      onConnectionLost\n    )\n  }\n\n  private getToken(): Promise<string> {\n    if (!this.authCache) {\n      throw new Error('AuthCache is not set on API Client')\n    }\n    return this.authCache.getToken()\n  }\n\n  setAuthenticator(\n    authenticator: Authenticator,\n    cacheExpirySeconds?: number\n  ): void {\n    this.authCache = new AuthCache(authenticator, cacheExpirySeconds)\n  }\n\n  headers(): Headers {\n    const headers = new Headers()\n    headers.set(clientVersionHeaderKey, this.version)\n    if (this.appVersion) {\n      headers.set(appVersionHeaderKey, this.appVersion)\n    }\n    return headers\n  }\n}\n","import { Authenticator } from './interfaces'\nimport Token from './Token'\n\n// Default to 10 seconds less than expected expiry to give some wiggle room near the end\n// https://github.com/xmtp/xmtp-node-go/blob/main/pkg/api/authentication.go#L18\nconst DEFAULT_MAX_AGE_SECONDS = 60 * 60 - 10\n\nexport default class AuthCache {\n  private authenticator: Authenticator\n  private token?: Token\n  maxAgeMs: number\n\n  constructor(\n    authenticator: Authenticator,\n    cacheExpirySeconds = DEFAULT_MAX_AGE_SECONDS\n  ) {\n    this.authenticator = authenticator\n    this.maxAgeMs = cacheExpirySeconds * 1000\n  }\n\n  async getToken(): Promise<string> {\n    if (!this.token || this.token.ageMs > this.maxAgeMs) {\n      await this.refresh()\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.token!.toBase64()\n  }\n\n  async refresh(): Promise<void> {\n    this.token = await this.authenticator.createToken()\n  }\n}\n","{\n  \"name\": \"@xmtp/xmtp-js\",\n  \"version\": \"11.0.0\",\n  \"description\": \"XMTP client SDK for interacting with XMTP networks.\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"browser\": \"dist/web/index.js\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"browser\": \"./dist/web/index.js\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\"\n    }\n  },\n  \"scripts\": {\n    \"prebench\": \"npm run build:bench\",\n    \"bench\": \"node dist/bench/index.cjs\",\n    \"build\": \"npm run clean:dist && npm run build:node && npm run build:web\",\n    \"build:bench\": \"tsup --out-dir dist/bench --entry.0 bench/index.ts --format cjs\",\n    \"build:node\": \"tsup\",\n    \"build:web\": \"tsup --platform browser --target esnext\",\n    \"build:docs\": \"rimraf docs && mkdir -p tmp && cp README.md tmp/ && sed -i.bak '/badge.svg/d' tmp/README.md && typedoc --excludePrivate --readme tmp/README.md src/index.ts\",\n    \"clean\": \"npm run clean:dist && npm run clean:proto\",\n    \"clean:dist\": \"rimraf dist\",\n    \"clean:proto\": \"rimraf -g src/proto/*.ts\",\n    \"package\": \"npm pack\",\n    \"prepublishOnly\": \"npm run build\",\n    \"updateSnapVersion\": \"npm view @xmtp/snap --json | jq '{\\\"version\\\": .version, \\\"package\\\": .name}' > ./src/snapInfo.json\",\n    \"test:setup\": \"./dev/up\",\n    \"test:teardown\": \"./dev/down\",\n    \"test\": \"npm run test:node\",\n    \"test:node\": \"jest --no-cache --env='node' --testTimeout=30000\",\n    \"test:jsdom\": \"jest --no-cache --env='./jest.jsdom.env.cjs' --testTimeout=30000\",\n    \"test:cov\": \"jest --coverage --no-cache --runInBand\",\n    \"lint\": \"prettier --check . && eslint .\",\n    \"autolint\": \"prettier --write . && eslint --fix .\",\n    \"semantic-release\": \"semantic-release\",\n    \"typecheck\": \"tsc\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\",\n    \"provenance\": true\n  },\n  \"files\": [\n    \"dist/index.cjs\",\n    \"dist/index.cjs.map\",\n    \"dist/index.d.ts\",\n    \"dist/index.js\",\n    \"dist/index.js.map\",\n    \"dist/web/index.js\",\n    \"dist/web/index.js.map\"\n  ],\n  \"keywords\": [\n    \"xmtp\",\n    \"messaging\",\n    \"web3\",\n    \"sdk\",\n    \"js\",\n    \"javascript\",\n    \"node\",\n    \"nodejs\"\n  ],\n  \"author\": \"XMTP Labs <eng@xmtp.com>\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/xmtp/xmtp-js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https:git@github.com:xmtp/xmtp-js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/xmtp/xmtp-js/issues\"\n  },\n  \"release\": {\n    \"branches\": [\n      \"main\",\n      {\n        \"name\": \"beta\",\n        \"prerelease\": true\n      }\n    ]\n  },\n  \"dependencies\": {\n    \"@noble/secp256k1\": \"^1.5.2\",\n    \"@xmtp/proto\": \"^3.28.0-beta.1\",\n    \"async-mutex\": \"^0.4.0\",\n    \"elliptic\": \"^6.5.4\",\n    \"ethers\": \"^5.5.3\",\n    \"long\": \"^5.2.0\"\n  },\n  \"devDependencies\": {\n    \"@commitlint/cli\": \"^16.1.0\",\n    \"@commitlint/config-conventional\": \"^16.0.0\",\n    \"@metamask/providers\": \"^11.1.1\",\n    \"@types/benchmark\": \"^2.1.2\",\n    \"@types/bl\": \"^5.0.2\",\n    \"@types/callback-to-async-iterator\": \"^1.1.4\",\n    \"@types/elliptic\": \"^6.4.14\",\n    \"@types/jest\": \"^28.1.3\",\n    \"@types/node\": \"^18.14.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.38.0\",\n    \"@typescript-eslint/parser\": \"^5.38.0\",\n    \"benny\": \"^3.7.1\",\n    \"dd-trace\": \"^2.12.2\",\n    \"esbuild\": \"^0.17.16\",\n    \"esbuild-plugin-external-global\": \"^1.0.1\",\n    \"eslint\": \"^8.0.1\",\n    \"eslint-config-prettier\": \"^8.3.0\",\n    \"eslint-config-standard\": \"^17.0.0\",\n    \"eslint-plugin-import\": \"^2.26.0\",\n    \"eslint-plugin-jsdoc\": \"^37.9.1\",\n    \"eslint-plugin-node\": \"^11.1.0\",\n    \"eslint-plugin-prettier\": \"^4.0.0\",\n    \"eslint-plugin-promise\": \"^6.0.1\",\n    \"husky\": \"^7.0.4\",\n    \"jest\": \"^29.6.0\",\n    \"jest-environment-jsdom\": \"^28.1.3\",\n    \"prettier\": \"^2.4.0\",\n    \"rimraf\": \"^5.0.0\",\n    \"semantic-release\": \"^21.0.3\",\n    \"ts-jest\": \"^29.1.1\",\n    \"ts-node\": \"^10.9.1\",\n    \"tsup\": \"^6.7.0\",\n    \"typedoc\": \"^0.22.11\",\n    \"typescript\": \"^4.4.3\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  }\n}\n","export const XMTP_DEV_WARNING = `\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the XMTP 'dev' network. Use 'production' for production messages.\nhttps://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments\n`\n","import { OnConnectionLostCallback } from './../ApiClient'\nimport { messageApi, keystore, conversationReference } from '@xmtp/proto'\nimport { SignedPublicKeyBundle } from './../crypto/PublicKeyBundle'\nimport { ListMessagesOptions } from './../Client'\nimport { InvitationContext } from './../Invitation'\nimport { Conversation, ConversationV1, ConversationV2 } from './Conversation'\nimport { MessageV1, DecodedMessage } from '../Message'\nimport Stream from '../Stream'\nimport Client from '../Client'\nimport {\n  buildDirectMessageTopic,\n  buildUserIntroTopic,\n  buildUserInviteTopic,\n  dateToNs,\n  nsToDate,\n} from '../utils'\nimport { PublicKeyBundle } from '../crypto'\nimport { SortDirection } from '../ApiClient'\nimport Long from 'long'\nimport JobRunner from './JobRunner'\n\nconst CLOCK_SKEW_OFFSET_MS = 10000\n\nconst messageHasHeaders = (msg: MessageV1): boolean => {\n  return Boolean(msg.recipientAddress && msg.senderAddress)\n}\n\n/**\n * Conversations allows you to view ongoing 1:1 messaging sessions with another wallet\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default class Conversations<ContentTypes = any> {\n  private client: Client<ContentTypes>\n  private v1JobRunner: JobRunner\n  private v2JobRunner: JobRunner\n\n  constructor(client: Client<ContentTypes>) {\n    this.client = client\n    this.v1JobRunner = new JobRunner('v1', client.keystore)\n    this.v2JobRunner = new JobRunner('v2', client.keystore)\n  }\n\n  /**\n   * List all conversations with the current wallet found in the network.\n   */\n  async list(): Promise<Conversation<ContentTypes>[]> {\n    const [v1Convos, v2Convos] = await Promise.all([\n      this.listV1Conversations(),\n      this.listV2Conversations(),\n    ])\n\n    const conversations = v1Convos.concat(v2Convos)\n\n    conversations.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime())\n    return conversations\n  }\n\n  /**\n   * List all conversations stored in the client cache, which may not include\n   * conversations on the network.\n   */\n  async listFromCache(): Promise<Conversation<ContentTypes>[]> {\n    const [v1Convos, v2Convos]: Conversation<ContentTypes>[][] =\n      await Promise.all([\n        this.getV1ConversationsFromKeystore(),\n        this.getV2ConversationsFromKeystore(),\n      ])\n    const conversations = v1Convos.concat(v2Convos)\n\n    conversations.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime())\n    return conversations\n  }\n\n  private async listV1Conversations(): Promise<Conversation<ContentTypes>[]> {\n    return this.v1JobRunner.run(async (latestSeen) => {\n      const seenPeers = await this.getIntroductionPeers({\n        startTime: latestSeen\n          ? new Date(+latestSeen - CLOCK_SKEW_OFFSET_MS)\n          : undefined,\n        direction: SortDirection.SORT_DIRECTION_ASCENDING,\n      })\n\n      await this.client.keystore.saveV1Conversations({\n        conversations: Array.from(seenPeers).map(\n          ([peerAddress, createdAt]) => ({\n            peerAddress,\n            createdNs: dateToNs(createdAt),\n            topic: buildDirectMessageTopic(peerAddress, this.client.address),\n            context: undefined,\n          })\n        ),\n      })\n\n      return (\n        await this.client.keystore.getV1Conversations()\n      ).conversations.map(this.conversationReferenceToV1.bind(this))\n    })\n  }\n\n  /**\n   * List all V2 conversations\n   */\n  private async listV2Conversations(): Promise<Conversation<ContentTypes>[]> {\n    return this.v2JobRunner.run(async (lastRun) => {\n      // Get all conversations already in the KeyStore\n      const existing = await this.getV2ConversationsFromKeystore()\n      // Load all conversations started after the newest conversation found\n      const newConversations = await this.updateV2Conversations(lastRun)\n\n      // Create a Set of all the existing topics to ensure no duplicates are added\n      const existingTopics = new Set(existing.map((c) => c.topic))\n      // Add all new conversations to the existing list\n      for (const convo of newConversations) {\n        if (!existingTopics.has(convo.topic)) {\n          existing.push(convo)\n          existingTopics.add(convo.topic)\n        }\n      }\n\n      // Sort the result set by creation time in ascending order\n      existing.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime())\n      return existing\n    })\n  }\n\n  private async getV2ConversationsFromKeystore(): Promise<\n    ConversationV2<ContentTypes>[]\n  > {\n    return (await this.client.keystore.getV2Conversations()).conversations.map(\n      this.conversationReferenceToV2.bind(this)\n    )\n  }\n\n  private async getV1ConversationsFromKeystore(): Promise<\n    ConversationV1<ContentTypes>[]\n  > {\n    return (await this.client.keystore.getV1Conversations()).conversations.map(\n      this.conversationReferenceToV1.bind(this)\n    )\n  }\n\n  // Called in listV2Conversations and in newConversation\n  async updateV2Conversations(\n    startTime?: Date\n  ): Promise<ConversationV2<ContentTypes>[]> {\n    const envelopes = await this.client.listInvitations({\n      startTime: startTime\n        ? new Date(+startTime - CLOCK_SKEW_OFFSET_MS)\n        : undefined,\n      direction: SortDirection.SORT_DIRECTION_ASCENDING,\n    })\n\n    return this.decodeInvites(envelopes)\n  }\n\n  private async decodeInvites(\n    envelopes: messageApi.Envelope[],\n    shouldThrow = false\n  ): Promise<ConversationV2<ContentTypes>[]> {\n    const { responses } = await this.client.keystore.saveInvites({\n      requests: envelopes.map((env) => ({\n        payload: env.message as Uint8Array,\n        timestampNs: Long.fromString(env.timestampNs as string),\n        contentTopic: env.contentTopic as string,\n      })),\n    })\n\n    const out: ConversationV2<ContentTypes>[] = []\n    for (const response of responses) {\n      try {\n        out.push(this.saveInviteResponseToConversation(response))\n      } catch (e) {\n        console.warn('Error saving invite response to conversation: ', e)\n        if (shouldThrow) {\n          throw e\n        }\n      }\n    }\n    return out\n  }\n\n  private saveInviteResponseToConversation({\n    result,\n    error,\n  }: keystore.SaveInvitesResponse_Response): ConversationV2<ContentTypes> {\n    if (error || !result || !result.conversation) {\n      throw new Error(`Error from keystore: ${error?.code} ${error?.message}}`)\n    }\n    return this.conversationReferenceToV2(result.conversation)\n  }\n\n  private conversationReferenceToV2(\n    convoRef: conversationReference.ConversationReference\n  ): ConversationV2<ContentTypes> {\n    return new ConversationV2(\n      this.client,\n      convoRef.topic,\n      convoRef.peerAddress,\n      nsToDate(convoRef.createdNs),\n      convoRef.context\n    )\n  }\n\n  private conversationReferenceToV1(\n    convoRef: conversationReference.ConversationReference\n  ): ConversationV1<ContentTypes> {\n    return new ConversationV1(\n      this.client,\n      convoRef.peerAddress,\n      nsToDate(convoRef.createdNs)\n    )\n  }\n\n  /**\n   * Returns a stream of any newly created conversations.\n   * Will dedupe to not return the same conversation twice in the same stream.\n   * Does not dedupe any other previously seen conversations\n   */\n  async stream(\n    onConnectionLost?: OnConnectionLostCallback\n  ): Promise<Stream<Conversation<ContentTypes>, ContentTypes>> {\n    const seenPeers: Set<string> = new Set()\n    const introTopic = buildUserIntroTopic(this.client.address)\n    const inviteTopic = buildUserInviteTopic(this.client.address)\n\n    const newPeer = (peerAddress: string): boolean => {\n      // Check if we have seen the peer already in this stream\n      if (seenPeers.has(peerAddress)) {\n        return false\n      }\n      seenPeers.add(peerAddress)\n      return true\n    }\n\n    const decodeConversation = async (env: messageApi.Envelope) => {\n      if (env.contentTopic === introTopic) {\n        if (!env.message) {\n          throw new Error('empty envelope')\n        }\n        const msg = await MessageV1.fromBytes(env.message)\n        const peerAddress = this.getPeerAddress(msg)\n        if (!newPeer(peerAddress)) {\n          return undefined\n        }\n        await msg.decrypt(this.client.keystore, this.client.publicKeyBundle)\n        return new ConversationV1(this.client, peerAddress, msg.sent)\n      }\n      if (env.contentTopic === inviteTopic) {\n        const results = await this.decodeInvites([env], true)\n        if (results.length) {\n          return results[0]\n        }\n      }\n\n      throw new Error('unrecognized invite topic')\n    }\n\n    const topics = [introTopic, inviteTopic]\n\n    return Stream.create<Conversation<ContentTypes>, ContentTypes>(\n      this.client,\n      topics,\n      decodeConversation.bind(this),\n      undefined,\n      onConnectionLost\n    )\n  }\n\n  /**\n   * Streams messages from all conversations.\n   *\n   * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.\n   * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.\n   *\n   */\n  async streamAllMessages(\n    onConnectionLost?: OnConnectionLostCallback\n  ): Promise<AsyncGenerator<DecodedMessage<ContentTypes>>> {\n    const introTopic = buildUserIntroTopic(this.client.address)\n    const inviteTopic = buildUserInviteTopic(this.client.address)\n\n    const topics = new Set<string>([introTopic, inviteTopic])\n\n    const convoMap = new Map<string, Conversation<ContentTypes>>()\n\n    for (const conversation of await this.list()) {\n      topics.add(conversation.topic)\n      convoMap.set(conversation.topic, conversation)\n    }\n\n    const decodeMessage = async (\n      env: messageApi.Envelope\n    ): Promise<\n      Conversation<ContentTypes> | DecodedMessage<ContentTypes> | null\n    > => {\n      const contentTopic = env.contentTopic\n      if (!contentTopic || !env.message) {\n        return null\n      }\n\n      if (contentTopic === introTopic) {\n        const msg = await MessageV1.fromBytes(env.message)\n        if (!messageHasHeaders(msg)) {\n          return null\n        }\n        const peerAddress = this.getPeerAddress(msg)\n\n        // Temporarily create a convo to decrypt the message\n        const convo = new ConversationV1(\n          this.client,\n          peerAddress as string,\n          msg.sent\n        )\n\n        // TODO: This duplicates the proto deserialization unnecessarily\n        // Refactor to avoid duplicate work\n        return convo.decodeMessage(env)\n      }\n\n      // Decode as an invite and return the envelope\n      // This gives the contentTopicUpdater everything it needs to add to the topic list\n      if (contentTopic === inviteTopic) {\n        const results = await this.decodeInvites([env], true)\n        return results[0]\n      }\n\n      const convo = convoMap.get(contentTopic)\n\n      // Decode as a V1 message if the topic matches a V1 convo\n      if (convo instanceof ConversationV1) {\n        return convo.decodeMessage(env)\n      }\n\n      // Decode as a V2 message if the topic matches a V2 convo\n      if (convo instanceof ConversationV2) {\n        return convo.decodeMessage(env)\n      }\n\n      console.log('Unknown topic')\n\n      throw new Error('Unknown topic')\n    }\n\n    const addConvo = (\n      topic: string,\n      conversation: Conversation<ContentTypes>\n    ): boolean => {\n      if (topics.has(topic)) {\n        return false\n      }\n      convoMap.set(topic, conversation)\n      topics.add(topic)\n      return true\n    }\n\n    const contentTopicUpdater = (\n      msg: Conversation<ContentTypes> | DecodedMessage<ContentTypes> | null\n    ) => {\n      // If we have a V1 message from the introTopic, store the conversation in our mapping\n      if (msg instanceof DecodedMessage && msg.contentTopic === introTopic) {\n        const convo = new ConversationV1(\n          this.client,\n          msg.recipientAddress === this.client.address\n            ? (msg.senderAddress as string)\n            : (msg.recipientAddress as string),\n          msg.sent\n        )\n        const isNew = addConvo(convo.topic, convo)\n\n        return isNew ? Array.from(topics.values()) : undefined\n      }\n\n      if (msg instanceof ConversationV2) {\n        const isNew = addConvo(msg.topic, msg)\n\n        return isNew ? Array.from(topics.values()) : undefined\n      }\n\n      return undefined\n    }\n\n    const str = await Stream.create<\n      DecodedMessage<ContentTypes> | Conversation<ContentTypes> | null,\n      ContentTypes\n    >(\n      this.client,\n      Array.from(topics.values()),\n      decodeMessage,\n      contentTopicUpdater,\n      onConnectionLost\n    )\n\n    const gen = (async function* generate() {\n      for await (const val of str) {\n        if (val instanceof DecodedMessage) {\n          yield val\n        }\n        // For conversation V2, we may have messages in the new topic before we started streaming.\n        // To be safe, we fetch all messages\n        if (val instanceof ConversationV2) {\n          for (const convoMessage of await val.messages()) {\n            yield convoMessage\n          }\n        }\n      }\n    })()\n\n    // Overwrite the generator's return method to close the underlying stream\n    // Generators by default need to wait until the next yield to return.\n    // In this case, that's only when the next message arrives...which could be a long time\n    gen.return = async () => {\n      // Returning the stream will cause the iteration to end inside the generator\n      // The generator will then return on its own\n      await str?.return()\n      return { value: undefined, done: true }\n    }\n\n    return gen\n  }\n\n  private async getIntroductionPeers(\n    opts?: ListMessagesOptions\n  ): Promise<Map<string, Date>> {\n    const topic = buildUserIntroTopic(this.client.address)\n    const messages = await this.client.listEnvelopes(\n      topic,\n      (env) => {\n        if (!env.message) {\n          throw new Error('empty envelope')\n        }\n        return MessageV1.fromBytes(env.message)\n      },\n      opts\n    )\n    const seenPeers: Map<string, Date> = new Map()\n    for (const message of messages) {\n      // Ignore all messages without sender or recipient address headers\n      // Makes getPeerAddress safe\n      if (!messageHasHeaders(message)) {\n        continue\n      }\n\n      const peerAddress = this.getPeerAddress(message)\n\n      if (peerAddress) {\n        const have = seenPeers.get(peerAddress)\n        if (!have || have > message.sent) {\n          try {\n            // Verify that the message can be decrypted before treating the intro as valid\n            await message.decrypt(\n              this.client.keystore,\n              this.client.publicKeyBundle\n            )\n            seenPeers.set(peerAddress, message.sent)\n          } catch (e) {\n            continue\n          }\n        }\n      }\n    }\n\n    return seenPeers\n  }\n\n  /**\n   * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network\n   */\n  async newConversation(\n    peerAddress: string,\n    context?: InvitationContext\n  ): Promise<Conversation<ContentTypes>> {\n    let contact = await this.client.getUserContact(peerAddress)\n    if (!contact) {\n      throw new Error(`Recipient ${peerAddress} is not on the XMTP network`)\n    }\n\n    if (peerAddress === this.client.address) {\n      throw new Error('self messaging not supported')\n    }\n\n    // If this is a V1 conversation continuation\n    if (contact instanceof PublicKeyBundle && !context?.conversationId) {\n      return new ConversationV1(this.client, peerAddress, new Date())\n    }\n\n    // If no conversationId, check and see if we have an existing V1 conversation\n    if (!context?.conversationId) {\n      const v1Convos = await this.listV1Conversations()\n      const matchingConvo = v1Convos.find(\n        (convo) => convo.peerAddress === peerAddress\n      )\n      // If intro already exists, return V1 conversation\n      // if both peers have V1 compatible key bundles\n      if (matchingConvo) {\n        if (!this.client.signedPublicKeyBundle.isFromLegacyBundle()) {\n          throw new Error(\n            'cannot resume pre-existing V1 conversation; client keys not compatible'\n          )\n        }\n        if (\n          !(contact instanceof PublicKeyBundle) &&\n          !contact.isFromLegacyBundle()\n        ) {\n          throw new Error(\n            'cannot resume pre-existing V1 conversation; peer keys not compatible'\n          )\n        }\n        return matchingConvo\n      }\n    }\n\n    // Coerce the contact into a V2 bundle\n    if (contact instanceof PublicKeyBundle) {\n      contact = SignedPublicKeyBundle.fromLegacyBundle(contact)\n    }\n\n    // Define a function for matching V2 conversations\n    const matcherFn = (convo: Conversation<ContentTypes>) =>\n      convo.peerAddress === peerAddress &&\n      isMatchingContext(context, convo.context ?? undefined)\n\n    const existing = await this.getV2ConversationsFromKeystore()\n    const existingMatch = existing.find(matcherFn)\n    if (existingMatch) {\n      return existingMatch\n    }\n\n    return this.v2JobRunner.run(async (lastRun) => {\n      const newItems = await this.updateV2Conversations(lastRun)\n      const newItemMatch = newItems.find(matcherFn)\n      // If one of those matches, return it to update the cache\n      if (newItemMatch) {\n        return newItemMatch\n      }\n\n      return this.createV2Convo(contact as SignedPublicKeyBundle, context)\n    })\n  }\n\n  private async createV2Convo(\n    recipient: SignedPublicKeyBundle,\n    context?: InvitationContext\n  ): Promise<ConversationV2<ContentTypes>> {\n    const timestamp = new Date()\n    const { payload, conversation } = await this.client.keystore.createInvite({\n      recipient,\n      context,\n      createdNs: dateToNs(timestamp),\n    })\n    if (!payload || !conversation) {\n      throw new Error('Required field not returned from Keystore')\n    }\n\n    const peerAddress = await recipient.walletSignatureAddress()\n\n    await this.client.publishEnvelopes([\n      {\n        contentTopic: buildUserInviteTopic(peerAddress),\n        message: payload,\n        timestamp,\n      },\n      {\n        contentTopic: buildUserInviteTopic(this.client.address),\n        message: payload,\n        timestamp,\n      },\n    ])\n\n    return this.conversationReferenceToV2(conversation)\n  }\n\n  private getPeerAddress(message: MessageV1): string {\n    const peerAddress =\n      message.recipientAddress === this.client.address\n        ? message.senderAddress\n        : message.recipientAddress\n\n    // This assertion is safe, so long as messages have been through the filter\n    return peerAddress as string\n  }\n}\n\nfunction isMatchingContext(\n  contextA?: InvitationContext,\n  contextB?: InvitationContext\n): boolean {\n  // Use == to allow null and undefined to be equivalent\n  return contextA?.conversationId === contextB?.conversationId\n}\n","import { keystore } from '@xmtp/proto'\nimport { Mutex } from 'async-mutex'\nimport { Keystore } from '../keystore'\nimport Long from 'long'\nimport { dateToNs, nsToDate } from '../utils'\n\ntype JobType = 'v1' | 'v2'\n\ntype UpdateJob<T> = (lastRun: Date | undefined) => Promise<T>\n\nexport default class JobRunner {\n  readonly jobType: JobType\n  readonly mutex: Mutex\n  readonly keystore: Keystore\n\n  constructor(jobType: JobType, keystore: Keystore) {\n    this.jobType = jobType\n    this.mutex = new Mutex()\n    this.keystore = keystore\n  }\n\n  get protoJobType(): keystore.JobType {\n    return getProtoJobType(this.jobType)\n  }\n\n  async run<T>(callback: UpdateJob<T>): Promise<T> {\n    return this.mutex.runExclusive(async () => {\n      const lastRun = await this.getLastRunTime()\n      const startTime = new Date()\n      const result = await callback(lastRun)\n      await this.setLastRunTime(startTime)\n      return result\n    })\n  }\n\n  private async getLastRunTime(): Promise<Date | undefined> {\n    const { lastRunNs } = await this.keystore.getRefreshJob(\n      keystore.GetRefreshJobRequest.fromPartial({\n        jobType: this.protoJobType,\n      })\n    )\n    if (lastRunNs.equals(Long.fromNumber(0))) {\n      return undefined\n    }\n    return nsToDate(lastRunNs)\n  }\n\n  private async setLastRunTime(lastRun: Date): Promise<void> {\n    await this.keystore.setRefreshJob({\n      jobType: this.protoJobType,\n      lastRunNs: dateToNs(lastRun),\n    })\n  }\n}\n\nfunction getProtoJobType(jobType: 'v1' | 'v2'): keystore.JobType {\n  const protoJobType = {\n    v1: keystore.JobType.JOB_TYPE_REFRESH_V1,\n    v2: keystore.JobType.JOB_TYPE_REFRESH_V2,\n  }[jobType]\n\n  if (!protoJobType) {\n    throw new Error(`unknown job type: ${jobType}`)\n  }\n\n  return protoJobType\n}\n","// This import has to come first so that the polyfills are registered before the stream polyfills\nimport { content as proto } from '@xmtp/proto'\n\n//\n// Compression\n//\n\nexport async function decompress(\n  encoded: proto.EncodedContent,\n  maxSize: number\n): Promise<void> {\n  if (encoded.compression === undefined) {\n    return\n  }\n  const sink = { bytes: new Uint8Array(encoded.content.length) }\n  await readStreamFromBytes(encoded.content)\n    .pipeThrough(\n      new DecompressionStream(compressionIdFromCode(encoded.compression))\n    )\n    .pipeTo(writeStreamToBytes(sink, maxSize))\n  encoded.content = sink.bytes\n}\n\nexport async function compress(encoded: proto.EncodedContent): Promise<void> {\n  if (encoded.compression === undefined) {\n    return\n  }\n  const sink = { bytes: new Uint8Array(encoded.content.length / 10) }\n  await readStreamFromBytes(encoded.content)\n    .pipeThrough(\n      new CompressionStream(compressionIdFromCode(encoded.compression))\n    )\n    .pipeTo(writeStreamToBytes(sink, encoded.content.length + 1000))\n  encoded.content = sink.bytes\n}\n\nfunction compressionIdFromCode(code: proto.Compression) {\n  if (code === proto.Compression.COMPRESSION_GZIP) {\n    return 'gzip'\n  }\n  if (code === proto.Compression.COMPRESSION_DEFLATE) {\n    return 'deflate'\n  }\n  throw new Error('unrecognized compression algorithm')\n}\n\nexport function readStreamFromBytes(\n  bytes: Uint8Array,\n  chunkSize = 1024\n): ReadableStream {\n  let position = 0\n  return new ReadableStream({\n    pull(controller) {\n      if (position >= bytes.length) {\n        return controller.close()\n      }\n      let end = position + chunkSize\n      end = end <= bytes.length ? end : bytes.length\n      controller.enqueue(bytes.subarray(position, end))\n      position = end\n    },\n  })\n}\n\nexport function writeStreamToBytes(\n  sink: {\n    bytes: Uint8Array\n  },\n  maxSize: number\n): WritableStream {\n  let position = 0\n  return new WritableStream({\n    write(chunk: Uint8Array) {\n      const end = position + chunk.length\n      if (end > maxSize) {\n        throw new Error('maximum output size exceeded')\n      }\n      while (sink.bytes.length < end) {\n        sink.bytes = growBytes(sink.bytes, maxSize)\n      }\n      sink.bytes.set(chunk, position)\n      position = end\n    },\n\n    close() {\n      if (position < sink.bytes.length) {\n        sink.bytes = sink.bytes.subarray(0, position)\n      }\n    },\n  })\n}\nfunction growBytes(bytes: Uint8Array, maxSize: number): Uint8Array {\n  let newSize = bytes.length * 2\n  if (newSize > maxSize) {\n    newSize = maxSize\n  }\n  const bigger = new Uint8Array(newSize)\n  bigger.set(bytes)\n  return bigger\n}\n","import { contact, publicKey } from '@xmtp/proto'\nimport { PublicKeyBundle, SignedPublicKeyBundle } from './crypto'\n\n// Decodes contact bundles from the contact topic.\nexport function decodeContactBundle(\n  bytes: Uint8Array\n): PublicKeyBundle | SignedPublicKeyBundle {\n  let cb: contact.ContactBundle\n  try {\n    cb = contact.ContactBundle.decode(bytes)\n  } catch (e) {\n    const pb = publicKey.PublicKeyBundle.decode(bytes)\n    cb = { v1: { keyBundle: new PublicKeyBundle(pb) }, v2: undefined }\n  }\n  if (cb.v1?.keyBundle) {\n    return new PublicKeyBundle(cb.v1.keyBundle)\n  }\n  if (cb.v2?.keyBundle) {\n    return new SignedPublicKeyBundle(cb.v2.keyBundle)\n  }\n  throw new Error('unknown or invalid contact bundle')\n}\n\n// Encodes public key bundle for the contact topic.\nexport function encodeContactBundle(\n  bundle: PublicKeyBundle | SignedPublicKeyBundle\n): Uint8Array {\n  if (bundle instanceof PublicKeyBundle) {\n    return contact.ContactBundle.encode({\n      v1: { keyBundle: bundle },\n      v2: undefined,\n    }).finish()\n  } else {\n    return contact.ContactBundle.encode({\n      v1: undefined,\n      v2: { keyBundle: bundle },\n    }).finish()\n  }\n}\n","import { keccak256 } from 'js-sha3'\nimport { authn, signature, publicKey } from '@xmtp/proto'\nimport AuthData from './AuthData'\nimport { PrivateKey } from '../crypto'\nimport { hexToBytes } from '../crypto/utils'\nimport Token from './Token'\n\nexport default class LocalAuthenticator {\n  private identityKey: PrivateKey\n\n  constructor(identityKey: PrivateKey) {\n    if (!identityKey.publicKey.signature) {\n      throw new Error('Provided public key is not signed')\n    }\n\n    this.identityKey = identityKey\n  }\n\n  async createToken(timestamp?: Date): Promise<Token> {\n    const authData = AuthData.create(\n      this.identityKey.publicKey.walletSignatureAddress(),\n      timestamp || new Date()\n    )\n    const authDataBytes = authData.toBytes()\n    const digest = keccak256(authDataBytes)\n    const authSig = await this.identityKey.sign(hexToBytes(digest))\n\n    return new Token(\n      authn.Token.fromPartial({\n        identityKey: publicKey.PublicKey.fromPartial(\n          // The generated types are overly strict and don't like our additional methods\n          // eslint-disable-next-line\n          // @ts-ignore\n          this.identityKey.publicKey\n        ),\n        authDataBytes,\n        // The generated types are overly strict and don't like our additional methods\n        // eslint-disable-next-line\n        // @ts-ignore\n        authDataSignature: signature.Signature.fromPartial(authSig),\n      })\n    )\n  }\n}\n","import { authn as authnProto } from '@xmtp/proto'\nimport Long from 'long'\nimport { dateToNs } from '../utils/date'\n\nexport default class AuthData implements authnProto.AuthData {\n  walletAddr: string\n  createdNs: Long\n\n  public constructor({ walletAddr, createdNs }: authnProto.AuthData) {\n    this.walletAddr = walletAddr\n    this.createdNs = createdNs\n  }\n\n  static create(walletAddr: string, timestamp?: Date): AuthData {\n    timestamp = timestamp || new Date()\n    return new AuthData({\n      walletAddr,\n      createdNs: dateToNs(timestamp),\n    })\n  }\n\n  static fromBytes(bytes: Uint8Array): AuthData {\n    const res = authnProto.AuthData.decode(bytes)\n    return new AuthData(res)\n  }\n\n  toBytes(): Uint8Array {\n    return authnProto.AuthData.encode(this).finish()\n  }\n}\n","import { authn, signature, publicKey } from '@xmtp/proto'\nimport AuthData from './AuthData'\n\nexport default class Token implements authn.Token {\n  identityKey: publicKey.PublicKey\n  authDataBytes: Uint8Array\n  authDataSignature: signature.Signature\n  private _authData?: AuthData\n\n  constructor({ identityKey, authDataBytes, authDataSignature }: authn.Token) {\n    if (!identityKey) {\n      throw new Error('Missing identity key in token')\n    }\n    if (!authDataSignature) {\n      throw new Error('Missing authDataSignature in token')\n    }\n    this.identityKey = identityKey\n    this.authDataBytes = authDataBytes\n    this.authDataSignature = authDataSignature\n  }\n\n  // Get AuthData, generating from bytes and cacheing the first time it is accessed\n  get authData(): AuthData {\n    if (!this._authData) {\n      this._authData = AuthData.fromBytes(this.authDataBytes)\n    }\n\n    return this._authData\n  }\n\n  get ageMs(): number {\n    const now = new Date().valueOf()\n    const authData = this.authData\n    const createdAt = authData.createdNs.div(1_000_000).toNumber()\n    return now - createdAt\n  }\n\n  toBytes(): Uint8Array {\n    return authn.Token.encode(this).finish()\n  }\n\n  static fromBytes(bytes: Uint8Array): Token {\n    return new Token(authn.Token.decode(bytes))\n  }\n\n  toBase64(): string {\n    return Buffer.from(this.toBytes()).toString('base64')\n  }\n}\n","import { authn } from '@xmtp/proto'\nimport { Keystore } from '../keystore'\nimport { dateToNs } from '../utils'\nimport Token from './Token'\n\nconst wrapToken = (token: authn.Token): Token => {\n  if (token instanceof Token) {\n    return token\n  }\n  return new Token(token)\n}\n\nexport default class KeystoreAuthenticator {\n  private keystore: Keystore\n\n  constructor(keystore: Keystore) {\n    this.keystore = keystore\n  }\n\n  async createToken(timestamp?: Date): Promise<Token> {\n    const token = await this.keystore.createAuthToken({\n      timestampNs: timestamp ? dateToNs(timestamp) : undefined,\n    })\n\n    return wrapToken(token)\n  }\n}\n","import BackupClient, { BackupType, NoBackupConfiguration } from './BackupClient'\n\nconst BACKUP_TYPE = BackupType.none\nexport default class NoBackupClient implements BackupClient {\n  private configuration: NoBackupConfiguration\n\n  public static createConfiguration(): NoBackupConfiguration {\n    return {\n      type: BACKUP_TYPE,\n      version: 0,\n    }\n  }\n\n  constructor(configuration: NoBackupConfiguration) {\n    this.configuration = configuration\n  }\n\n  public get backupType(): BackupType {\n    return BACKUP_TYPE\n  }\n}\n","import BackupClient, {\n  BackupType,\n  TopicStoreBackupConfiguration,\n} from './BackupClient'\n\nconst BACKUP_TYPE = BackupType.xmtpTopicStore\nexport default class TopicStoreBackupClient implements BackupClient {\n  private configuration: TopicStoreBackupConfiguration\n\n  public static createConfiguration(\n    walletAddress: string\n  ): TopicStoreBackupConfiguration {\n    // TODO: randomly generate topic and encryption key\n    return {\n      type: BACKUP_TYPE,\n      version: 0,\n      topic: 'history-v0:' + walletAddress,\n    }\n  }\n\n  constructor(configuration: TopicStoreBackupConfiguration) {\n    this.configuration = configuration\n  }\n\n  public get backupType(): BackupType {\n    return BACKUP_TYPE\n  }\n}\n","import BackupClient, {\n  BackupConfiguration,\n  BackupType,\n  SelectBackupProvider,\n} from './BackupClient'\nimport NoBackupClient from './NoBackupClient'\nimport TopicStoreBackupClient from './TopicStoreBackupClient'\n\n/**\n * Creates a backup client of the correct provider type (e.g. xmtp backup, no backup, etc).\n * Uses an existing user preference from the backend if it exists, else prompts for a new\n * one using the `providerSelector`\n *\n * @param walletAddress The public address of the user's wallet\n * @param selectBackupProvider A callback for determining the provider to use, in the event there is no\n * existing user preference. The app can define the policy to use here (e.g. prompt the user,\n * or default to a certain provider type).\n * @returns A backup client of the correct type\n */\nexport async function createBackupClient(\n  walletAddress: string,\n  selectBackupProvider: SelectBackupProvider\n): Promise<BackupClient> {\n  const configuration = await fetchOrCreateConfiguration(\n    walletAddress,\n    selectBackupProvider\n  )\n  switch (configuration.type) {\n    case BackupType.none:\n      return new NoBackupClient(configuration)\n    case BackupType.xmtpTopicStore:\n      return new TopicStoreBackupClient(configuration)\n  }\n}\n\nexport async function fetchOrCreateConfiguration(\n  walletAddress: string,\n  selectBackupProvider: SelectBackupProvider\n): Promise<BackupConfiguration> {\n  // TODO: return existing configuration from the backend if it exists\n  let backupConfiguration: BackupConfiguration\n  const provider = await selectBackupProvider()\n  switch (provider.type) {\n    case BackupType.none:\n      backupConfiguration = NoBackupClient.createConfiguration()\n      break\n    case BackupType.xmtpTopicStore:\n      backupConfiguration =\n        TopicStoreBackupClient.createConfiguration(walletAddress)\n      break\n  }\n  // TODO: Persist new configuration to backend\n  return backupConfiguration\n}\n","export class KeystoreProviderUnavailableError extends Error {}\n","import { authn, keystore, privateKey, signature } from '@xmtp/proto'\nimport {\n  PrivateKeyBundleV1,\n  PrivateKeyBundleV2,\n} from './../crypto/PrivateKeyBundle'\nimport { InvitationV1, SealedInvitation } from './../Invitation'\nimport { PrivateKey, PublicKeyBundle } from '../crypto'\nimport { Keystore, TopicData } from './interfaces'\nimport { decryptV1, encryptV1, encryptV2, decryptV2 } from './encryption'\nimport { KeystoreError } from './errors'\nimport {\n  convertError,\n  mapAndConvertErrors,\n  toPublicKeyBundle,\n  toSignedPublicKeyBundle,\n  validateObject,\n  getKeyMaterial,\n  topicDataToV2ConversationReference,\n} from './utils'\nimport {\n  nsToDate,\n  buildDirectMessageTopicV2,\n  buildDirectMessageTopic,\n} from '../utils'\nimport { AddRequest, V1Store, V2Store } from './conversationStores'\nimport { Persistence } from './persistence'\nimport LocalAuthenticator from '../authn/LocalAuthenticator'\nimport { hmacSha256Sign } from '../crypto/ecies'\nimport crypto from '../crypto/crypto'\nimport { bytesToHex } from '../crypto/utils'\nimport Long from 'long'\n\nconst { ErrorCode } = keystore\n\n// Constant, 32 byte salt\n// DO NOT CHANGE\nconst INVITE_SALT = new TextEncoder().encode('__XMTP__INVITATION__SALT__XMTP__')\n\nasync function deriveKey(\n  secret: Uint8Array,\n  info: Uint8Array\n): Promise<CryptoKey> {\n  const key = await crypto.subtle.importKey('raw', secret, 'HKDF', false, [\n    'deriveKey',\n  ])\n  return crypto.subtle.deriveKey(\n    { name: 'HKDF', hash: 'SHA-256', salt: INVITE_SALT, info },\n    key,\n    { name: 'AES-GCM', length: 256 },\n    true,\n    ['encrypt', 'decrypt']\n  )\n}\n\nexport default class InMemoryKeystore implements Keystore {\n  private v1Keys: PrivateKeyBundleV1\n  private v2Keys: PrivateKeyBundleV2 // Do I need this?\n  private v1Store: V1Store\n  private v2Store: V2Store\n  private authenticator: LocalAuthenticator\n  private accountAddress: string | undefined\n  private jobStatePersistence: Persistence\n\n  constructor(\n    keys: PrivateKeyBundleV1,\n    v1Store: V1Store,\n    v2Store: V2Store,\n    persistence: Persistence\n  ) {\n    this.v1Keys = keys\n    this.v2Keys = PrivateKeyBundleV2.fromLegacyBundle(keys)\n    this.v1Store = v1Store\n    this.v2Store = v2Store\n    this.authenticator = new LocalAuthenticator(keys.identityKey)\n    this.jobStatePersistence = persistence\n  }\n\n  static async create(keys: PrivateKeyBundleV1, persistence: Persistence) {\n    return new InMemoryKeystore(\n      keys,\n      await V1Store.create(persistence),\n      await V2Store.create(persistence),\n      persistence\n    )\n  }\n\n  get walletAddress(): string {\n    return this.v1Keys.identityKey.publicKey.walletSignatureAddress()\n  }\n\n  async decryptV1(\n    req: keystore.DecryptV1Request\n  ): Promise<keystore.DecryptResponse> {\n    const responses = await mapAndConvertErrors(\n      req.requests,\n      async (req) => {\n        if (!validateObject(req, ['payload', 'peerKeys'], ['headerBytes'])) {\n          throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'invalid')\n        }\n        const { payload, peerKeys, headerBytes, isSender } = req\n\n        const decrypted = await decryptV1(\n          this.v1Keys,\n          toPublicKeyBundle(peerKeys),\n          payload,\n          headerBytes,\n          isSender\n        )\n\n        return {\n          decrypted,\n        }\n      },\n      keystore.ErrorCode.ERROR_CODE_UNSPECIFIED\n    )\n\n    return keystore.DecryptResponse.fromPartial({\n      responses,\n    })\n  }\n\n  async decryptV2(\n    req: keystore.DecryptV2Request\n  ): Promise<keystore.DecryptResponse> {\n    const responses = await mapAndConvertErrors(\n      req.requests,\n      async (req) => {\n        if (!validateObject(req, ['payload'], ['headerBytes'])) {\n          throw new KeystoreError(\n            keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,\n            'missing required field'\n          )\n        }\n\n        const { payload, headerBytes, contentTopic } = req\n        const topicData = this.v2Store.lookup(contentTopic)\n        if (!topicData) {\n          // This is the wrong error type. Will add to the proto repo later\n          throw new KeystoreError(\n            keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,\n            'no topic key'\n          )\n        }\n        const decrypted = await decryptV2(\n          payload,\n          getKeyMaterial(topicData.invitation),\n          headerBytes\n        )\n\n        return { decrypted }\n      },\n      ErrorCode.ERROR_CODE_UNSPECIFIED\n    )\n\n    return keystore.DecryptResponse.fromPartial({\n      responses,\n    })\n  }\n\n  async encryptV1(\n    req: keystore.EncryptV1Request\n  ): Promise<keystore.EncryptResponse> {\n    const responses = await mapAndConvertErrors(\n      req.requests,\n      async (req) => {\n        if (!validateObject(req, ['payload', 'recipient'], ['headerBytes'])) {\n          throw new KeystoreError(\n            ErrorCode.ERROR_CODE_INVALID_INPUT,\n            'missing required field'\n          )\n        }\n\n        const { recipient, payload, headerBytes } = req\n\n        return {\n          encrypted: await encryptV1(\n            this.v1Keys,\n            toPublicKeyBundle(recipient),\n            payload,\n            headerBytes\n          ),\n        }\n      },\n      ErrorCode.ERROR_CODE_UNSPECIFIED\n    )\n\n    return keystore.EncryptResponse.fromPartial({\n      responses,\n    })\n  }\n\n  async createAuthToken({\n    timestampNs,\n  }: keystore.CreateAuthTokenRequest): Promise<authn.Token> {\n    return this.authenticator.createToken(\n      timestampNs ? nsToDate(timestampNs) : undefined\n    )\n  }\n\n  async encryptV2(\n    req: keystore.EncryptV2Request\n  ): Promise<keystore.EncryptResponse> {\n    const responses = await mapAndConvertErrors(\n      req.requests,\n      async (req) => {\n        if (!validateObject(req, ['payload'], ['headerBytes'])) {\n          throw new KeystoreError(\n            ErrorCode.ERROR_CODE_INVALID_INPUT,\n            'missing required field'\n          )\n        }\n\n        const { payload, headerBytes, contentTopic } = req\n\n        const topicData = this.v2Store.lookup(contentTopic)\n        if (!topicData) {\n          throw new KeystoreError(\n            ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,\n            'no topic key'\n          )\n        }\n\n        return {\n          encrypted: await encryptV2(\n            payload,\n            getKeyMaterial(topicData.invitation),\n            headerBytes\n          ),\n        }\n      },\n      ErrorCode.ERROR_CODE_INVALID_INPUT\n    )\n\n    return keystore.EncryptResponse.fromPartial({\n      responses,\n    })\n  }\n\n  async saveInvites(\n    req: keystore.SaveInvitesRequest\n  ): Promise<keystore.SaveInvitesResponse> {\n    const toAdd: AddRequest[] = []\n\n    const responses = await mapAndConvertErrors(\n      req.requests,\n      async ({ payload, timestampNs }) => {\n        const sealed = SealedInvitation.fromBytes(payload)\n        if (sealed.v1) {\n          const headerTime = sealed.v1.header.createdNs\n          if (!headerTime.equals(timestampNs)) {\n            throw new Error('envelope and header timestamp mismatch')\n          }\n\n          const isSender = sealed.v1.header.sender.equals(\n            this.v2Keys.getPublicKeyBundle()\n          )\n\n          const invitation = await sealed.v1.getInvitation(this.v2Keys)\n          const topicData = {\n            invitation,\n            createdNs: sealed.v1.header.createdNs,\n            peerAddress: isSender\n              ? await sealed.v1.header.recipient.walletSignatureAddress()\n              : await sealed.v1.header.sender.walletSignatureAddress(),\n          }\n          toAdd.push({ ...topicData, topic: invitation.topic })\n          return {\n            conversation: topicDataToV2ConversationReference(topicData),\n          }\n        }\n      },\n      ErrorCode.ERROR_CODE_INVALID_INPUT\n    )\n\n    await this.v2Store.add(toAdd)\n\n    return keystore.SaveInvitesResponse.fromPartial({\n      responses,\n    })\n  }\n\n  async createInvite(\n    req: keystore.CreateInviteRequest\n  ): Promise<keystore.CreateInviteResponse> {\n    try {\n      if (!validateObject(req, ['recipient'], [])) {\n        throw new KeystoreError(\n          ErrorCode.ERROR_CODE_INVALID_INPUT,\n          'missing recipient'\n        )\n      }\n      const created = nsToDate(req.createdNs)\n      const recipient = toSignedPublicKeyBundle(req.recipient)\n      const myAddress = await this.getAccountAddress()\n      const theirAddress = await recipient.walletSignatureAddress()\n\n      const secret = await this.v2Keys.sharedSecret(\n        recipient,\n        this.v2Keys.getCurrentPreKey().publicKey,\n        myAddress < theirAddress\n      )\n\n      const sortedAddresses = [myAddress, theirAddress].sort()\n\n      const msgString =\n        (req.context?.conversationId || '') + sortedAddresses.join()\n\n      const msgBytes = new TextEncoder().encode(msgString)\n\n      const topic = bytesToHex(\n        await hmacSha256Sign(Buffer.from(secret), Buffer.from(msgBytes))\n      )\n\n      const infoString = [\n        '0', // sequence number\n        ...sortedAddresses,\n      ].join('|')\n      const info = new TextEncoder().encode(infoString)\n      const derivedKey = await deriveKey(secret, info)\n\n      const keyMaterial = new Uint8Array(\n        await crypto.subtle.exportKey('raw', derivedKey)\n      )\n\n      const invitation = new InvitationV1({\n        topic: buildDirectMessageTopicV2(topic),\n        aes256GcmHkdfSha256: { keyMaterial },\n        context: req.context,\n      })\n\n      const sealed = await SealedInvitation.createV1({\n        sender: this.v2Keys,\n        recipient,\n        created,\n        invitation,\n      })\n\n      const topicData = {\n        invitation,\n        topic: invitation.topic,\n        createdNs: req.createdNs,\n        peerAddress: await recipient.walletSignatureAddress(),\n      }\n\n      await this.v2Store.add([topicData])\n\n      return keystore.CreateInviteResponse.fromPartial({\n        conversation: topicDataToV2ConversationReference(topicData),\n        payload: sealed.toBytes(),\n      })\n    } catch (e) {\n      throw convertError(e as Error, ErrorCode.ERROR_CODE_INVALID_INPUT)\n    }\n  }\n\n  async signDigest(\n    req: keystore.SignDigestRequest\n  ): Promise<signature.Signature> {\n    if (!validateObject(req, ['digest'], [])) {\n      throw new KeystoreError(\n        ErrorCode.ERROR_CODE_INVALID_INPUT,\n        'missing required field'\n      )\n    }\n\n    const { digest, identityKey, prekeyIndex } = req\n    let key: PrivateKey\n    if (identityKey) {\n      key = this.v1Keys.identityKey\n    } else if (\n      typeof prekeyIndex !== 'undefined' &&\n      Number.isInteger(prekeyIndex)\n    ) {\n      key = this.v1Keys.preKeys[prekeyIndex]\n      if (!key) {\n        throw new KeystoreError(\n          ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,\n          'no prekey found'\n        )\n      }\n    } else {\n      throw new KeystoreError(\n        ErrorCode.ERROR_CODE_INVALID_INPUT,\n        'must specifify identityKey or prekeyIndex'\n      )\n    }\n\n    return key.sign(digest)\n  }\n\n  async saveV1Conversations({\n    conversations,\n  }: keystore.SaveV1ConversationsRequest): Promise<keystore.SaveV1ConversationsResponse> {\n    await this.v1Store.add(\n      conversations.map((convo) => ({\n        topic: buildDirectMessageTopic(convo.peerAddress, this.walletAddress),\n        peerAddress: convo.peerAddress,\n        createdNs: convo.createdNs,\n        invitation: undefined,\n      }))\n    )\n\n    return {}\n  }\n\n  async getV1Conversations(): Promise<keystore.GetConversationsResponse> {\n    const convos = this.v1Store.topics.map(\n      this.topicDataToV1ConversationReference.bind(this)\n    )\n\n    return { conversations: convos }\n  }\n\n  async getV2Conversations(): Promise<keystore.GetConversationsResponse> {\n    const convos = this.v2Store.topics.map((invite) =>\n      topicDataToV2ConversationReference(invite as TopicData)\n    )\n\n    convos.sort((a, b) =>\n      a.createdNs.div(1_000_000).sub(b.createdNs.div(1_000_000)).toNumber()\n    )\n\n    return keystore.GetConversationsResponse.fromPartial({\n      conversations: convos,\n    })\n  }\n\n  async getPublicKeyBundle(): Promise<PublicKeyBundle> {\n    return this.v1Keys.getPublicKeyBundle()\n  }\n\n  async getPrivateKeyBundle(): Promise<privateKey.PrivateKeyBundleV1> {\n    return this.v1Keys\n  }\n\n  async getAccountAddress(): Promise<string> {\n    if (!this.accountAddress) {\n      this.accountAddress = await this.v2Keys\n        .getPublicKeyBundle()\n        .walletSignatureAddress()\n    }\n    return this.accountAddress\n  }\n\n  async getRefreshJob({\n    jobType,\n  }: keystore.GetRefreshJobRequest): Promise<keystore.GetRefreshJobResponse> {\n    if (jobType === keystore.JobType.JOB_TYPE_UNSPECIFIED) {\n      throw new KeystoreError(\n        ErrorCode.ERROR_CODE_INVALID_INPUT,\n        'invalid job type'\n      )\n    }\n\n    const lastRunTime = await this.getLastRunTime(jobType)\n\n    return keystore.GetRefreshJobResponse.fromPartial({\n      lastRunNs: lastRunTime || Long.fromNumber(0),\n    })\n  }\n\n  async setRefreshJob({\n    jobType,\n    lastRunNs,\n  }: keystore.SetRefeshJobRequest): Promise<keystore.SetRefreshJobResponse> {\n    const key = await this.buildJobStorageKey(jobType)\n    await this.jobStatePersistence.setItem(\n      key,\n      Uint8Array.from(lastRunNs.toBytes())\n    )\n\n    return {}\n  }\n\n  private topicDataToV1ConversationReference(\n    data: keystore.TopicMap_TopicData\n  ) {\n    return {\n      peerAddress: data.peerAddress,\n      createdNs: data.createdNs,\n      topic: buildDirectMessageTopic(data.peerAddress, this.walletAddress),\n      context: undefined,\n    }\n  }\n\n  private buildJobStorageKey(jobType: keystore.JobType): string {\n    return `refreshJob/${jobType.toString()}`\n  }\n\n  private async getLastRunTime(\n    jobType: keystore.JobType\n  ): Promise<Long | undefined> {\n    const bytes = await this.jobStatePersistence.getItem(\n      this.buildJobStorageKey(jobType)\n    )\n    if (!bytes || !bytes.length) {\n      return\n    }\n\n    return Long.fromBytes([...bytes])\n  }\n\n  // This method is not defined as part of the standard Keystore API, but is available\n  // on the InMemoryKeystore to support legacy use-cases.\n  lookupTopic(topic: string) {\n    return this.v2Store.lookup(topic)\n  }\n}\n","import Long from 'long'\nimport { SignedPublicKeyBundle } from './crypto/PublicKeyBundle'\nimport { messageApi, invitation } from '@xmtp/proto'\nimport crypto from './crypto/crypto'\nimport Ciphertext from './crypto/Ciphertext'\nimport { decrypt, encrypt } from './crypto'\nimport { PrivateKeyBundleV2 } from './crypto/PrivateKeyBundle'\nimport { dateToNs, buildDirectMessageTopicV2 } from './utils'\n\nexport type InvitationContext = {\n  conversationId: string\n  metadata: { [k: string]: string }\n}\n\n/**\n * InvitationV1 is a protobuf message to be encrypted and used as the ciphertext in a SealedInvitationV1 message\n */\nexport class InvitationV1 implements invitation.InvitationV1 {\n  topic: string\n  context: InvitationContext | undefined\n  aes256GcmHkdfSha256: invitation.InvitationV1_Aes256gcmHkdfsha256 // eslint-disable-line camelcase\n\n  constructor({\n    topic,\n    context,\n    aes256GcmHkdfSha256,\n  }: invitation.InvitationV1) {\n    if (!topic || !topic.length) {\n      throw new Error('Missing topic')\n    }\n    if (\n      !aes256GcmHkdfSha256 ||\n      !aes256GcmHkdfSha256.keyMaterial ||\n      !aes256GcmHkdfSha256.keyMaterial.length\n    ) {\n      throw new Error('Missing key material')\n    }\n    this.topic = topic\n    this.context = context\n    this.aes256GcmHkdfSha256 = aes256GcmHkdfSha256\n  }\n\n  static createRandom(context?: invitation.InvitationV1_Context): InvitationV1 {\n    const topic = buildDirectMessageTopicV2(\n      Buffer.from(crypto.getRandomValues(new Uint8Array(32)))\n        .toString('base64')\n        .replace(/=*$/g, '')\n        // Replace slashes with dashes so that the topic is still easily split by /\n        // We do not treat this as needing to be valid Base64 anywhere\n        .replace('/', '-')\n    )\n    const keyMaterial = crypto.getRandomValues(new Uint8Array(32))\n\n    return new InvitationV1({\n      topic,\n      aes256GcmHkdfSha256: { keyMaterial },\n      context,\n    })\n  }\n\n  toBytes(): Uint8Array {\n    return invitation.InvitationV1.encode(this).finish()\n  }\n\n  static fromBytes(bytes: Uint8Array): InvitationV1 {\n    return new InvitationV1(invitation.InvitationV1.decode(bytes))\n  }\n}\n\n/**\n * SealedInvitationHeaderV1 is a protobuf message to be used as the headerBytes in a SealedInvitationV1\n */\nexport class SealedInvitationHeaderV1\n  implements invitation.SealedInvitationHeaderV1\n{\n  sender: SignedPublicKeyBundle\n  recipient: SignedPublicKeyBundle\n  createdNs: Long\n\n  constructor({\n    sender,\n    recipient,\n    createdNs,\n  }: invitation.SealedInvitationHeaderV1) {\n    if (!sender) {\n      throw new Error('Missing sender')\n    }\n    if (!recipient) {\n      throw new Error('Missing recipient')\n    }\n    this.sender = new SignedPublicKeyBundle(sender)\n    this.recipient = new SignedPublicKeyBundle(recipient)\n    this.createdNs = createdNs\n  }\n\n  toBytes(): Uint8Array {\n    return invitation.SealedInvitationHeaderV1.encode(this).finish()\n  }\n\n  static fromBytes(bytes: Uint8Array): SealedInvitationHeaderV1 {\n    return new SealedInvitationHeaderV1(\n      invitation.SealedInvitationHeaderV1.decode(bytes)\n    )\n  }\n}\n\nexport class SealedInvitationV1 implements invitation.SealedInvitationV1 {\n  headerBytes: Uint8Array\n  ciphertext: Ciphertext\n  private _header?: SealedInvitationHeaderV1\n  private _invitation?: InvitationV1\n\n  constructor({ headerBytes, ciphertext }: invitation.SealedInvitationV1) {\n    if (!headerBytes || !headerBytes.length) {\n      throw new Error('Missing header bytes')\n    }\n    if (!ciphertext) {\n      throw new Error('Missing ciphertext')\n    }\n    this.headerBytes = headerBytes\n    this.ciphertext = new Ciphertext(ciphertext)\n  }\n\n  /**\n   * Accessor method for the full header object\n   */\n  get header(): SealedInvitationHeaderV1 {\n    // Use cached value if already exists\n    if (this._header) {\n      return this._header\n    }\n    this._header = SealedInvitationHeaderV1.fromBytes(this.headerBytes)\n    return this._header\n  }\n\n  /**\n   * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation\n   */\n  async getInvitation(viewer: PrivateKeyBundleV2): Promise<InvitationV1> {\n    // Use cached value if already exists\n    if (this._invitation) {\n      return this._invitation\n    }\n    // The constructors for child classes will validate that this is complete\n    const header = this.header\n    let secret: Uint8Array\n    if (viewer.identityKey.matches(this.header.sender.identityKey)) {\n      secret = await viewer.sharedSecret(\n        header.recipient,\n        header.sender.preKey,\n        false\n      )\n    } else {\n      secret = await viewer.sharedSecret(\n        header.sender,\n        header.recipient.preKey,\n        true\n      )\n    }\n\n    const decryptedBytes = await decrypt(\n      this.ciphertext,\n      secret,\n      this.headerBytes\n    )\n    this._invitation = InvitationV1.fromBytes(decryptedBytes)\n    return this._invitation\n  }\n\n  toBytes(): Uint8Array {\n    return invitation.SealedInvitationV1.encode(this).finish()\n  }\n\n  static fromBytes(bytes: Uint8Array): SealedInvitationV1 {\n    return new SealedInvitationV1(invitation.SealedInvitationV1.decode(bytes))\n  }\n}\n\n/**\n * Wrapper class for SealedInvitationV1 and any future iterations of SealedInvitation\n */\nexport class SealedInvitation implements invitation.SealedInvitation {\n  v1: SealedInvitationV1 | undefined\n\n  constructor({ v1 }: invitation.SealedInvitation) {\n    if (v1) {\n      this.v1 = new SealedInvitationV1(v1)\n    } else {\n      throw new Error('Missing v1 or v2 invitation')\n    }\n  }\n\n  toBytes(): Uint8Array {\n    return invitation.SealedInvitation.encode(this).finish()\n  }\n\n  static fromBytes(bytes: Uint8Array): SealedInvitation {\n    return new SealedInvitation(invitation.SealedInvitation.decode(bytes))\n  }\n\n  static async fromEnvelope(\n    env: messageApi.Envelope\n  ): Promise<SealedInvitation> {\n    if (!env.message || !env.timestampNs) {\n      throw new Error('invalid invitation envelope')\n    }\n    const sealed = SealedInvitation.fromBytes(env.message)\n    const envelopeTime = Long.fromString(env.timestampNs)\n    const headerTime = sealed.v1?.header.createdNs\n    if (!headerTime || !headerTime.equals(envelopeTime)) {\n      throw new Error('envelope and header timestamp mistmatch')\n    }\n    return sealed\n  }\n\n  /**\n   * Create a SealedInvitation with a SealedInvitationV1 payload\n   * Will encrypt all contents and validate inputs\n   */\n  static async createV1({\n    sender,\n    recipient,\n    created,\n    invitation,\n  }: {\n    sender: PrivateKeyBundleV2\n    recipient: SignedPublicKeyBundle\n    created: Date\n    invitation: InvitationV1\n  }): Promise<SealedInvitation> {\n    const headerBytes = new SealedInvitationHeaderV1({\n      sender: sender.getPublicKeyBundle(),\n      recipient,\n      createdNs: dateToNs(created),\n    }).toBytes()\n\n    const secret = await sender.sharedSecret(\n      recipient,\n      sender.getCurrentPreKey().publicKey,\n      false\n    )\n\n    const invitationBytes = invitation.toBytes()\n    const ciphertext = await encrypt(invitationBytes, secret, headerBytes)\n\n    return new SealedInvitation({\n      v1: { headerBytes, ciphertext },\n    })\n  }\n}\n","import {\n  PublicKeyBundle,\n  encrypt,\n  PrivateKeyBundleV1,\n  decrypt,\n} from '../crypto'\nimport { ciphertext } from '@xmtp/proto'\n\nexport const decryptV1 = async (\n  myKeys: PrivateKeyBundleV1,\n  peerKeys: PublicKeyBundle,\n  ciphertext: ciphertext.Ciphertext,\n  headerBytes: Uint8Array,\n  isSender: boolean\n): Promise<Uint8Array> => {\n  const secret = await myKeys.sharedSecret(\n    peerKeys,\n    myKeys.getCurrentPreKey().publicKey, // assumes that the current preKey is what was used to encrypt\n    !isSender\n  )\n\n  return decrypt(ciphertext, secret, headerBytes)\n}\n\nexport const encryptV1 = async (\n  keys: PrivateKeyBundleV1,\n  recipient: PublicKeyBundle,\n  message: Uint8Array,\n  headerBytes: Uint8Array\n): Promise<ciphertext.Ciphertext> => {\n  const secret = await keys.sharedSecret(\n    recipient,\n    keys.getCurrentPreKey().publicKey,\n    false // assumes that the sender is the party doing the encrypting\n  )\n\n  return encrypt(message, secret, headerBytes)\n}\n\nexport const decryptV2 = (\n  ciphertext: ciphertext.Ciphertext,\n  secret: Uint8Array,\n  headerBytes: Uint8Array\n) => decrypt(ciphertext, secret, headerBytes)\n\nexport const encryptV2 = (\n  payload: Uint8Array,\n  secret: Uint8Array,\n  headerBytes: Uint8Array\n) => encrypt(payload, secret, headerBytes)\n","import { TopicData } from './interfaces'\nimport {\n  conversationReference,\n  publicKey,\n  keystore,\n  invitation,\n} from '@xmtp/proto'\nimport { PublicKeyBundle, SignedPublicKeyBundle } from '../crypto'\nimport { KeystoreError } from './errors'\nimport { WithoutUndefined } from '../utils/typedefs'\nimport { XmtpEnv } from '../Client'\n\nexport const convertError = (\n  e: Error,\n  // Default error code to apply to errors that don't have one\n  errorCode: keystore.ErrorCode\n) => {\n  if (e instanceof KeystoreError) {\n    return e\n  }\n\n  return new KeystoreError(errorCode, e.message)\n}\n\nexport const wrapResult = <T>(result: T): { result: T } => ({ result })\n\ntype ResultOrError<T> = { result: T } | { error: KeystoreError }\n\n// Map an array of items to an array of results or errors\n// Transform any errors thrown into `KeystoreError`s\nexport const mapAndConvertErrors = <Input, Output>(\n  input: Input[],\n  mapper: (input: Input) => Promise<Output> | Output,\n  // Default error code to apply to errors that don't have one\n  errorCode: keystore.ErrorCode\n): Promise<ResultOrError<Output>[]> => {\n  return Promise.all(\n    input.map(async (item: Input) => {\n      try {\n        // Be sure to await mapper result to catch errors\n        return wrapResult(await mapper(item))\n      } catch (e) {\n        return { error: convertError(e as Error, errorCode) }\n      }\n    })\n  )\n}\n\n// Wrap the bundle in our class if not already wrapped\nexport const toPublicKeyBundle = (bundle: publicKey.PublicKeyBundle) => {\n  if (bundle instanceof PublicKeyBundle) {\n    return bundle\n  }\n\n  return new PublicKeyBundle(bundle)\n}\n\n// Wrap the bundle in our class if not already wrapped\nexport const toSignedPublicKeyBundle = (\n  bundle: publicKey.SignedPublicKeyBundle\n) => {\n  if (bundle instanceof SignedPublicKeyBundle) {\n    return bundle\n  }\n\n  return new SignedPublicKeyBundle(bundle)\n}\n\n// Takes object and returns true if none of the `objectFields` are null or undefined and none of the `arrayFields` are empty\nexport const validateObject = <T>(\n  obj: T,\n  objectFields: (keyof T)[],\n  arrayFields: (keyof T)[]\n): obj is WithoutUndefined<T> => {\n  for (const field of objectFields) {\n    if (!obj[field]) {\n      throw new KeystoreError(\n        keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,\n        `Missing field ${String(field)}`\n      )\n    }\n  }\n  for (const field of arrayFields) {\n    const val = obj[field]\n    // @ts-expect-error does not know it's an array\n    if (!val || !val?.length) {\n      throw new KeystoreError(\n        keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,\n        `Missing field ${String(field)}`\n      )\n    }\n  }\n\n  return true\n}\n\nexport const getKeyMaterial = (\n  invite: invitation.InvitationV1 | undefined\n): Uint8Array => {\n  if (!invite?.aes256GcmHkdfSha256?.keyMaterial) {\n    throw new KeystoreError(\n      keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,\n      'Missing key material'\n    )\n  }\n  return invite.aes256GcmHkdfSha256.keyMaterial\n}\n\nexport const topicDataToV2ConversationReference = ({\n  invitation,\n  createdNs,\n  peerAddress,\n}: TopicData): conversationReference.ConversationReference => ({\n  context: invitation.context,\n  topic: invitation.topic,\n  peerAddress,\n  createdNs,\n})\n\nexport const isCompleteTopicData = (\n  obj: keystore.TopicMap_TopicData\n): obj is TopicData => !!obj.invitation\n\nexport const topicDataToMap = (topicMap: keystore.TopicMap) => {\n  const out = new Map<string, keystore.TopicMap_TopicData>()\n  for (const [k, v] of Object.entries(topicMap.topics)) {\n    out.set(k, v)\n  }\n  return out\n}\n\nexport const buildPersistenceKey = (env: XmtpEnv, walletAddress: string) =>\n  `xmtp/${env}/${walletAddress}/`\n","import Long from 'long'\nimport { keystore, invitation } from '@xmtp/proto'\nimport { Persistence } from './persistence/interface'\nimport { Mutex } from 'async-mutex'\nimport { isCompleteTopicData, topicDataToMap } from './utils'\nimport { numberToUint8Array, uint8ArrayToNumber } from '../utils'\n\nexport type AddRequest = {\n  topic: string\n  createdNs: Long\n  peerAddress: string\n  invitation: invitation.InvitationV1 | undefined\n}\n\nconst INVITE_STORAGE_KEY = 'invitations/v1'\nconst V1_STORAGE_KEY = 'conversation-v1/v1'\n\n/**\n * V2Store holds a simple map of topic -> TopicData and writes to the persistence layer on changes\n */\nexport class V2Store {\n  private readonly persistence: Persistence\n  private readonly persistenceKey: string\n  private readonly mutex: Mutex\n  private readonly topicMap: Map<string, keystore.TopicMap_TopicData>\n  private revision: number\n\n  constructor(\n    persistence: Persistence,\n    persistenceKey: string,\n    initialData: Map<string, keystore.TopicMap_TopicData> = new Map()\n  ) {\n    this.persistenceKey = persistenceKey\n    this.persistence = persistence\n    this.revision = 0\n    this.mutex = new Mutex()\n    this.topicMap = initialData\n  }\n\n  get revisionKey(): string {\n    return this.persistenceKey + '/revision'\n  }\n\n  static async create(persistence: Persistence): Promise<V2Store> {\n    const persistenceKey = INVITE_STORAGE_KEY\n\n    const v2Store = new V2Store(persistence, persistenceKey)\n    await v2Store.refresh()\n    return v2Store\n  }\n\n  protected validate(topicData: AddRequest): boolean {\n    return (\n      !!topicData.topic &&\n      topicData.topic.length > 0 &&\n      isCompleteTopicData(topicData)\n    )\n  }\n\n  async refresh() {\n    const currentRevision = await this.getRevision()\n    if (currentRevision > this.revision) {\n      for (const [topic, data] of await this.loadFromPersistence()) {\n        this.topicMap.set(topic, data)\n      }\n    }\n    this.revision = currentRevision\n  }\n\n  async getRevision(): Promise<number> {\n    const data = await this.persistence.getItem(this.revisionKey)\n    if (!data) {\n      return 0\n    }\n    return uint8ArrayToNumber(data)\n  }\n\n  async setRevision(number: number) {\n    await this.persistence.setItem(this.revisionKey, numberToUint8Array(number))\n  }\n\n  async loadFromPersistence(): Promise<\n    Map<string, keystore.TopicMap_TopicData>\n  > {\n    const rawData = await this.persistence.getItem(this.persistenceKey)\n    if (!rawData) {\n      return new Map()\n    }\n    return topicDataToMap(keystore.TopicMap.decode(rawData))\n  }\n\n  async store() {\n    await this.persistence.setItem(this.persistenceKey, this.toBytes())\n    this.revision++\n    await this.setRevision(this.revision)\n  }\n\n  async add(topicData: AddRequest[]): Promise<void> {\n    await this.mutex.runExclusive(async () => {\n      await this.refresh()\n      let isDirty = false\n      for (const row of topicData) {\n        if (!this.validate(row)) {\n          console.warn('Invalid topic data', row.topic)\n          continue\n        }\n        const { topic, ...data } = row\n        // This will not overwrite any existing values. First invite found in the store for a given topic will always be used\n        // Duplicates do not throw errors\n        if (!this.topicMap.has(topic)) {\n          this.topicMap.set(topic, data)\n          isDirty = true\n        }\n      }\n      // Only write to persistence once, and only if we have added new invites\n      if (isDirty) {\n        await this.store()\n      }\n    })\n  }\n\n  get topics(): keystore.TopicMap_TopicData[] {\n    return [...this.topicMap.values()]\n  }\n\n  lookup(topic: string): keystore.TopicMap_TopicData | undefined {\n    return this.topicMap.get(topic)\n  }\n\n  private toBytes(): Uint8Array {\n    return keystore.TopicMap.encode({\n      topics: Object.fromEntries(this.topicMap),\n    }).finish()\n  }\n}\n\nexport class V1Store extends V2Store {\n  static async create(persistence: Persistence): Promise<V1Store> {\n    const persistenceKey = V1_STORAGE_KEY\n    const v1Store = new V1Store(persistence, persistenceKey)\n    await v1Store.refresh()\n\n    return v1Store\n  }\n\n  protected override validate(topicData: AddRequest) {\n    return !!(\n      topicData.topic &&\n      topicData.topic.length &&\n      topicData.peerAddress?.length > 0\n    )\n  }\n}\n","// This file is taken from `bitchan/eccrypto` and ported to TS. All references to `nodeCrypto` have been replaced with `browserCrypto`\n/**\n * `elliptic` is a CommonJS module and has issues with named imports\n * DO NOT CHANGE THIS TO A NAMED IMPORT\n */\nimport elliptic from 'elliptic'\nimport crypto from './crypto'\nconst EC = elliptic.ec\nconst ec = new EC('secp256k1')\n\nconst subtle = crypto.subtle\n\nconst EC_GROUP_ORDER = Buffer.from(\n  'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141',\n  'hex'\n)\nconst ZERO32 = Buffer.alloc(32, 0)\n\nexport type Ecies = {\n  iv: Buffer\n  ephemeralPublicKey: Buffer\n  ciphertext: Buffer\n  mac: Buffer\n}\n\nfunction assert(condition: boolean, message: string) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed')\n  }\n}\n\nfunction isScalar(x: unknown) {\n  return Buffer.isBuffer(x) && x.length === 32\n}\n\nfunction isValidPrivateKey(privateKey: Buffer) {\n  if (!isScalar(privateKey)) {\n    return false\n  }\n  return (\n    privateKey.compare(ZERO32) > 0 && // > 0\n    privateKey.compare(EC_GROUP_ORDER) < 0\n  ) // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1: Buffer, b2: Buffer) {\n  if (b1.length !== b2.length) {\n    return false\n  }\n  let res = 0\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i] // jshint ignore:line\n  }\n  return res === 0\n}\n\nfunction randomBytes(size: number): Buffer {\n  const arr = new Uint8Array(size)\n  crypto.getRandomValues(arr)\n  return Buffer.from(arr)\n}\n\nasync function sha512(msg: Buffer) {\n  const digest = await subtle.digest('SHA-512', msg)\n  return Buffer.from(digest)\n}\n\nfunction getAes(\n  op: 'encrypt' | 'decrypt'\n): (iv: Buffer, key: Buffer, data: Buffer) => Promise<Buffer> {\n  return function (iv: Buffer, key: Uint8Array, data: Uint8Array) {\n    return new Promise(function (resolve) {\n      const importAlgorithm = { name: 'AES-CBC' }\n      const keyp = subtle.importKey('raw', key, importAlgorithm, false, [op])\n      return keyp\n        .then(function (cryptoKey) {\n          const encAlgorithm = { name: 'AES-CBC', iv }\n          return subtle[op](encAlgorithm, cryptoKey, data)\n        })\n        .then(function (result) {\n          resolve(Buffer.from(new Uint8Array(result)))\n        })\n    })\n  }\n}\n\nconst aesCbcEncrypt = getAes('encrypt')\nconst aesCbcDecrypt = getAes('decrypt')\n\nexport async function hmacSha256Sign(key: Buffer, msg: Buffer) {\n  const newKey = await subtle.importKey(\n    'raw',\n    key,\n    { name: 'HMAC', hash: { name: 'SHA-256' } },\n    false,\n    ['sign']\n  )\n\n  return Buffer.from(\n    await subtle.sign({ name: 'HMAC', hash: 'SHA-256' }, newKey, msg)\n  )\n}\n\nasync function hmacSha256Verify(key: Buffer, msg: Buffer, sig: Buffer) {\n  const expectedSig = await hmacSha256Sign(key, msg)\n  return equalConstTime(expectedSig, sig)\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n *\n * @returns {Buffer} A 32-byte private key.\n * @function\n */\nexport function generatePrivate() {\n  let privateKey = randomBytes(32)\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32)\n  }\n  return privateKey\n}\n\nexport function getPublic(privateKey: Buffer) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, 'Bad private key')\n  assert(isValidPrivateKey(privateKey), 'Bad private key')\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic('array'))\n}\n\n/**\n * Get compressed version of public key.\n */\nexport function getPublicCompressed(privateKey: Buffer) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, 'Bad private key')\n  assert(isValidPrivateKey(privateKey), 'Bad private key')\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true\n  return Buffer.from(\n    ec.keyFromPrivate(privateKey).getPublic(compressed, 'array')\n  )\n}\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexport function sign(privateKey: Buffer, msg: Buffer) {\n  return new Promise(function (resolve) {\n    assert(privateKey.length === 32, 'Bad private key')\n    assert(isValidPrivateKey(privateKey), 'Bad private key')\n    assert(msg.length > 0, 'Message should not be empty')\n    assert(msg.length <= 32, 'Message is too long')\n    resolve(Buffer.from(ec.sign(msg, privateKey, { canonical: true }).toDER()))\n  })\n}\n\nexport function verify(publicKey: Buffer, msg: Buffer, sig: Buffer) {\n  return new Promise(function (resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, 'Bad public key')\n    if (publicKey.length === 65) {\n      assert(publicKey[0] === 4, 'Bad public key')\n    }\n    if (publicKey.length === 33) {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, 'Bad public key')\n    }\n    assert(msg.length > 0, 'Message should not be empty')\n    assert(msg.length <= 32, 'Message is too long')\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null)\n    } else {\n      reject(new Error('Bad signature'))\n    }\n  })\n}\n\nexport function derive(\n  privateKeyA: Buffer,\n  publicKeyB: Buffer\n): Promise<Buffer> {\n  return new Promise(function (resolve) {\n    assert(Buffer.isBuffer(privateKeyA), 'Bad private key')\n    assert(Buffer.isBuffer(publicKeyB), 'Bad public key')\n    assert(privateKeyA.length === 32, 'Bad private key')\n    assert(isValidPrivateKey(privateKeyA), 'Bad private key')\n    assert(\n      publicKeyB.length === 65 || publicKeyB.length === 33,\n      'Bad public key'\n    )\n    if (publicKeyB.length === 65) {\n      assert(publicKeyB[0] === 4, 'Bad public key')\n    }\n    if (publicKeyB.length === 33) {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, 'Bad public key')\n    }\n    const keyA = ec.keyFromPrivate(privateKeyA)\n    const keyB = ec.keyFromPublic(publicKeyB)\n    const Px = keyA.derive(keyB.getPublic()) // BN instance\n    resolve(Buffer.from(Px.toArray()))\n  })\n}\n\nexport async function encrypt(\n  publicKeyTo: Buffer,\n  msg: Buffer,\n  opts?: { ephemPrivateKey?: Buffer; iv?: Buffer } | undefined\n) {\n  opts = opts || {}\n  // Take IV from opts or generate randomly\n  const iv = opts?.iv || randomBytes(16)\n  let ephemPrivateKey = opts?.ephemPrivateKey || randomBytes(32)\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    if (opts?.ephemPrivateKey) {\n      throw new Error('ephemPrivateKey is not valid')\n    }\n    ephemPrivateKey = randomBytes(32)\n  }\n  // Get the public key from the ephemeral private key\n  const ephemeralPublicKey = getPublic(ephemPrivateKey)\n\n  const hash = await sha512(await derive(ephemPrivateKey, publicKeyTo))\n  const encryptionKey = hash.slice(0, 32)\n  const macKey = hash.slice(32)\n  const ciphertext = await aesCbcEncrypt(iv, encryptionKey, msg)\n\n  // Get a MAC\n  const dataToMac = Buffer.concat([iv, ephemeralPublicKey, ciphertext])\n  const mac = await hmacSha256Sign(macKey, dataToMac)\n\n  // Return the payload\n  return {\n    iv,\n    ephemeralPublicKey,\n    ciphertext,\n    mac,\n  }\n}\n\nexport async function decrypt(privateKey: Buffer, opts: Ecies) {\n  const px = await derive(privateKey, opts.ephemeralPublicKey)\n  const hash = await sha512(px)\n  const encryptionKey = hash.slice(0, 32)\n  const macKey = hash.slice(32)\n  const dataToMac = Buffer.concat([\n    opts.iv,\n    opts.ephemeralPublicKey,\n    opts.ciphertext,\n  ])\n  assert(await hmacSha256Verify(macKey, dataToMac, opts.mac), 'Bad mac')\n\n  return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext)\n}\n","import { messageApi } from '@xmtp/proto'\nimport type { ApiClient } from '../../ApiClient'\nimport { Authenticator } from '../../authn'\nimport { buildUserPrivateStoreTopic } from '../../utils/topic'\nimport { Persistence } from './interface'\n\nexport default class TopicPersistence implements Persistence {\n  apiClient: ApiClient\n  constructor(apiClient: ApiClient) {\n    this.apiClient = apiClient\n  }\n\n  // Returns the first record in a topic if it is present.\n  async getItem(key: string): Promise<Uint8Array | null> {\n    for await (const env of this.apiClient.queryIterator(\n      { contentTopic: this.buildTopic(key) },\n      {\n        pageSize: 1,\n        direction: messageApi.SortDirection.SORT_DIRECTION_DESCENDING,\n      }\n    )) {\n      if (!env.message) continue\n      try {\n        return Uint8Array.from(env.message)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n\n    return null\n  }\n\n  async setItem(key: string, value: Uint8Array): Promise<void> {\n    const keys = Uint8Array.from(value)\n    await this.apiClient.publish([\n      {\n        contentTopic: this.buildTopic(key),\n        message: keys,\n      },\n    ])\n  }\n\n  setAuthenticator(authenticator: Authenticator): void {\n    this.apiClient.setAuthenticator(authenticator)\n  }\n\n  private buildTopic(key: string): string {\n    return buildUserPrivateStoreTopic(key)\n  }\n}\n","import { Persistence } from './interface'\n\nexport default class BrowserStoragePersistence implements Persistence {\n  storage: Storage\n  constructor(storage: Storage) {\n    this.storage = storage\n  }\n\n  static create(): BrowserStoragePersistence {\n    if (typeof localStorage === 'undefined') {\n      throw new Error('Missing LocalStorage. Use ephemeralPersistence instead')\n    }\n    return new BrowserStoragePersistence(localStorage)\n  }\n\n  async getItem(key: string): Promise<Uint8Array | null> {\n    const value = this.storage.getItem(key)\n    if (value === null) {\n      return null\n    }\n    return Uint8Array.from(Buffer.from(value, 'binary'))\n  }\n\n  async setItem(key: string, value: Uint8Array): Promise<void> {\n    this.storage.setItem(key, Buffer.from(value).toString('binary'))\n  }\n}\n","// Fully in-memory polyfill for the browser storage API.\n// Borrowed from https://github.com/MitchellCash/node-storage-polyfill but implemented as a ponyfill instead of a polyfill\n\nexport default class LocalStoragePonyfill implements Storage {\n  store: Map<string, string>\n  constructor() {\n    this.store = new Map()\n  }\n\n  get length(): number {\n    return this.store.size\n  }\n\n  clear(): void {\n    this.store = new Map()\n  }\n\n  getItem(key: string): string | null {\n    this.validateString(key)\n\n    if (this.store.has(key)) {\n      return String(this.store.get(key))\n    }\n\n    return null\n  }\n\n  key(index: number): string | null {\n    if (index === undefined) {\n      // This is the TypeError implemented in Chrome, Firefox throws \"Storage.key: At least 1\n      // argument required, but only 0 passed\".\n      throw new TypeError(\n        \"Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.\"\n      )\n    }\n\n    const keys = [...this.store.keys()]\n\n    if (index >= keys.length) {\n      return null\n    }\n\n    return keys[index]\n  }\n\n  removeItem(key: string): void {\n    this.validateString(key)\n    this.store.delete(key)\n  }\n\n  setItem(key: string, value: string): void {\n    this.validateString(key)\n    this.validateString(value)\n    this.store.set(String(key), String(value))\n  }\n\n  private validateString(val: string): void {\n    if (!(typeof val === 'string')) {\n      throw new TypeError('Key must be a string')\n    }\n  }\n}\n","import BrowserStoragePersistence from './BrowserStoragePersistence'\nimport LocalStoragePonyfill from './LocalStoragePonyfill'\n\nexport default class InMemoryPersistence extends BrowserStoragePersistence {\n  static create() {\n    return new BrowserStoragePersistence(new LocalStoragePonyfill())\n  }\n}\n","import { Persistence } from './interface'\n\nexport default class PrefixedPersistence {\n  prefix: string\n  persistence: Persistence\n\n  constructor(prefix: string, persistence: Persistence) {\n    this.prefix = prefix\n    this.persistence = persistence\n  }\n\n  getItem(key: string) {\n    return this.persistence.getItem(this.buildKey(key))\n  }\n\n  setItem(key: string, value: Uint8Array) {\n    return this.persistence.setItem(this.buildKey(key), value)\n  }\n\n  private buildKey(key: string) {\n    return this.prefix + key\n  }\n}\n","import { Persistence } from './interface'\nimport { Ecies, getPublic, encrypt, decrypt } from '../../crypto/ecies'\nimport {\n  PrivateKey,\n  SignedEciesCiphertext,\n  SignedPrivateKey,\n} from '../../crypto'\n\n/**\n * EncryptedPersistence is a Persistence implementation that uses ECIES to encrypt all values\n * ECIES encryption protects against unauthorized reads, but not unauthorized writes.\n * A third party with access to the underlying store could write malicious data using the public key of the owner\n */\nexport default class EncryptedPersistence implements Persistence {\n  private persistence: Persistence\n  private privateKey: PrivateKey | SignedPrivateKey\n  private privateKeyBytes: Buffer\n  private publicKey: Buffer\n\n  constructor(\n    persistence: Persistence,\n    privateKey: PrivateKey | SignedPrivateKey\n  ) {\n    this.persistence = persistence\n    this.privateKey = privateKey\n    this.privateKeyBytes = Buffer.from(privateKey.secp256k1.bytes)\n    this.publicKey = getPublic(this.privateKeyBytes)\n  }\n\n  async getItem(key: string): Promise<Uint8Array | null> {\n    const encrypted = await this.persistence.getItem(key)\n    if (encrypted) {\n      return this.decrypt(encrypted)\n    }\n    return null\n  }\n\n  async setItem(key: string, value: Uint8Array): Promise<void> {\n    const encrypted = await this.encrypt(value)\n    await this.persistence.setItem(key, encrypted)\n  }\n\n  private async encrypt(value: Uint8Array): Promise<Uint8Array> {\n    const ecies = await encrypt(this.publicKey, Buffer.from(value))\n    return this.serializeEcies(ecies)\n  }\n\n  private async decrypt(value: Uint8Array): Promise<Uint8Array> {\n    const ecies = await this.deserializeEcies(value)\n    const result = await decrypt(this.privateKeyBytes, ecies)\n    return Uint8Array.from(result)\n  }\n\n  private async serializeEcies(data: Ecies): Promise<Uint8Array> {\n    // This will create and sign a `SignedEciesCiphertext` payload based on the provided data\n    const protoVal = await SignedEciesCiphertext.create(data, this.privateKey)\n    return protoVal.toBytes()\n  }\n\n  private async deserializeEcies(data: Uint8Array): Promise<Ecies> {\n    const protoVal = SignedEciesCiphertext.fromBytes(data)\n    // Verify the signature upon deserializing\n    if (!(await protoVal.verify(this.privateKey.publicKey))) {\n      throw new Error('signature validation failed')\n    }\n    const ecies = protoVal.ciphertext\n\n    return {\n      ciphertext: Buffer.from(ecies.ciphertext),\n      mac: Buffer.from(ecies.mac),\n      iv: Buffer.from(ecies.iv),\n      ephemeralPublicKey: Buffer.from(ecies.ephemeralPublicKey),\n    }\n  }\n}\n","import { PrivateKeyBundleV2 } from './../../crypto/PrivateKeyBundle'\nimport { PrivateKeyBundleV1 } from '../../crypto/PrivateKeyBundle'\nimport { EncryptedPersistence, PrefixedPersistence } from '../persistence'\nimport { KeystoreProviderOptions } from './interfaces'\nimport { buildPersistenceKey } from '../utils'\nimport EphemeralPersistence from '../persistence/InMemoryPersistence'\n\nexport const buildPersistenceFromOptions = async (\n  opts: KeystoreProviderOptions,\n  keys: PrivateKeyBundleV1 | PrivateKeyBundleV2\n) => {\n  if (!opts.persistConversations) {\n    return EphemeralPersistence.create()\n  }\n  const address = await keys.identityKey.publicKey.walletSignatureAddress()\n  const prefix = buildPersistenceKey(opts.env, address)\n  const basePersistence = opts.basePersistence\n  const shouldEncrypt = !opts.disablePersistenceEncryption\n\n  return new PrefixedPersistence(\n    prefix,\n    shouldEncrypt\n      ? new EncryptedPersistence(basePersistence, keys.identityKey)\n      : basePersistence\n  )\n}\n","import { utils } from 'ethers'\nimport { Signer } from '../../types/Signer'\nimport crypto from '../../crypto/crypto'\nimport {\n  PrivateKeyBundleV1,\n  decodePrivateKeyBundle,\n  decrypt,\n  encrypt,\n  PrivateKeyBundleV2,\n} from '../../crypto'\nimport type { PreEventCallback } from '../../Client'\nimport { LocalAuthenticator } from '../../authn'\nimport { bytesToHex, hexToBytes } from '../../crypto/utils'\nimport Ciphertext from '../../crypto/Ciphertext'\nimport { privateKey as proto } from '@xmtp/proto'\nimport TopicPersistence from '../persistence/TopicPersistence'\n\nconst KEY_BUNDLE_NAME = 'key_bundle'\n/**\n * EncryptedKeyStore wraps Store to enable encryption of private key bundles\n * using a wallet signature.\n */\nexport default class NetworkKeyManager {\n  private persistence: TopicPersistence\n  private signer: Signer\n  private preEnableIdentityCallback?: PreEventCallback\n\n  constructor(\n    signer: Signer,\n    persistence: TopicPersistence,\n    preEnableIdentityCallback?: PreEventCallback\n  ) {\n    this.signer = signer\n    this.persistence = persistence\n    this.preEnableIdentityCallback = preEnableIdentityCallback\n  }\n\n  private async getStorageAddress(name: string): Promise<string> {\n    // I think we want to namespace the storage address by wallet\n    // This will allow us to support switching between multiple wallets in the same browser\n    let walletAddress = await this.signer.getAddress()\n    walletAddress = utils.getAddress(walletAddress)\n    return `${walletAddress}/${name}`\n  }\n\n  // Retrieve a private key bundle for the active wallet address in the signer\n  async loadPrivateKeyBundle(): Promise<PrivateKeyBundleV1 | null> {\n    const storageBuffer = await this.persistence.getItem(\n      await this.getStorageAddress(KEY_BUNDLE_NAME)\n    )\n    if (!storageBuffer) {\n      return null\n    }\n\n    const [bundle, needsUpdate] = await this.fromEncryptedBytes(\n      this.signer,\n      Uint8Array.from(storageBuffer)\n    )\n    // If a versioned bundle is not found, the legacy bundle needs to be resaved to the store in\n    // the new format. Once all bundles have been upgraded, this migration code can be removed.\n    if (needsUpdate) {\n      await this.storePrivateKeyBundle(bundle)\n    }\n    return bundle\n  }\n\n  // Store the private key bundle at an address generated based on the active wallet in the signer\n  async storePrivateKeyBundle(bundle: PrivateKeyBundleV1): Promise<void> {\n    const keyAddress = await this.getStorageAddress(KEY_BUNDLE_NAME)\n    const encodedBundle = await this.toEncryptedBytes(bundle, this.signer)\n    // We need to setup the Authenticator so that the underlying store can publish messages without error\n    if (typeof this.persistence.setAuthenticator === 'function') {\n      this.persistence.setAuthenticator(\n        new LocalAuthenticator(bundle.identityKey)\n      )\n    }\n\n    await this.persistence.setItem(keyAddress, encodedBundle)\n  }\n\n  // encrypts/serializes the bundle for storage\n  async toEncryptedBytes(\n    bundle: PrivateKeyBundleV1,\n    wallet: Signer\n  ): Promise<Uint8Array> {\n    // serialize the contents\n    const bytes = bundle.encode()\n    const wPreKey = crypto.getRandomValues(new Uint8Array(32))\n    const input = storageSigRequestText(wPreKey)\n    const walletAddr = await wallet.getAddress()\n    if (this.preEnableIdentityCallback) {\n      await this.preEnableIdentityCallback()\n    }\n    let sig = await wallet.signMessage(input)\n\n    // Check that the signature is correct, was created using the expected\n    // input, and retry if not. This mitigates a bug in interacting with\n    // LedgerLive for iOS, where the previous signature response is\n    // returned in some cases.\n    let address = utils.verifyMessage(input, sig)\n    if (address !== walletAddr) {\n      sig = await wallet.signMessage(input)\n      console.log('invalid signature, retrying')\n\n      address = utils.verifyMessage(input, sig)\n      if (address !== walletAddr) {\n        throw new Error('invalid signature')\n      }\n    }\n\n    const secret = hexToBytes(sig)\n    const ciphertext = await encrypt(bytes, secret)\n    return proto.EncryptedPrivateKeyBundle.encode({\n      v1: {\n        walletPreKey: wPreKey,\n        ciphertext,\n      },\n    }).finish()\n  }\n\n  // decrypts/deserializes the bundle from storage bytes\n  async fromEncryptedBytes(\n    wallet: Signer,\n    bytes: Uint8Array\n  ): Promise<[PrivateKeyBundleV1, boolean]> {\n    const [eBundle, needsUpdate] = getEncryptedBundle(bytes)\n\n    if (!eBundle.walletPreKey) {\n      throw new Error('missing wallet pre-key')\n    }\n    if (!eBundle.ciphertext?.aes256GcmHkdfSha256) {\n      throw new Error('missing bundle ciphertext')\n    }\n\n    if (this.preEnableIdentityCallback) {\n      await this.preEnableIdentityCallback()\n    }\n    const secret = hexToBytes(\n      await wallet.signMessage(storageSigRequestText(eBundle.walletPreKey))\n    )\n\n    // Ledger uses the last byte = v=[0,1,...] but Metamask and other wallets generate with\n    // v+27 as the last byte. We need to support both for interoperability. Doing this\n    // on the decryption side provides an immediate retroactive fix.\n    // Ledger is using the canonical way, whereas Ethereum adds 27 due to some legacy stuff\n    // https://github.com/ethereum/go-ethereum/issues/19751#issuecomment-504900739\n    try {\n      // Try the original version of the signature first\n      const ciphertext = new Ciphertext(eBundle.ciphertext)\n      const decrypted = await decrypt(ciphertext, secret)\n      const [bundle, needsUpdate2] = getPrivateBundle(decrypted)\n      return [bundle, needsUpdate || needsUpdate2]\n    } catch (e) {\n      // Assert that the secret is length 65 (encoded signature + recovery byte)\n      if (secret.length !== 65) {\n        throw new Error(\n          'Expected 65 bytes before trying a different recovery byte'\n        )\n      }\n      // Try the other version of recovery byte, either +27 or -27\n      const lastByte = secret[secret.length - 1]\n      let newSecret = secret.slice(0, secret.length - 1)\n      if (lastByte < 27) {\n        // This is a canonical signature, so we need to add 27 to the recovery byte and try again\n        newSecret = new Uint8Array([...newSecret, lastByte + 27])\n      } else {\n        // This canocalizes v to 0 or 1 (or maybe 2 or 3 but very unlikely)\n        newSecret = new Uint8Array([...newSecret, lastByte - 27])\n      }\n      const ciphertext = new Ciphertext(eBundle.ciphertext)\n      const decrypted = await decrypt(ciphertext, newSecret)\n      const [bundle, needsUpdate2] = getPrivateBundle(decrypted)\n      return [bundle, needsUpdate || needsUpdate2]\n    }\n  }\n}\n\n// getEncryptedV1Bundle returns the decoded bundle from the provided bytes. If there is an error decoding the bundle it attempts\n// to decode the bundle as a legacy bundle. Additionally return whether the bundle is in the expected format.\nfunction getEncryptedBundle(\n  bytes: Uint8Array\n): [proto.EncryptedPrivateKeyBundleV1, boolean] {\n  try {\n    const b = proto.EncryptedPrivateKeyBundle.decode(bytes)\n    if (b.v1) {\n      return [b.v1, false]\n    }\n  } catch (e) {\n    return [proto.EncryptedPrivateKeyBundleV1.decode(bytes), true]\n  }\n  throw new Error('unrecognized encrypted private key bundle version')\n}\n\n// getPrivateV1Bundle returns the decoded bundle from the provided bytes. If there is an error decoding the bundle it attempts\n// to decode the bundle as a legacy bundle. Additionally return whether the bundle is in the expected format.\nfunction getPrivateBundle(bytes: Uint8Array): [PrivateKeyBundleV1, boolean] {\n  try {\n    // TODO: add support for V2\n    const b = decodePrivateKeyBundle(bytes)\n    if (b instanceof PrivateKeyBundleV2) {\n      throw new Error('V2 bundles not supported yet')\n    }\n    return [b, false]\n  } catch (e) {\n    // Adds a default fallback for older versions of the proto\n    const b = proto.PrivateKeyBundleV1.decode(bytes)\n    return [new PrivateKeyBundleV1(b), true]\n  }\n}\n\nexport function storageSigRequestText(preKey: Uint8Array): string {\n  // Note that an update to this signature request text will require\n  // addition of backward compatibility for existing encrypted bundles\n  // and/or a migration; otherwise clients will no longer be able to\n  // decrypt those bundles.\n  return (\n    'XMTP : Enable Identity\\n' +\n    `${bytesToHex(preKey)}\\n` +\n    '\\n' +\n    'For more info: https://xmtp.org/signatures/'\n  )\n}\n","import { ApiClient } from '../../ApiClient'\nimport { PrivateKeyBundleV1 } from '../../crypto'\nimport InMemoryKeystore from '../InMemoryKeystore'\nimport TopicPersistence from '../persistence/TopicPersistence'\nimport { KeystoreProviderUnavailableError } from './errors'\nimport { buildPersistenceFromOptions } from './helpers'\nimport NetworkKeyManager from './NetworkKeyManager'\nimport type { Signer } from '../../types/Signer'\nimport type { Keystore } from '../interfaces'\nimport type { KeystoreProvider, KeystoreProviderOptions } from './interfaces'\n\n/**\n * KeyGeneratorKeystoreProvider will create a new XMTP `PrivateKeyBundle` and persist it to the network\n * This provider should always be specified last in the list of `keystoreProviders` on client creation,\n * as it will overwrite any XMTP identities already on the network\n */\nexport default class KeyGeneratorKeystoreProvider implements KeystoreProvider {\n  async newKeystore(\n    opts: KeystoreProviderOptions,\n    apiClient: ApiClient,\n    wallet?: Signer\n  ): Promise<Keystore> {\n    if (!wallet) {\n      throw new KeystoreProviderUnavailableError(\n        'Wallet required to generate new keys'\n      )\n    }\n    if (opts.preCreateIdentityCallback) {\n      await opts.preCreateIdentityCallback()\n    }\n    const bundle = await PrivateKeyBundleV1.generate(wallet)\n    const manager = new NetworkKeyManager(\n      wallet,\n      new TopicPersistence(apiClient),\n      opts.preEnableIdentityCallback\n    )\n    await manager.storePrivateKeyBundle(bundle)\n\n    return InMemoryKeystore.create(\n      bundle,\n      await buildPersistenceFromOptions(opts, bundle)\n    )\n  }\n}\n","import { Signer } from './../../types/Signer'\nimport type { ApiClient } from '../../ApiClient'\nimport { KeystoreProvider, KeystoreProviderOptions } from './interfaces'\nimport NetworkKeyLoader from './NetworkKeyManager'\nimport { KeystoreProviderUnavailableError } from './errors'\nimport TopicPersistence from '../persistence/TopicPersistence'\nimport { Keystore } from '../interfaces'\nimport InMemoryKeystore from '../InMemoryKeystore'\nimport { buildPersistenceFromOptions } from './helpers'\n\n/**\n * NetworkKeystoreProvider will look on the XMTP network for an `EncryptedPrivateKeyBundle`\n * on the user's private storage topic. If found, will decrypt the bundle using a wallet\n * signature and instantiate a Keystore instance using the decrypted value.\n */\nexport default class NetworkKeystoreProvider implements KeystoreProvider {\n  async newKeystore(\n    opts: KeystoreProviderOptions,\n    apiClient: ApiClient,\n    wallet?: Signer\n  ): Promise<Keystore> {\n    if (!wallet) {\n      throw new KeystoreProviderUnavailableError('No wallet provided')\n    }\n\n    const loader = new NetworkKeyLoader(\n      wallet,\n      new TopicPersistence(apiClient),\n      opts.preEnableIdentityCallback\n    )\n    const keys = await loader.loadPrivateKeyBundle()\n    if (!keys) {\n      throw new KeystoreProviderUnavailableError('No keys found')\n    }\n\n    return InMemoryKeystore.create(\n      keys,\n      await buildPersistenceFromOptions(opts, keys)\n    )\n  }\n}\n","import { KeystoreProviderUnavailableError } from './errors'\nimport { Keystore } from '../interfaces'\nimport type { KeystoreProvider, KeystoreProviderOptions } from './interfaces'\nimport InMemoryKeystore from '../InMemoryKeystore'\nimport {\n  decodePrivateKeyBundle,\n  PrivateKeyBundleV2,\n} from '../../crypto/PrivateKeyBundle'\nimport { buildPersistenceFromOptions } from './helpers'\n\n/**\n * StaticKeystoreProvider will look for a `privateKeyOverride` in the provided options,\n * and bootstrap a Keystore using those options if provided.\n *\n * If no `privateKeyOverride` is supplied will throw a `KeystoreProviderUnavailableError` causing\n * the client to continue iterating through the `KeystoreProviders` list.\n */\nexport default class StaticKeystoreProvider implements KeystoreProvider {\n  async newKeystore(opts: KeystoreProviderOptions): Promise<Keystore> {\n    const { privateKeyOverride } = opts\n    if (!privateKeyOverride) {\n      throw new KeystoreProviderUnavailableError(\n        'No private key override provided'\n      )\n    }\n\n    const bundle = decodePrivateKeyBundle(privateKeyOverride)\n    if (bundle instanceof PrivateKeyBundleV2) {\n      throw new Error('V2 private key bundle found. Only V1 supported')\n    }\n\n    return InMemoryKeystore.create(\n      bundle,\n      await buildPersistenceFromOptions(opts, bundle)\n    )\n  }\n}\n","import { keystore as keystoreProto } from '@xmtp/proto'\nimport type { RPC } from './rpcDefinitions'\nimport { b64Decode, b64Encode } from '../utils/bytes'\nimport { KeystoreError } from './errors'\nimport { PrivateKeyBundleV1 } from '../crypto'\nimport { getEthereum } from '../utils/ethereum'\nimport type { XmtpEnv } from '../Client'\nimport { isSameMajorVersion } from '../utils/semver'\nconst {\n  GetKeystoreStatusResponse_KeystoreStatus: KeystoreStatus,\n  InitKeystoreRequest,\n  InitKeystoreResponse,\n  GetKeystoreStatusRequest,\n  GetKeystoreStatusResponse,\n} = keystoreProto\n\nexport type SnapMeta = {\n  walletAddress: string\n  env: XmtpEnv\n}\n\ntype SnapParams = {\n  meta: SnapMeta\n  req?: string\n}\n\nexport async function snapRPC<Req, Res>(\n  method: string,\n  codecs: RPC<Req, Res>,\n  req: Req,\n  meta: SnapMeta,\n  snapId: string\n): Promise<Res> {\n  let reqParam = null\n  if (codecs.req) {\n    const reqBytes = codecs.req.encode(req).finish()\n    reqParam = b64Encode(reqBytes, 0, reqBytes.length)\n  }\n\n  const responseString = await snapRequest(method, reqParam, meta, snapId)\n  if (Array.isArray(responseString)) {\n    throw new Error('Unexpected array response')\n  }\n\n  return codecs.res.decode(b64Decode(responseString))\n}\n\nexport async function snapRequest(\n  method: string,\n  req: string | null,\n  meta: SnapMeta,\n  snapId: string\n): Promise<string> {\n  const params: SnapParams = { meta }\n  if (typeof req === 'string') {\n    params.req = req\n  }\n  const response = await getEthereum().request({\n    method: 'wallet_invokeSnap',\n    params: {\n      snapId,\n      request: {\n        method,\n        params,\n      },\n    },\n  })\n\n  if (!response || typeof response !== 'object') {\n    throw new Error('No response value')\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (response as any).res as unknown as string\n}\n\nexport type Snap = {\n  permissionName: string\n  id: string\n  version: string\n  initialPermissions: Record<string, unknown>\n}\n\nexport type GetSnapsResponse = Record<string, Snap>\n\n// If a browser has multiple providers, but one of them supports MetaMask flask\n// this function will ensure that Flask is being used and return true.\n// Designed to be resistant to provider clobbering by Phantom and CBW\n// Inspired by https://github.com/Montoya/snap-connect-test/blob/main/index.html\nexport async function hasMetamaskWithSnaps() {\n  const ethereum = getEthereum()\n  // Naive way of detecting snaps support\n  if (ethereum?.isMetaMask) {\n    try {\n      await ethereum.request({\n        method: 'wallet_getSnaps',\n      })\n      return true\n    } catch {\n      // no-op\n    }\n  }\n  if (\n    typeof ethereum?.detected !== 'undefined' &&\n    Array.isArray(ethereum.detected)\n  ) {\n    for (const provider of ethereum.detected) {\n      try {\n        // Detect snaps support\n        await provider.request({\n          method: 'wallet_getSnaps',\n        })\n        // enforces MetaMask as provider\n        ethereum?.setProvider?.(provider)\n\n        return true\n      } catch {\n        // no-op\n      }\n    }\n  }\n\n  if (\n    typeof ethereum?.providers !== 'undefined' &&\n    Array.isArray(ethereum.providers)\n  ) {\n    for (const provider of ethereum.providers) {\n      try {\n        // Detect snaps support\n        await provider.request({\n          method: 'wallet_getSnaps',\n        })\n\n        window.ethereum = provider\n\n        return true\n      } catch {\n        // no-op\n      }\n    }\n  }\n\n  return false\n}\n\nexport async function getSnaps(): Promise<GetSnapsResponse> {\n  return (await getEthereum()?.request({\n    method: 'wallet_getSnaps',\n  })) as unknown as GetSnapsResponse\n}\n\nexport async function getSnap(\n  snapId: string,\n  version?: string\n): Promise<Snap | undefined> {\n  try {\n    const snaps = await getSnaps()\n\n    return Object.values(snaps).find(\n      (snap) =>\n        snap.id === snapId &&\n        (!version || isSameMajorVersion(snap.version, version))\n    )\n  } catch (e) {\n    console.warn('Failed to obtain installed snap', e)\n    return undefined\n  }\n}\n\nexport async function connectSnap(\n  snapId: string,\n  params: Record<'version' | string, unknown> = {}\n) {\n  await getEthereum()?.request({\n    method: 'wallet_requestSnaps',\n    params: {\n      [snapId]: params,\n    },\n  })\n}\n\nconst getWalletStatusCodec = {\n  req: GetKeystoreStatusRequest,\n  res: GetKeystoreStatusResponse,\n}\nexport async function getWalletStatus(meta: SnapMeta, snapId: string) {\n  const response = await snapRPC(\n    'getKeystoreStatus',\n    getWalletStatusCodec,\n    {\n      walletAddress: meta.walletAddress,\n    },\n    meta,\n    snapId\n  )\n\n  if (\n    [\n      KeystoreStatus.KEYSTORE_STATUS_UNSPECIFIED,\n      KeystoreStatus.UNRECOGNIZED,\n    ].includes(response.status)\n  ) {\n    throw new Error('No status specified in response')\n  }\n\n  return response.status\n}\n\nconst initKeystoreCodec = {\n  req: InitKeystoreRequest,\n  res: InitKeystoreResponse,\n}\nexport async function initSnap(\n  bundle: PrivateKeyBundleV1,\n  env: XmtpEnv,\n  snapId: string\n) {\n  const walletAddress = bundle.identityKey.publicKey.walletSignatureAddress()\n  const response = await snapRPC(\n    'initKeystore',\n    initKeystoreCodec,\n    {\n      v1: bundle,\n    },\n    { walletAddress, env },\n    snapId\n  )\n  if (response.error) {\n    throw new KeystoreError(response.error.code, response.error.message)\n  }\n}\n","export function getEthereum() {\n  return window.ethereum\n}\n","import { keystore, authn, publicKey, signature } from '@xmtp/proto'\nimport { Reader, Writer } from 'protobufjs/minimal'\n\ntype Codec<T> = {\n  decode(input: Reader | Uint8Array, length?: number): T\n  encode(message: T, writer?: Writer): Writer\n}\n\nexport type RPC<Req, Res> = {\n  req: Codec<Req> | null\n  res: Codec<Res>\n}\n\ntype ApiDefs = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [k: string]: RPC<any, any>\n}\n\nexport const apiDefs: ApiDefs = {\n  decryptV1: {\n    req: keystore.DecryptV1Request,\n    res: keystore.DecryptResponse,\n  },\n  encryptV1: {\n    req: keystore.EncryptV1Request,\n    res: keystore.EncryptResponse,\n  },\n  encryptV2: {\n    req: keystore.EncryptV2Request,\n    res: keystore.EncryptResponse,\n  },\n  decryptV2: {\n    req: keystore.DecryptV2Request,\n    res: keystore.DecryptResponse,\n  },\n  saveInvites: {\n    req: keystore.SaveInvitesRequest,\n    res: keystore.SaveInvitesResponse,\n  },\n  createInvite: {\n    req: keystore.CreateInviteRequest,\n    res: keystore.CreateInviteResponse,\n  },\n  createAuthToken: {\n    req: keystore.CreateAuthTokenRequest,\n    res: authn.Token,\n  },\n  signDigest: {\n    req: keystore.SignDigestRequest,\n    res: signature.Signature,\n  },\n  getPublicKeyBundle: {\n    req: null,\n    res: publicKey.PublicKeyBundle,\n  },\n  saveV1Conversations: {\n    req: keystore.SaveV1ConversationsRequest,\n    res: keystore.SaveV1ConversationsResponse,\n  },\n  getV1Conversations: {\n    req: null,\n    res: keystore.GetConversationsResponse,\n  },\n  getV2Conversations: {\n    req: null,\n    res: keystore.GetConversationsResponse,\n  },\n  getRefreshJob: {\n    req: keystore.GetRefreshJobRequest,\n    res: keystore.GetRefreshJobResponse,\n  },\n  setRefreshJob: {\n    req: keystore.SetRefeshJobRequest,\n    res: keystore.SetRefreshJobResponse,\n  },\n} as const\n","import { Keystore } from './interfaces'\nimport { SnapMeta, snapRPC } from './snapHelpers'\nimport type { XmtpEnv } from '../Client'\nimport { apiDefs } from './rpcDefinitions'\n\nasync function getResponse<T extends keyof Keystore>(\n  method: T,\n  req: Uint8Array | null,\n  meta: SnapMeta,\n  snapId: string\n): Promise<typeof apiDefs[T]['res']> {\n  return snapRPC(method, apiDefs[method], req, meta, snapId)\n}\n\nexport function SnapKeystore(\n  walletAddress: string,\n  env: XmtpEnv,\n  snapId: string\n): Keystore {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const generatedMethods: any = {}\n\n  const snapMeta: SnapMeta = {\n    walletAddress,\n    env,\n  }\n\n  for (const [method, apiDef] of Object.entries(apiDefs)) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    generatedMethods[method] = async (req: any) => {\n      if (!apiDef.req) {\n        return getResponse(method as keyof Keystore, null, snapMeta, snapId)\n      }\n\n      return getResponse(method as keyof Keystore, req, snapMeta, snapId)\n    }\n  }\n\n  return {\n    ...generatedMethods,\n    // Don't bother calling the keystore, since we already have the wallet address\n    async getAccountAddress() {\n      return walletAddress\n    },\n  }\n}\n","import { KeystoreProviderUnavailableError } from './errors'\nimport { Keystore } from '../interfaces'\nimport { KeystoreProvider, KeystoreProviderOptions } from './interfaces'\nimport { SnapKeystore } from '../SnapKeystore'\nimport {\n  connectSnap,\n  getSnap,\n  getWalletStatus,\n  hasMetamaskWithSnaps,\n  initSnap,\n} from '../snapHelpers'\nimport { keystore } from '@xmtp/proto'\nimport { Signer } from '../../types/Signer'\nimport { ApiClient } from '../../ApiClient'\nimport NetworkKeystoreProvider from './NetworkKeystoreProvider'\nimport { PrivateKeyBundleV1, decodePrivateKeyBundle } from '../../crypto'\nimport KeyGeneratorKeystoreProvider from './KeyGeneratorKeystoreProvider'\nimport type { XmtpEnv } from '../../Client'\nimport { semverGreaterThan } from '../../utils/semver'\nconst { GetKeystoreStatusResponse_KeystoreStatus: KeystoreStatus } = keystore\n\nexport const SNAP_LOCAL_ORIGIN = 'local:http://localhost:8080'\n\n/**\n * The Snap keystore provider will:\n * 1. Check if the user is capable of using Snaps\n * 2. Check if the user has already setup the Snap with the appropriate keys\n * 3. If not, will get keys from the network or create new keys and store them in the Snap\n */\nexport default class SnapKeystoreProvider implements KeystoreProvider {\n  snapId: string\n  snapVersion?: string\n\n  constructor(snapId = SNAP_LOCAL_ORIGIN, snapVersion?: string) {\n    this.snapId = snapId\n    this.snapVersion = snapVersion\n  }\n\n  async newKeystore(\n    opts: KeystoreProviderOptions,\n    apiClient: ApiClient,\n    wallet?: Signer\n  ): Promise<Keystore> {\n    if (!wallet) {\n      throw new KeystoreProviderUnavailableError('No wallet provided')\n    }\n\n    if (!(await hasMetamaskWithSnaps())) {\n      throw new KeystoreProviderUnavailableError(\n        'MetaMask with Snaps not detected'\n      )\n    }\n\n    const walletAddress = await wallet.getAddress()\n    const env = opts.env\n    const hasSnap = await getSnap(this.snapId, this.snapVersion)\n    if (!hasSnap || semverGreaterThan(this.snapVersion, hasSnap.version)) {\n      await connectSnap(\n        this.snapId,\n        this.snapVersion ? { version: this.snapVersion } : {}\n      )\n    }\n\n    if (!(await checkSnapLoaded(walletAddress, env, this.snapId))) {\n      const bundle = await bundleFromOptions(opts, apiClient, wallet)\n      await initSnap(bundle, env, this.snapId)\n    }\n\n    return SnapKeystore(walletAddress, env, this.snapId)\n  }\n}\n\nasync function createBundle(\n  opts: KeystoreProviderOptions,\n  apiClient: ApiClient,\n  wallet: Signer\n) {\n  const tmpProvider = new KeyGeneratorKeystoreProvider()\n  const tmpKeystore = await tmpProvider.newKeystore(opts, apiClient, wallet)\n  return new PrivateKeyBundleV1(await tmpKeystore.getPrivateKeyBundle())\n}\n\nasync function bundleFromOptions(\n  opts: KeystoreProviderOptions,\n  apiClient: ApiClient,\n  wallet?: Signer\n) {\n  if (opts.privateKeyOverride) {\n    const bundle = decodePrivateKeyBundle(opts.privateKeyOverride)\n    if (!(bundle instanceof PrivateKeyBundleV1)) {\n      throw new Error('Unsupported private key bundle version')\n    }\n    return bundle\n  }\n\n  if (!wallet) {\n    throw new Error('No privateKeyOverride or wallet')\n  }\n\n  return getOrCreateBundle(opts, apiClient, wallet)\n}\n\nasync function getOrCreateBundle(\n  opts: KeystoreProviderOptions,\n  apiClient: ApiClient,\n  wallet: Signer\n): Promise<PrivateKeyBundleV1> {\n  // I really don't love using other providers inside a provider. Feels like too much indirection\n  // TODO: Refactor keystore providers to better support the weird Snap flow\n  const networkProvider = new NetworkKeystoreProvider()\n  try {\n    const tmpKeystore = await networkProvider.newKeystore(\n      opts,\n      apiClient,\n      wallet\n    )\n    return new PrivateKeyBundleV1(await tmpKeystore.getPrivateKeyBundle())\n  } catch (e) {\n    if (e instanceof KeystoreProviderUnavailableError) {\n      return createBundle(opts, apiClient, wallet)\n    }\n    throw e\n  }\n}\n\nasync function checkSnapLoaded(\n  walletAddress: string,\n  env: XmtpEnv,\n  snapId: string\n) {\n  const status = await getWalletStatus({ walletAddress, env }, snapId)\n  if (status === KeystoreStatus.KEYSTORE_STATUS_INITIALIZED) {\n    return true\n  }\n  return false\n}\n","{\n  \"version\": \"1.2.2\",\n  \"package\": \"@xmtp/snap\"\n}\n","/* eslint-disable camelcase */\nimport {\n  ContentTypeId,\n  ContentCodec,\n  EncodedContent,\n  CodecRegistry,\n} from '../MessageContent'\nimport { composite as proto } from '@xmtp/proto'\n\n// xmtp.org/composite\n//\n// Composite is a generic sequence of multiple parts of arbitrary content type.\n// It can be nested arbitrarily (composite of composites).\n\nexport const ContentTypeComposite = new ContentTypeId({\n  authorityId: 'xmtp.org',\n  typeId: 'composite',\n  versionMajor: 1,\n  versionMinor: 0,\n})\n\n// Composite type defines the expected structure of values\n// that can be processed by the CompositeCodec\nexport type Composite =\n  | {\n      type: ContentTypeId\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      content: any\n    }\n  | { parts: Composite[] }\n\n// CompositeCodec implements encoding/decoding of Composite values.\n// Register this codec with the Client if you want support for Composite content.\nexport class CompositeCodec implements ContentCodec<Composite> {\n  get contentType(): ContentTypeId {\n    return ContentTypeComposite\n  }\n\n  encode(content: Composite, codecs: CodecRegistry): EncodedContent {\n    const part = this.toProto(content, codecs)\n    let composite: proto.Composite\n    if (part.composite) {\n      composite = part.composite\n    } else {\n      composite = { parts: [part] }\n    }\n    const bytes = proto.Composite.encode(composite).finish()\n    return {\n      type: ContentTypeComposite,\n      parameters: {},\n      content: bytes,\n    }\n  }\n\n  decode(content: EncodedContent, codecs: CodecRegistry): Composite {\n    return this.fromProto(\n      { composite: proto.Composite.decode(content.content), part: undefined },\n      codecs\n    )\n  }\n\n  private toProto(\n    content: Composite,\n    codecs: CodecRegistry\n  ): proto.Composite_Part {\n    if ('type' in content) {\n      const codec = codecs.codecFor(content.type)\n      if (!codec) {\n        throw new Error(`missing codec for part type ${content.type}`)\n      }\n      return {\n        part: codec.encode(content.content, codecs),\n        composite: undefined,\n      }\n    }\n    const parts = new Array<proto.Composite_Part>()\n    for (const part of content.parts) {\n      parts.push(this.toProto(part, codecs))\n    }\n    return { composite: { parts }, part: undefined }\n  }\n\n  private fromProto(\n    content: proto.Composite_Part,\n    codecs: CodecRegistry\n  ): Composite {\n    if (content.part) {\n      if (!content.part.type) {\n        throw new Error('missing part content type')\n      }\n      const contentType = new ContentTypeId(content.part.type)\n      const codec = codecs.codecFor(contentType)\n      if (!codec) {\n        throw new Error(`missing codec for part type ${contentType}`)\n      }\n      return {\n        type: contentType,\n        content: codec.decode(content.part as EncodedContent, codecs),\n      }\n    }\n    if (!content.composite) {\n      throw new Error('invalid composite')\n    }\n    const parts = new Array<Composite>()\n    for (const part of content.composite.parts) {\n      parts.push(this.fromProto(part, codecs))\n    }\n    return { parts }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  fallback(content: Composite): string | undefined {\n    return undefined\n  }\n}\n"]}